
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<meta name="HandheldFriendly" content="True"/>
<title>Bonus III - Functional Flavour</title>
<link rel="shortcut icon" href="https://raw.githubusercontent.com/prooph/proophessor/gh-pages/images/ico/prooph-logo@0.5x.png">
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://raw.githubusercontent.com/prooph/proophessor/gh-pages/images/ico/apple-touch-icon-144-precomposed.png">
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://raw.githubusercontent.com/prooph/proophessor/gh-pages/images/ico/apple-touch-icon-114-precomposed.png">
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://raw.githubusercontent.com/prooph/proophessor/gh-pages/images/ico/apple-touch-icon-72-precomposed.png">
<link rel="apple-touch-icon-precomposed" href="https://raw.githubusercontent.com/prooph/proophessor/gh-pages/images/ico/apple-touch-icon-57-precomposed.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@prooph_software">
<meta name="twitter:title" content="Event Machine">
<meta name="twitter:description" content="Rapid CQRS / ES framework for PHP with a path to refactor towards a richer domain model as needed.">
<meta name="twitter:image" content="https://proophsoftware.github.io/event-machine/img/Event_Machine_Intro.png">
    <link rel="stylesheet"
      href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.5/lumen/bootstrap.min.css">
<link rel="stylesheet"
      href="https://tobiju.github.io/share/prismjs/prism-ghcolors.css"/>
<link rel="stylesheet"
      href="https://tobiju.github.io/share/prismjs/prism-linenumbers.css"/>
<style>
    body, html {
        height: 100%;
        padding-top: 36px;
        position: relative;
    }

    img {
        max-width: 100%;
    }

    code span {
        white-space: nowrap;
    }
    code span.comment {
        white-space: pre;
    }

    .highlight {
        background: #FFFF88;
    }

    .page-wrapper {
        min-height: 100%;
        padding-bottom: 170px;
        position: relative;
    }

    .box-header {
        position: relative;
    }

    /* Header Section */
    header {
        background: white;
        color: black;
        font-size: 16px;
        font-weight: 300;
    }

    h1:first-child {
        margin-top: 0;
    }

    /* anchor link will be displayed after the static top nav */
    h1:before,
    h2:before,
    h3:before,
    h4:before,
    h5:before,
    h6:before {
        display: block;
        content: " ";
        margin-top: -64px;
        height: 64px;
        visibility: hidden;
    }

    .navbar-brand {
        padding: 0;
    }

    .navbar-brand img {
        max-height: 100%;
    }

    /* Content Section */
    #content {
        margin-bottom: 17px;
        font-size: 17px;
        min-height: 200px;
    }

    .breadcrumb {
        position: relative;
        z-index: 999;
    }

    .links {
        background: #f8f8f8;
        border-top: 1px solid #e5e5e5;
        border-bottom: 1px solid #e5e5e5;
        padding: 16px 0;
    }

    .links .prev {
        text-align: left;
    }

    .links .parent {
        text-align: center;
    }

    .links .next {
        text-align: right;
    }

    /* Search */
    .form-search {
        position: absolute;
        right: 0;
        top: 0;
        z-index: 999;
    }

    @media (max-width: 767px) {
        .form-search {
            position: relative;
            margin-top: 0;
        }
    }

    .form-search .form-control {
        border: 0;
        width: 80px;
    }

    @media (max-width: 767px) {
        .form-search .form-control {
            width: 100% !important;
        }
    }

    .form-search .list-search-results {
        position: relative;
    }

    .form-search .list-search-results ul {
        background: #eee;
        border: 1px solid inherit;
        list-style: none;
        max-height: 300px;
        overflow: auto;
        padding: 0;
        position: absolute;
        width: 100%;
        z-index: 999;
    }

    .form-search .list-search-results ul li:nth-child(even) {
        background: rgba(255, 255, 255, 0.3)
    }

    .form-search .list-search-results ul li.selected {
        background: #ccc;
    }

    .form-search .list-search-results ul li a {
        display: block;
        padding: 4px 8px;
    }

    /* TOC */
    .list-toc {
        padding: 0;
    }

    .list-toc .list-group-item {
        background: 0 none;
        position: relative;
        font-weight: bold;
        padding: 0;
        margin: 0;
    }

    .list-toc li .text-number {
        padding-left: 20px;
    }
    .list-toc li li .text-number {
        padding-left: 40px;
    }
    .list-toc li li li .text-number {
        padding-left: 60px;
    }
    .list-toc li li li li .text-number {
        padding-left: 80px;
    }
    .list-toc li li li li li .text-number {
        padding-left: 100px;
    }
    .list-toc .text-number {
        padding-left: 100px;
    }

    .list-toc .list-group-item .row {
        padding: 7px 0 7px;
    }

    .list-toc .list-group-item .bbt-toc-toggle {
        display: block;
        position: absolute;
        top: 5px;
        right: 10px;
        font-weight: normal;
    }

    .list-toc .list-group-item .bbt-toc-toggle:before {
        content: "";
        display: block;
    }

    .list-toc .list-group-item .bbt-toc-toggle.collapsed:before {
        content: "";
        display: block;
    }

    .list-toc > li:nth-child(2n+1) {
        background: rgba(0, 0, 0, 0.03);
    }

    .bbt-theme-cyborg .list-toc > li:nth-child(2n+1),
    .bbt-theme-darkly .list-toc > li:nth-child(2n+1),
    .bbt-theme-slate .list-toc > li:nth-child(2n+1),
    .bbt-theme-superhero .list-toc > li:nth-child(2n+1) {
        background: rgba(255, 255, 255, 0.05);
    }

    .list-toc .list-group-item {
        border-bottom: 0 none;
        border-left: 0 none;
        border-right: 0 none;
        font-size: inherit;
    }

    .list-toc .list-group-item:first-child {
        border-top-right-radius: 0;
        border-top-left-radius: 0;
    }

    .list-toc .list-group-item:last-child {
        border-bottom-right-radius: 0;
        border-bottom-left-radius: 0;
    }

    /* Left navigation */
    .nav-left ul li a {
        padding-top: 3px;
        padding-bottom: 3px;
        border-left: 1px solid transparent;
    }

    .nav-left ul li.active a,
    .nav-left ul li a:hover {
        background: none !important;
        color: inherit;
        border-color: inherit;
    }

    .navbar-top {
        position: relative;
    }

    .affix {
        top: 60px;
    }

    .badge {
        border-radius: 4px;
        padding: 5px;
    }

    /* Footer Section */
    footer {
        color: black;
        background: white;
        width: 100%;
        position: absolute;
        bottom: 0;
    }

    footer #copyright {
        padding: 30px;
        text-align: center;
        color: #444;
    }

    footer #copyright p {
        margin: 0;
    }

    footer #copyright span a {
        color: white;
    }

    /* Top Navigation */
    @media (max-width: 767px) {
        ul.navbar-nav {
            margin: 0 -15px
        }

        ul.navbar-nav li {
            border-radius: 0;
        }

        ul.navbar-nav li ul {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 0;
            box-shadow: none;
            display: block;
            float: none;
            left: auto;
            padding: 0;
            position: static;
        }

        ul.navbar-nav li ul li a {
            padding: 8px 30px;
        }

        ul.navbar-nav li ul li ul li a {
            padding: 6px 40px;
        }
    }

    @media (min-width: 768px) {

        ul.navbar-nav li {
            display: block;
            position: relative;
            float: left;
        }

        ul.navbar-nav li ul {
            display: none;
        }

        ul.navbar-nav li a {
            display: block;
        }

        ul.navbar-nav li:hover > ul {
            display: block;
            position: absolute;
        }

        ul.navbar-nav li:hover li {
            float: none;
        }

        ul.navbar-nav ul ul {
            left: 100%;
            top: 0;
        }
    }
</style>
    <style>
    body {
        font-size: 16px;
    }
    /* Header Section */
    header {
        font-size: 17px;
        font-weight: 400;
    }

    .dropdown-menu {
        font-size: 17px;
    }

    .alert-light {
        color: #818182;
        background-color: #fefefe;
    }

    .alert-dark {
        color: #1b1e21;
        background-color: #d6d8d9;
        border-color: #c6c8ca;
    }

    .prooph-logo {
        float: left;
        margin-left: 8px;
        margin-right: 8px;
        transition-timing-function: ease-in-out;
        transition: all 5s;
        height: 50px;
        padding: 5px;
    }

    .jumbotron {
       background-color: #04A1B0;
    }

    .jumbotron .display-1 {
        color: white;
    }

    .jumbotron .display-2 {
        color: white;
    }

    .jumbotron pre {
        display: block;
        color: #f8f8f2;
        font-size: 13px;
        margin-top: 60px;
        border-radius: 0;
        border: none;
        background: #272822;
        padding: 1em;
        padding-bottom: 0px;
        overflow: auto;
        text-shadow: 0 1px rgba(0,0,0,0.3);
        font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
        text-align: left;
        white-space: pre;
        word-spacing: normal;
        word-break: normal;
        word-wrap: normal;
        line-height: 1.5;
        -moz-tab-size: 4;
        -o-tab-size: 4;
        tab-size: 4;
        -webkit-hyphens: none;
        -moz-hyphens: none;
        -ms-hyphens: none;
        hyphens: none;
    }

    .jumbotron pre.line-numbers {
        position: relative;
        padding-left: 3.8em;
        counter-reset: linenumber;
    }

    .jumbotron pre code {
        color: white;
        margin-left: -80px;
    }


    h2.front {
        text-align: center;
        font-size: 56px;
        margin-top: 100px;
        padding: 20px;
    }

    .intro {
        margin-top: 30px;
        font-size: 24px;
        font-weight: 200;
    }

    .intro.sub-intro {
        margin-top: 15px;
        margin-bottom: 15px;
    }

    .flavour {
        height: 200px;
    }

    .flavour h3 {
        color: white;
        font-size: 30px;
    }

    .flavour h3 small {
        color: #f2f2f2;
        font-size: 20px;
    }

    .flavour.prototyping {
        background-color: #CC3340;
    }

    .flavour.functional {
        background-color: #EB6842;
    }

    .flavour.oop {
        background-color: #715671;
    }

    .flavour.mixed {
        background-color: #26896C;
    }

    .btn-get-started {
        background-color: #04A1B0;
        color: white;
        padding: 20px 26px;
        font-size: 35px;
        border-radius: 8px;
        width: 100%;
        -webkit-transition-duration: 0.4s; /* Safari */
        transition-duration: 0.4s;
    }

    .btn-get-started:hover {
        background-color: #04c8d7;
        color: white;
        border-bottom-width: 4px;
        margin-top: 0px;
    }

    .img-center {
        display: block;
        margin-left: auto;
        margin-right: auto;
        width: 50%;
    }


    #forkongithub a {
        background: #000;
        color: #fff;
        text-decoration: none;
        font-family: arial, sans-serif;
        text-align: center;
        font-weight: bold;
        padding: 5px 40px;
        font-size: 1rem;
        line-height: 2rem;
        position: relative;
        transition: 0.5s;
    }

    #forkongithub a:hover {
        background: #c11;
        color: #fff;
    }

    #forkongithub a::before, #forkongithub a::after {
        content: "";
        width: 100%;
        display: block;
        position: absolute;
        top: 1px;
        left: 0;
        height: 1px;
        background: #fff;
    }

    #forkongithub a::after {
        bottom: 1px;
        top: auto;
    }

    @media screen and (min-width: 800px) {
        #forkongithub {
            position: fixed;
            display: block;
            top: 0;
            right: 0;
            width: 200px;
            overflow: hidden;
            height: 200px;
            z-index: 1000;
        }

        #forkongithub a {
            width: 200px;
            position: absolute;
            top: 80px;
            right: -60px;
            transform: rotate(45deg);
            -webkit-transform: rotate(45deg);
            -ms-transform: rotate(45deg);
            -moz-transform: rotate(45deg);
            -o-transform: rotate(45deg);
            box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.8);
        }
    }

    @media screen and (max-width: 799px) {
        .jumbotron {
            margin-top: 60px;
        }
    }

    @media screen and (max-width: 991px) {
        .jumbotron pre {
            display: none;
        }

        .flavour {
            margin-top: 60px;
        }
    }
</style>
</head>
<body data-spy="scroll" data-target="#sideNav" data-offset="50" class="bbt-theme-lumen">
<div class="page-wrapper">
    <header>
    
<nav class="navbar navbar-default navbar-fixed-top">
    <div class="box-header container">
        <form class="form-search navbar-form navbar-right" role="search">
            <div class="form-group">
                <input type="text"
                       placeholder="Search"
                       class="js-search-input form-control"
                       data-roothref="https://event-engine.io/">

                <div class="js-search-results"></div>
            </div>
        </form>

        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
                    data-target="#js-navbar-collapse" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://event-engine.io/">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200" class="prooph-logo">
                    <defs>
                        <style>
                            .cls-1{fill:#04a1b0;}.cls-2{fill:#26896c;}.cls-3{fill:#eeca50;}.cls-4{fill:#eb6842;}.cls-5{fill:#cc3340;}.cls-6{fill:#715671;}
                        </style>
                    </defs>
                    <title>prooph-logo</title>
                    <g id="artwork">
                        <g id="Layer_5" data-name="Layer 5">
                            <path class="cls-1"
                                  d="M57.22,17,67.84,35.43a1.77,1.77,0,0,0,1.53.89h61.25a1.77,1.77,0,0,0,1.53-.89L142.78,17a1.77,1.77,0,0,0-1.53-2.66H58.76A1.77,1.77,0,0,0,57.22,17Z"/>
                            <path class="cls-2"
                                  d="M29.54,94.68l30.63-53a1.77,1.77,0,0,0,0-1.77L49.55,21.48a1.77,1.77,0,0,0-3.07,0L5.24,92.91a1.77,1.77,0,0,0,1.53,2.66H28A1.77,1.77,0,0,0,29.54,94.68Z"/>
                            <path class="cls-3"
                                  d="M60.16,158.36l-30.63-53a1.77,1.77,0,0,0-1.53-.89H6.78a1.77,1.77,0,0,0-1.53,2.66l41.24,71.43a1.77,1.77,0,0,0,3.07,0l10.61-18.38A1.77,1.77,0,0,0,60.16,158.36Z"/>
                            <path class="cls-4"
                                  d="M130.63,163.68H69.37a1.77,1.77,0,0,0-1.53.89L57.22,183a1.77,1.77,0,0,0,1.53,2.66h82.48a1.77,1.77,0,0,0,1.53-2.66l-10.61-18.38A1.77,1.77,0,0,0,130.63,163.68Z"/>
                            <path class="cls-5"
                                  d="M170.46,105.32l-30.63,53a1.77,1.77,0,0,0,0,1.77l10.61,18.38a1.77,1.77,0,0,0,3.07,0l41.24-71.43a1.77,1.77,0,0,0-1.53-2.66H172A1.77,1.77,0,0,0,170.46,105.32Z"/>
                            <path class="cls-6"
                                  d="M139.84,41.64l30.63,53a1.77,1.77,0,0,0,1.53.89h21.23a1.77,1.77,0,0,0,1.53-2.66L153.52,21.48a1.77,1.77,0,0,0-3.07,0L139.84,39.86A1.77,1.77,0,0,0,139.84,41.64Z"/>
                        </g>
                    </g>
                </svg>
            </a>

        </div>

        <div class="collapse navbar-collapse" id="js-navbar-collapse">
            
    
    <ul class="nav navbar-nav">
                        <li>
    <a href="https://event-engine.io/intro/">Introduction</a>
    
    <ul class="dropdown-menu">
                        <li>
    <a href="https://event-engine.io/intro/about.html">About Event Engine</a>

    </li>
                        <li>
    <a href="https://event-engine.io/intro/pros_and_cons.html">Pros and cons</a>

    </li>
            </ul>

    </li>
                        <li>
    <a href="https://event-engine.io/tutorial/">Tutorial</a>
    
    <ul class="dropdown-menu">
                        <li>
    <a href="https://event-engine.io/tutorial/intro.html">Introduction</a>

    </li>
                        <li>
    <a href="https://event-engine.io/tutorial/partI.html">Part I - Add A Building</a>

    </li>
                        <li>
    <a href="https://event-engine.io/tutorial/partII.html">Part II - The Building Aggregate</a>

    </li>
                        <li>
    <a href="https://event-engine.io/tutorial/partIII.html">Part III - Aggregate State</a>

    </li>
                        <li>
    <a href="https://event-engine.io/tutorial/partIV.html">Part IV - Projections and Queries</a>

    </li>
                        <li>
    <a href="https://event-engine.io/tutorial/partV.html">Part V - DRY</a>

    </li>
                        <li>
    <a href="https://event-engine.io/tutorial/partVI.html">Part VI - Check in User</a>

    </li>
                        <li>
    <a href="https://event-engine.io/tutorial/partVII.html">Part VII - The Unhappy Path</a>

    </li>
                        <li>
    <a href="https://event-engine.io/tutorial/bonusI.html">Bonus I - Custom Projection</a>

    </li>
                        <li>
    <a href="https://event-engine.io/tutorial/bonusII.html">Bonus II - Unit and Integration Tests</a>

    </li>
                        <li>
    <a href="https://event-engine.io/tutorial/bonusIII.html">Bonus III - Functional Flavour</a>

    </li>
                        <li>
    <a href="https://event-engine.io/tutorial/bonusIV.html">Bonus IV - OOP Flavour</a>

    </li>
            </ul>

    </li>
                        <li>
    <a href="https://event-engine.io/api/">API</a>
    
    <ul class="dropdown-menu">
                        <li>
    <a href="https://event-engine.io/api/set_up/">Set Up</a>
    
    <ul class="dropdown-menu">
                        <li>
    <a href="https://event-engine.io/api/set_up/installation.html">Installation</a>

    </li>
                        <li>
    <a href="https://event-engine.io/api/set_up/di.html">Dependency Injection</a>

    </li>
                        <li>
    <a href="https://event-engine.io/api/set_up/production_optimization.html">Optimize For Production</a>

    </li>
            </ul>

    </li>
                        <li>
    <a href="https://event-engine.io/api/descriptions.html">Event Engine Descriptions</a>

    </li>
                        <li>
    <a href="https://event-engine.io/api/functional_flavour.html">Functional Flavour</a>

    </li>
                        <li>
    <a href="https://event-engine.io/api/immutable_state.html">Immutable State</a>

    </li>
                        <li>
    <a href="https://event-engine.io/api/document_store/">Document Store</a>
    
    <ul class="dropdown-menu">
                        <li>
    <a href="https://event-engine.io/api/document_store/set_up.html">Document Store</a>

    </li>
            </ul>

    </li>
                        <li>
    <a href="https://event-engine.io/api/projections/">Projections</a>
    
    <ul class="dropdown-menu">
                        <li>
    <a href="https://event-engine.io/api/projections/set_up.html">Custom Projections</a>

    </li>
            </ul>

    </li>
            </ul>

    </li>
            </ul>

        </div>
    </div>
</nav>
</header>
<div class="container">
    <ol class="breadcrumb">
                        <li><a href="https://event-engine.io/">Event Engine Docs</a></li>
                                <li><a href="https://event-engine.io/tutorial/">Tutorial</a></li>
                                <li class="active">Bonus III - Functional Flavour</li>
            </ol>
    <div class="row">

                <div class="col-md-3">
            <nav class="nav-left hidden-xs hidden-sm" id="sideNav">
    <ul class="nav nav-stacked" data-spy="affix" data-offset-top="59" role="tablist">
                                <li>
                <a href="#2-11" title="Bonus&#x20;III&#x20;-&#x20;Functional&#x20;Flavour">Bonus III - Functional F...</a>
            </li>
                                <li>
                <a href="#2-11-1" title="Harden&#x20;The&#x20;Domain&#x20;Model">Harden The Domain Model</a>
            </li>
                                <li>
                <a href="#2-11-2" title="Functional&#x20;Port">Functional Port</a>
            </li>
                                <li>
                <a href="#2-11-3" title="Deserialize">Deserialize</a>
            </li>
                                <li>
                <a href="#2-11-4" title="Serialize&#x20;Payload">Serialize Payload</a>
            </li>
                                <li>
                <a href="#2-11-5" title="Decorate&#x20;Command&#x20;&#x2F;&#x20;Event">Decorate Command / Event</a>
            </li>
                                            <li>
                <a href="#2-11-6" title="Call&#x20;Command&#x20;Preprocessor">Call Command Preprocesso...</a>
            </li>
                                <li>
                <a href="#2-11-7" title="Call&#x20;Command&#x20;Controller">Call Command Controller</a>
            </li>
                                <li>
                <a href="#2-11-8" title="Call&#x20;Context&#x20;Provider">Call Context Provider</a>
            </li>
                                <li>
                <a href="#2-11-9" title="Call&#x20;Resolver">Call Resolver</a>
            </li>
                                <li>
                <a href="#2-11-10" title="Switching&#x20;The&#x20;Flavour">Switching The Flavour</a>
            </li>
                                <li>
                <a href="#2-11-11" title="Refactoring">Refactoring</a>
            </li>
            </ul>
</nav>
        </div>
                <div class="col-md-9">
<div id="section-main"><h1 id="2-11">Bonus III - Functional Flavour</h1>
<p>Event Engine has a nice feature called <strong>Flavours</strong>. A Flavour lets you customize the way Event Engine interacts with
your code. Throughout the tutorial we worked with the <strong>PrototypingFlavour</strong>, which is the default.</p>
<p>As the name suggests, the PrototypingFlavour is optimized for rapid development. For example instead of defining classes
for each type of message, Event Engine passes its default <code>Message</code> implementation to aggregate functions, process managers,
resolvers and projectors. You don't need to care about serialization and mapping.</p>
<p class="alert alert-info">If you want to try out new ideas, PrototypingFlavour is your best friend.
Following Domain-Driven Design best practices <strong>Continuous Discovery</strong> and <strong>Agile Development</strong> are key drivers for successful
projects. This requires experimentation and with the PrototypingFlavour it's easier than ever.</p>
<h2 id="2-11-1">Harden The Domain Model</h2>
<p>Experimentation is great, but at some point you'll be satisfied with the domain model and want to turn it into a clean and
robust implementation. That's very important for long-lived applications. Fortunately, Event Engine offers two additional Flavours.
One is called the <strong>FunctionalFlavour</strong> and the other one <strong>OopFlavour</strong>. Finally, you can implement your own <code>EventEngine\Runtime\Flavour</code>
to turn Event Engine into your very own CQRS / ES framework.</p>
<p>First let's look at the <strong>FunctionalFlavour</strong>. It's similar to what we did so fare, except that explicit message types are used instead of
generic Event Engine messages.</p>
<h2 id="2-11-2">Functional Port</h2>
<p>The FunctionalFlavour requires an implementation of <code>EventEngine\Runtime\Functional\Port</code>. Here you have to define custom mapping and serialization
logic for message types. Create a new class <code>MyServiceMessagePort</code> in <code>src/System/Flavour</code>:</p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\System\Flavour;

use EventEngine\Messaging\CommandDispatchResult;
use EventEngine\Messaging\Message;
use EventEngine\Messaging\MessageBag;
use EventEngine\Runtime\Functional\Port;

final class MyServiceMessagePort implements Port
{
    /**
     * @param Message $message
     * @return mixed The custom message
     */
    public function deserialize(Message $message)
    {
        // TODO: Implement deserialize() method.
    }

    /**
     * @param mixed $customMessage
     * @return array
     */
    public function serializePayload($customMessage): array
    {
        // TODO: Implement serializePayload() method.
    }

    /**
     * @param mixed $customCommand
     * @return MessageBag
     */
    public function decorateCommand($customCommand): MessageBag
    {
        // TODO: Implement decorateCommand() method.
    }

    /**
     * @param mixed $customEvent
     * @return MessageBag
     */
    public function decorateEvent($customEvent): MessageBag
    {
        // TODO: Implement decorateEvent() method.
    }

    /**
     * @param string $aggregateIdPayloadKey
     * @param mixed $command
     * @return string
     */
    public function getAggregateIdFromCommand(string $aggregateIdPayloadKey, $command): string
    {
        // TODO: Implement getAggregateIdFromCommand() method.
    }

    /**
     * @param mixed $customCommand
     * @param mixed $preProcessor Custom preprocessor
     * @return mixed|CommandDispatchResult Custom message or CommandDispatchResult
     */
    public function callCommandPreProcessor($customCommand, $preProcessor)
    {
        // TODO: Implement callCommandPreProcessor() method.
    }

    /**
     * Commands returned by the controller are dispatched automatically
     *
     * @param mixed $customCommand
     * @param mixed $controller
     * @return mixed[]|null|CommandDispatchResult Array of custom commands or null|CommandDispatchResult to indicate that no further action is required
     */
    public function callCommandController($customCommand, $controller)
    {
        // TODO: Implement callCommandController() method.
    }

    /**
     * @param mixed $customCommand
     * @param mixed $contextProvider
     * @return mixed
     */
    public function callContextProvider($customCommand, $contextProvider)
    {
        // TODO: Implement callContextProvider() method.
    }

    public function callResolver($customQuery, $resolver)
    {
        // TODO: Implement callResolver() method.
    }
}

</code></pre>
<p>We'll implement the interface step by step and define a mapping strategy along the way.</p>
<h2 id="2-11-3">Deserialize</h2>
<p>First method is <code>deserialize</code>:</p>
<pre><code class="language-php">/**
 * @param Message $message
 * @return mixed The custom message
 */
public function deserialize(Message $message)
{
    // TODO: Implement deserialize() method.
}
</code></pre>
<p>An Event Engine message is passed as argument and the method should return a custom message. The first important decision is required:</p>
<p class="alert alert-info"><strong>Which serialization technique do we want to use?</strong> Some people prefer handcrafted serialization, while others prefer conventions or serializers.
The good news is, every technique can be used! It just needs to be implemented in the Port.</p>
<p>To keep the tutorial simple, we're going to use the tools shipped with Event Engine.
That said, our messages become <code>ImmutableRecord</code>s and use the build-in serialization technique provided by <code>ImmutableRecordLogic</code>.</p>
<p class="alert alert-warning">The fact that messages are still coupled with the framework is not important here. It's our decision as developers to do it, but nothing required by Event Engine.
We could also write our own serialization mechanism or use a third-party tool like <a class="alert-link" href="https://github.com/prolic/fpp">FPP</a>.</p>
<p>Let's create some types and messages first:</p>
<p><code>src/Domain/Model/Building/BuildingId.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Model\Building;

use Ramsey\Uuid\Uuid;
use Ramsey\Uuid\UuidInterface;

final class BuildingId
{
    private $buildingId;

    public static function generate(): self
    {
        return new self(Uuid::uuid4());
    }

    public static function fromString(string $buildingId): self
    {
        return new self(Uuid::fromString($buildingId));
    }

    private function __construct(UuidInterface $buildingId)
    {
        $this-&gt;buildingId = $buildingId;
    }

    public function toString(): string
    {
        return $this-&gt;buildingId-&gt;toString();
    }

    public function equals($other): bool
    {
        if (!$other instanceof self) {
            return false;
        }

        return $this-&gt;buildingId-&gt;equals($other-&gt;buildingId);
    }

    public function __toString(): string
    {
        return $this-&gt;buildingId-&gt;toString();
    }
}

</code></pre>
<p><code>src/Domain/Model/Building/BuildingName.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Model\Building;

final class BuildingName
{
    private $name;

    public static function fromString(string $name): self
    {
        return new self($name);
    }

    private function __construct(string $name)
    {
        $this-&gt;name = $name;
    }

    public function toString(): string
    {
        return $this-&gt;name;
    }

    public function equals($other): bool
    {
        if(!$other instanceof self) {
            return false;
        }

        return $this-&gt;name === $other-&gt;name;
    }

    public function __toString(): string
    {
        return $this-&gt;name;
    }
}

</code></pre>
<p><code>src/Domain/Model/Building/Username.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Model\Building;

final class Username
{
    private $name;

    public static function fromString(string $name): self
    {
        return new self($name);
    }

    private function __construct(string $name)
    {
        $this-&gt;name = $name;
    }

    public function toString(): string
    {
        return $this-&gt;name;
    }

    public function equals($other): bool
    {
        if(!$other instanceof self) {
            return false;
        }

        return $this-&gt;name === $other-&gt;name;
    }

    public function __toString(): string
    {
        return $this-&gt;name;
    }
}

</code></pre>
<p><code>src/Domain/Model/Building/Command/AddBuilding.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Model\Building\Command;

use MyService\Domain\Model\Building\BuildingId;
use MyService\Domain\Model\Building\BuildingName;
use EventEngine\Data\ImmutableRecord;
use EventEngine\Data\ImmutableRecordLogic;

final class AddBuilding implements ImmutableRecord
{
    use ImmutableRecordLogic;

    /**
     * @var BuildingId
     */
    private $buildingId;

    /**
     * @var BuildingName
     */
    private $name;

    /**
     * @return BuildingId
     */
    public function buildingId(): BuildingId
    {
        return $this-&gt;buildingId;
    }

    /**
     * @return BuildingName
     */
    public function name(): BuildingName
    {
        return $this-&gt;name;
    }
}

</code></pre>
<p><code>src/Domain/Model/Building/Command/CheckInUser.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Model\Building\Command;

use MyService\Domain\Model\Building\BuildingId;
use MyService\Domain\Model\Building\Username;
use EventEngine\Data\ImmutableRecord;
use EventEngine\Data\ImmutableRecordLogic;

final class CheckInUser implements ImmutableRecord
{
    use ImmutableRecordLogic;

    /**
     * @var BuildingId
     */
    private $buildingId;

    /**
     * @var Username
     */
    private $name;

    /**
     * @return BuildingId
     */
    public function buildingId(): BuildingId
    {
        return $this-&gt;buildingId;
    }

    /**
     * @return Username
     */
    public function name(): Username
    {
        return $this-&gt;name;
    }
}

</code></pre>
<p><code>src/Domain/Model/Building/Command/CheckOutUser.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Model\Building\Command;

use MyService\Domain\Model\Building\BuildingId;
use MyService\Domain\Model\Building\Username;
use EventEngine\Data\ImmutableRecord;
use EventEngine\Data\ImmutableRecordLogic;

final class CheckOutUser implements ImmutableRecord
{
    use ImmutableRecordLogic;

    /**
     * @var BuildingId
     */
    private $buildingId;

    /**
     * @var Username
     */
    private $name;

    /**
     * @return BuildingId
     */
    public function buildingId(): BuildingId
    {
        return $this-&gt;buildingId;
    }

    /**
     * @return Username
     */
    public function name(): Username
    {
        return $this-&gt;name;
    }
}

</code></pre>
<p>Ok, much more classes now. Each property has its own value object like <code>BuildingId</code>, <code>BuildingName</code> and <code>Username</code>. Again, that's not a requirement but it adds type safety to
the implementation and serves as documentation. Don't worry about the amount of code. Most of it can be generated using PHPStorm templates. Event Engine docs contain useful tips (@TODO add docs link).
Another possibility is the already mentioned library <a href="https://github.com/prolic/fpp">FPP</a>.</p>
<p>With the value objects in place we've added a class for each command and implemented them as immutable records. Now we need a factory to instantiate a command with information
taken from Event Engine messages. <code>MyService\Domain\Api\Command</code> already contains command specific information. Let's add the factory there.</p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Api;

use MyService\Domain\Model\Building\Command\AddBuilding;
use MyService\Domain\Model\Building\Command\CheckInUser;
use MyService\Domain\Model\Building\Command\CheckOutUser;
use EventEngine\EventEngine;
use EventEngine\EventEngineDescription;
use EventEngine\JsonSchema\JsonSchema;

class Command implements EventEngineDescription
{
    const ADD_BUILDING = 'AddBuilding';
    const CHECK_IN_USER = 'CheckInUser';
    const CHECK_OUT_USER = 'CheckOutUser';

    const CLASS_MAP = [
        self::ADD_BUILDING =&gt; AddBuilding::class,
        self::CHECK_IN_USER =&gt; CheckInUser::class,
        self::CHECK_OUT_USER =&gt; CheckOutUser::class,
    ];

    public static function createFromNameAndPayload(string $commandName, array $payload)
    {
        $class = self::CLASS_MAP[$commandName] ?? false;

        if($class === false) {
            throw new \InvalidArgumentException("Unknown command name: $commandName");
        }

        //Commands use ImmutableRecordLogic and therefor have a fromArray method
        return $class::fromArray($payload);
    }

    public static function nameOf($command): string
    {
        $name = array_search(\get_class($command), self::CLASS_MAP);

        if($name === false) {
            throw new \InvalidArgumentException("Unknown command. Cannot find a name for class: " . \get_class($command));
        }

        return $name;
    }

    /* ... */
}

</code></pre>
<p>Finally, the factory can be used in the Port:</p>
<p><code>src/System/Flavour/MyServiceMessagePort.php</code></p>
<pre><code class="language-php">/**
 * @param Message $message
 * @return mixed The custom message
 */
public function deserialize(Message $message)
{
    switch ($message-&gt;messageType()) {
        case Message::TYPE_COMMAND:
            return Command::createFromNameAndPayload($message-&gt;messageName(), $message-&gt;payload());
            break;
    }
}
</code></pre>
<p>A similar implementation is required for events and queries:</p>
<p><code>src/Domain/Model/Building/Event/BuildingAdded.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Model\Building\Event;

use MyService\Domain\Model\Building\BuildingId;
use MyService\Domain\Model\Building\BuildingName;
use EventEngine\Data\ImmutableRecord;
use EventEngine\Data\ImmutableRecordLogic;

final class BuildingAdded implements ImmutableRecord
{
    use ImmutableRecordLogic;

    /**
     * @var BuildingId
     */
    private $buildingId;

    /**
     * @var BuildingName
     */
    private $name;

    /**
     * @return BuildingId
     */
    public function buildingId(): BuildingId
    {
        return $this-&gt;buildingId;
    }

    /**
     * @return BuildingName
     */
    public function name(): BuildingName
    {
        return $this-&gt;name;
    }
}

</code></pre>
<p><code>src/Domain/Model/Building/Event/UserCheckedIn.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Model\Building\Event;

use MyService\Domain\Model\Building\BuildingId;
use MyService\Domain\Model\Building\Username;
use EventEngine\Data\ImmutableRecord;
use EventEngine\Data\ImmutableRecordLogic;

final class UserCheckedIn implements ImmutableRecord
{
    use ImmutableRecordLogic;

    /**
     * @var BuildingId
     */
    private $buildingId;

    /**
     * @var Username
     */
    private $name;

    /**
     * @return BuildingId
     */
    public function buildingId(): BuildingId
    {
        return $this-&gt;buildingId;
    }

    /**
     * @return Username
     */
    public function name(): Username
    {
        return $this-&gt;name;
    }
}

</code></pre>
<p><code>src/Domain/Model/Building/Event/DoubleCheckInDetected.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Model\Building\Event;

use MyService\Domain\Model\Building\BuildingId;
use MyService\Domain\Model\Building\Username;
use EventEngine\Data\ImmutableRecord;
use EventEngine\Data\ImmutableRecordLogic;

final class DoubleCheckInDetected implements ImmutableRecord
{
    use ImmutableRecordLogic;

    /**
     * @var BuildingId
     */
    private $buildingId;

    /**
     * @var Username
     */
    private $name;

    /**
     * @return BuildingId
     */
    public function buildingId(): BuildingId
    {
        return $this-&gt;buildingId;
    }

    /**
     * @return Username
     */
    public function name(): Username
    {
        return $this-&gt;name;
    }
}

</code></pre>
<p><code>src/Domain/Model/Building/Event/UserCheckedOut.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Model\Building\Event;

use MyService\Domain\Model\Building\BuildingId;
use MyService\Domain\Model\Building\Username;
use EventEngine\Data\ImmutableRecord;
use EventEngine\Data\ImmutableRecordLogic;

final class UserCheckedOut implements ImmutableRecord
{
    use ImmutableRecordLogic;

    /**
     * @var BuildingId
     */
    private $buildingId;

    /**
     * @var Username
     */
    private $name;

    /**
     * @return BuildingId
     */
    public function buildingId(): BuildingId
    {
        return $this-&gt;buildingId;
    }

    /**
     * @return Username
     */
    public function name(): Username
    {
        return $this-&gt;name;
    }
}

</code></pre>
<p><code>src/Domain/Model/Building/Event/DoubleCheckOutDetected.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Model\Building\Event;

use MyService\Domain\Model\Building\BuildingId;
use MyService\Domain\Model\Building\Username;
use EventEngine\Data\ImmutableRecord;
use EventEngine\Data\ImmutableRecordLogic;

final class DoubleCheckOutDetected implements ImmutableRecord
{
    use ImmutableRecordLogic;

    /**
     * @var BuildingId
     */
    private $buildingId;

    /**
     * @var Username
     */
    private $name;

    /**
     * @return BuildingId
     */
    public function buildingId(): BuildingId
    {
        return $this-&gt;buildingId;
    }

    /**
     * @return Username
     */
    public function name(): Username
    {
        return $this-&gt;name;
    }
}

</code></pre>
<p><code>src/Domain/Api/Event.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Api;


use MyService\Domain\Model\Building\Event\BuildingAdded;
use MyService\Domain\Model\Building\Event\DoubleCheckInDetected;
use MyService\Domain\Model\Building\Event\DoubleCheckOutDetected;
use MyService\Domain\Model\Building\Event\UserCheckedIn;
use MyService\Domain\Model\Building\Event\UserCheckedOut;
use EventEngine\EventEngine;
use EventEngine\EventEngineDescription;
use EventEngine\JsonSchema\JsonSchema;

class Event implements EventEngineDescription
{
    const BUILDING_ADDED = 'BuildingAdded';
    const USER_CHECKED_IN = 'UserCheckedIn';
    const USER_CHECKED_OUT = 'UserCheckedOut';
    const DOUBLE_CHECK_IN_DETECTED = 'DoubleCheckInDetected';
    const DOUBLE_CHECK_OUT_DETECTED = 'DoubleCheckOutDetected';

    const CLASS_MAP = [
        self::BUILDING_ADDED =&gt; BuildingAdded::class,
        self::USER_CHECKED_IN =&gt; UserCheckedIn::class,
        self::USER_CHECKED_OUT =&gt; UserCheckedOut::class,
        self::DOUBLE_CHECK_IN_DETECTED =&gt; DoubleCheckInDetected::class,
        self::DOUBLE_CHECK_OUT_DETECTED =&gt; DoubleCheckOutDetected::class,
    ];

    public static function createFromNameAndPayload(string $eventName, array $payload)
    {
        $class = self::CLASS_MAP[$eventName] ?? false;

        if($class === false) {
            throw new \InvalidArgumentException("Unknown event name: $eventName");
        }

        //Commands use ImmutableRecordLogic and therefor have a fromArray method
        return $class::fromArray($payload);
    }

    public static function nameOf($event): string
    {
        $name = array_search(\get_class($event), self::CLASS_MAP);

        if($name === false) {
            throw new \InvalidArgumentException("Unknown event. Cannot find a name for class: " . \get_class($event));
        }

        return $name;
    }

    /* ... */
}

</code></pre>
<p><code>src/Domain/Resolver/Query/GetBuilding.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Resolver\Query;

use EventEngine\Data\ImmutableRecord;
use EventEngine\Data\ImmutableRecordLogic;
use MyService\Domain\Model\Building\BuildingId;

final class GetBuilding implements ImmutableRecord
{
    use ImmutableRecordLogic;

    /**
     * @var BuildingId
     */
    private $buildingId;

    /**
     * @return BuildingId
     */
    public function buildingId(): BuildingId
    {
        return $this-&gt;buildingId;
    }
}

</code></pre>
<p><code>src/Domain/Resolver/Query/GetBuildings.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Resolver\Query;

use EventEngine\Data\ImmutableRecord;
use EventEngine\Data\ImmutableRecordLogic;

final class GetBuildings implements ImmutableRecord
{
    use ImmutableRecordLogic;

    /**
     * @var string|null
     */
    private $buildingNameFilter;

    /**
     * @return string|null
     */
    public function buildingNameFilter(): ?string
    {
        return $this-&gt;buildingNameFilter;
    }
}

</code></pre>
<p><code>src/Domain/Resolver/Query/GetUserBuildingList.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Resolver\Query;

use EventEngine\Data\ImmutableRecord;
use EventEngine\Data\ImmutableRecordLogic;
use MyService\Domain\Model\Building\Username;

final class GetUserBuildingList implements ImmutableRecord
{
    use ImmutableRecordLogic;

    /**
     * @var Username
     */
    private $name;

    /**
     * @return Username
     */
    public function name(): Username
    {
        return $this-&gt;name;
    }
}

</code></pre>
<p><code>src/Domain/Api/Query.php</code></p>
<pre><code class="language-php">&lt;?php

declare(strict_types=1);

namespace MyService\Domain\Api;

use EventEngine\EventEngine;
use EventEngine\EventEngineDescription;
use EventEngine\JsonSchema\JsonSchema;
use EventEngine\Messaging\MessageBag;
use MyService\Domain\Resolver\BuildingResolver;
use MyService\Domain\Resolver\Query\GetBuilding;
use MyService\Domain\Resolver\Query\GetBuildings;
use MyService\Domain\Resolver\Query\GetUserBuildingList;
use MyService\Domain\Resolver\UserBuildingResolver;
use MyService\System\Api\SystemType;

class Query implements EventEngineDescription
{
    /**
     * Default Query, used to perform health checks using messagebox endpoint
     */
    const HEALTH_CHECK = 'HealthCheck';
    const BUILDING = 'Building';
    const BUILDINGS = 'Buildings';
    const USER_BUILDING = 'UserBuilding';

    const CLASS_MAP = [
        self::BUILDING =&gt; GetBuilding::class,
        self::BUILDINGS =&gt; GetBuildings::class,
        self::USER_BUILDING =&gt; GetUserBuildingList::class,
    ];

    public static function createFromNameAndPayload(string $queryName, array $payload)
    {
        if($queryName === self::HEALTH_CHECK) {
            return new MessageBag(
                self::HEALTH_CHECK,
                MessageBag::TYPE_QUERY,
                []
            );
        }

        $class = self::CLASS_MAP[$queryName] ?? false;

        if($class === false) {
            throw new \InvalidArgumentException("Unknown query name: $queryName");
        }

        //Commands use ImmutableRecordLogic and therefor have a fromArray method
        return $class::fromArray($payload);
    }

    public static function nameOf($query): string
    {
        if($query instanceof MessageBag) {
            return $query-&gt;messageName();
        }

        $name = array_search(\get_class($query), self::CLASS_MAP);

        if($name === false) {
            throw new \InvalidArgumentException("Unknown query. Cannot find a name for class: " . \get_class($query));
        }

        return $name;
    }

    /* ... */
}

</code></pre>
<p><code>src/System/Flavour/MyServiceMessagePort.php</code></p>
<pre><code class="language-php">/**
 * @param Message $message
 * @return mixed The custom message
 */
public function deserialize(Message $message)
{
    switch ($message-&gt;messageType()) {
        case Message::TYPE_COMMAND:
            return Command::createFromNameAndPayload($message-&gt;messageName(), $message-&gt;payload());
        case Message::TYPE_EVENT:
            return Event::createFromNameAndPayload($message-&gt;messageName(), $message-&gt;payload());
        case Message::TYPE_QUERY:
            return Query::createFromNameAndPayload($message-&gt;messageName(), $message-&gt;payload());
    }
}

</code></pre>
<h2 id="2-11-4">Serialize Payload</h2>
<p>To convert our own message types to Event Engine messages we have to implement the <code>serializePayload</code> method:</p>
<p><code>src/System/Flavour/MyServiceMessagePort.php</code></p>
<pre><code class="language-php">/**
 * @param mixed $customMessage
 * @return array
 */
public function serializePayload($customMessage): array
{
    if(is_array($customMessage)) {
        return $customMessage;
    }

    if(!$customMessage instanceof ImmutableRecord) {
        throw new \RuntimeException(
            "Invalid message passed to " . __METHOD__
            . ". Should be an immutable record, but got "
            . (\is_object($customMessage)? \get_class($customMessage) : \gettype($customMessage)));
    }

    return $customMessage-&gt;toArray();
}

</code></pre>
<h2 id="2-11-5">Decorate Command / Event</h2>
<p><code>decorateCommand</code> and <code>decorateEvent</code> are special methods called for each dispatched command and all yielded events.
The expected return type is <code>EventEngine\Messaging\MessageBag</code>. You can think of it as an envelop
for custom messages. The MessageBag can be used to add metadata information. Event Engine
adds information like aggregate id, aggregate type, aggregate version, causation id (command id) and causation name (command name)
by default. If you want to add additional metadata, just pass it to the MessageBag constructor (optional argument).</p>
<p class="alert alert-light">Decorating a custom event with a MessageBas has the advantage that a custom message can be carried through the Event Engine layer
without serialization. Event Engine assumes a normal message and adds aggregate specific metadata like described above.
The MessageBag is then passed back to the configured flavour to call a corresponding apply function. The flavour can access
the decorated event and pass it to the function. All without serialization in between. A similar approach is used when commands
are passed to preprocessors or controllers (concepts not included in the tutorial, but you can read about them in the docs).</p>
<p><code>src/System/Flavour/MyServiceMessagePort.php</code></p>
<pre><code class="language-php">/**
 * @param mixed $customCommand
 * @return MessageBag
 */
public function decorateCommand($customCommand): MessageBag
{
    return new MessageBag(
        Command::nameOf($customCommand),
        MessageBag::TYPE_COMMAND,
        $customCommand
    //, [] &lt;- you could add additional metadata here
    );
}
    
/**
 * @param mixed $customEvent
 * @return MessageBag
 */
public function decorateEvent($customEvent): MessageBag
{
    return new MessageBag(
        Event::nameOf($customEvent),
        MessageBag::TYPE_EVENT,
        $customEvent
        //, [] &lt;- you could add additional metadata here
    );
}
</code></pre>
<h3 id="2-11-5-1">Get Aggregate ID from Command</h3>
<p>Event Engine has a built-in way to locate existing aggregates using a generic command handler and repository. But it needs the correct aggregateId.
Each command should contain the same aggregateId property. Remember that this information is part of an Event Engine description:</p>
<p><code>src/Api/Aggregate</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Api;

use MyService\Domain\Model\Building;
use EventEngine\EventEngine;
use EventEngine\EventEngineDescription;

class Aggregate implements EventEngineDescription
{
    const BUILDING = 'Building';

    /**
     * @param EventEngine $eventEngine
     */
    public static function describe(EventEngine $eventEngine): void
    {
        $eventEngine-&gt;process(Command::ADD_BUILDING)
            -&gt;withNew(self::BUILDING)
            -&gt;identifiedBy(Payload::BUILDING_ID) //&lt;-- AggregateId payload property
            -&gt;handle([Building::class, 'add'])
            -&gt;recordThat(Event::BUILDING_ADDED)
            -&gt;apply([Building::class, 'whenBuildingAdded']);

        /* ... */
    }
}

</code></pre>
<p>Each <code>Building</code> command should have a <code>builidngId</code> property. Our newly created commands have <code>buildingId()</code> methods that we could call.
An explicit implementation looks like this:</p>
<pre><code class="language-php">/**
 * @param string $aggregateIdPayloadKey
 * @param mixed $command
 * @return string
 */
public function getAggregateIdFromCommand(string $aggregateIdPayloadKey, $command): string
{
    if($command instanceof AddBuilding
        || $command instanceof CheckInUser
        || $command instanceof CheckOutUser) {
        return $command-&gt;buildingId()-&gt;toString();
    }

    throw new \RuntimeException("Unknown command. Cannot get aggregate id from it. Got " . get_class($command));
}
</code></pre>
<p>But we would need to remember adding a new command here each time we add a new one to the system. That's annoying and interrupts the flow.
Instead we can define an <code>AggregateCommand</code> interface that each command should implement.</p>
<p><code>src/Domain/Model/Base/AggregateCommand.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Model\Base;

interface AggregateCommand
{
    public function aggregateId(): string;
}

</code></pre>
<p><code>src/Domain/Model/Building/Command/AddBuilding.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Model\Building\Command;

use MyService\Domain\Model\Base\AggregateCommand;
use MyService\Domain\Model\Building\BuildingId;
use MyService\Domain\Model\Building\BuildingName;
use EventEngine\Data\ImmutableRecord;
use EventEngine\Data\ImmutableRecordLogic;

final class AddBuilding implements ImmutableRecord, AggregateCommand //&lt;-- Implement new interface
{
    use ImmutableRecordLogic;

    /**
     * @var BuildingId
     */
    private $buildingId;

    /**
     * @var BuildingName
     */
    private $name;

    /**
     * @return BuildingId
     */
    public function buildingId(): BuildingId
    {
        return $this-&gt;buildingId;
    }

    /**
     * @return BuildingName
     */
    public function name(): BuildingName
    {
        return $this-&gt;name;
    }

    public function aggregateId(): string //&lt;-- new method
    {
        return $this-&gt;buildingId-&gt;toString();
    }
}

</code></pre>
<p>Do the same for <code>CheckInUser</code> and <code>CheckOutUser</code>!</p>
<p>Done? Great! Then we can change the Port to handle any <code>AggregateCommand</code>:</p>
<p><code>src/System/Flavour/MyServiceMessagePort.php</code></p>
<pre><code class="language-php">/**
 * @param string $aggregateIdPayloadKey
 * @param mixed $command
 * @return string
 */
public function getAggregateIdFromCommand(string $aggregateIdPayloadKey, $command): string
{
    if($command instanceof AggregateCommand) {
        return $command-&gt;aggregateId();
    }

    throw new \RuntimeException("Unknown command. Cannot get aggregate id from it. Got " . get_class($command));
}

</code></pre>
<h2 id="2-11-6">Call Command Preprocessor</h2>
<p>We don't know command preprocessors yet. In short: a command preprocessor can be called before a command
is passed to an aggregate function. This can be useful in cases where you want to enrich a command with additional information or
perform advanced validation that is not covered by Json Schema. Read more about command preprocessors in the docs.</p>
<p>Since we don't use one in the building application, we don't really need to implement the method. Let's assume that
our future command preprocessors will be simple callables:</p>
<p><code>src/System/Flavour/MyServiceMessagePort.php</code></p>
<pre><code class="language-php">/**
 * @param mixed $customCommand
 * @param mixed $preProcessor Custom preprocessor
 * @return mixed Custom message
 */
public function callCommandPreProcessor($customCommand, $preProcessor)
{
    if(is_callable($preProcessor)) {
        return $preProcessor($customCommand);
    }

    throw new \RuntimeException("Cannot call preprocessor. Got "
        . (is_object($preProcessor)? get_class($preProcessor) : gettype($preProcessor))
    );
}

</code></pre>
<h2 id="2-11-7">Call Command Controller</h2>
<p>Instead of an aggregate a command can also be routed to a controller and the controller can decide if it forwards the command to an application service or return a list of other commands
that are dispatched automatically. This is very useful for migrations or in scenarios where you want to use CQRS without event sourcing and without aggregates. In our demo application we don't
use command controllers. Just like preprocessors we define them as callable.</p>
<pre><code class="language-php">public function callCommandController($customCommand, $controller)
{
    if(is_callable($controller)) {
        return $controller($customCommand);
    }

    throw new \RuntimeException("Cannot call command controller. Got "
        . (is_object($controller)? get_class($controller) : gettype($controller))
    );
}
</code></pre>
<h2 id="2-11-8">Call Context Provider</h2>
<p>Another concept that we don't know yet. A context provider can be used to inject context into aggregate functions.
Read more about context providers in the docs (@TODO link docs).</p>
<p>We're implementing a functional Flavour, so we expect a callable context provider passed to the port:</p>
<p><code>src/System/Flavour/MyServiceMessagePort.php</code></p>
<pre><code class="language-php">/**
 * @param mixed $customCommand
 * @param mixed $contextProvider
 * @return mixed
 */
public function callContextProvider($customCommand, $contextProvider)
{
    if(is_callable($contextProvider)) {
        return $contextProvider($customCommand);
    }

    throw new \RuntimeException("Cannot call context provider. Got "
        . (is_object($contextProvider)? get_class($contextProvider) : gettype($contextProvider))
    );
}

</code></pre>
<h2 id="2-11-9">Call Resolver</h2>
<p>Last port method asks us to call a resolver. When using the <code>PrototypingFlavour</code> query resolvers should implement
<code>EventEngine\Querying\Resolver</code>. But this is no longer possible because we want to pass our own queries to
the resolvers and not Event Engine's generic message class. Hence, we need to define a project specific resolver interface instead
along with a query marker interface:</p>
<p><code>src/Domain/Resolver/Query.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Resolver;

interface Query
{
    //Query marker interface
}

</code></pre>
<p><code>src/Domain/Resolver/Resolver.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Resolver;

interface Resolver
{
    /**
     * @param Query $query
     * @return mixed array or object with toArray or JsonSerializable support
     */
    public function resolve(Query $query);
}

</code></pre>
<p>Existing queries should implement the marker interface and resolvers should implement the new resolver interface:</p>
<p><code>src/Domain/Resolver/Query/GetBuilding.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Resolver\Query;

use EventEngine\Data\ImmutableRecord;
use EventEngine\Data\ImmutableRecordLogic;
use MyService\Domain\Model\Building\BuildingId;
use MyService\Domain\Resolver\Query;

final class GetBuilding implements ImmutableRecord, Query
{
    use ImmutableRecordLogic;

    /**
     * @var BuildingId
     */
    private $buildingId;

    /**
     * @return BuildingId
     */
    public function buildingId(): BuildingId
    {
        return $this-&gt;buildingId;
    }
}

</code></pre>
<p class="alert alert-light">Add the interface to <code>GetBuildings</code> and <code>GetUserBuildingList</code> as well.</p>
<p><code>src/Domain/Resolver/BuildingResolver.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Resolver;

use EventEngine\DocumentStore\DocumentStore;
use EventEngine\DocumentStore\Filter\AnyFilter;
use EventEngine\DocumentStore\Filter\LikeFilter;
use MyService\Domain\Api\Payload;
use MyService\Domain\Model\Building\BuildingId;
use MyService\Domain\Resolver\Query\GetBuilding;
use MyService\Domain\Resolver\Query\GetBuildings;

final class BuildingResolver implements Resolver
{
    public const COLLECTION = 'buildings';
    public const STATE = 'state';
    public const STATE_DOT = 'state.';

    /**
     * @var DocumentStore
     */
    private $documentStore;

    public function __construct(DocumentStore $documentStore)
    {
        $this-&gt;documentStore = $documentStore;
    }

    /**
     * @param Query $query
     * @return array
     */
    public function resolve(Query $query): array
    {
        switch (true) {
            case $query instanceof GetBuilding:
                return $this-&gt;resolveBuilding($query-&gt;buildingId());
            case $query instanceof GetBuildings:
                return $this-&gt;resolveBuildings($query-&gt;name());
            default:
                throw new \RuntimeException("Query not supported. Got " . VariableType::determine($query));
        }
    }

    private function resolveBuilding(BuildingId $buildingId): array
    {
        $buildingDoc = $this-&gt;documentStore-&gt;getDoc(self::COLLECTION, $buildingId-&gt;toString());

        if(!$buildingDoc) {
            throw new \RuntimeException("Building not found", 404);
        }

        return $buildingDoc[self::STATE];
    }

    private function resolveBuildings(string $nameFilter = null): array
    {
        $filter = $nameFilter?
            new LikeFilter(self::STATE_DOT . Payload::NAME, "%$nameFilter%")
            : new AnyFilter();

        $cursor = $this-&gt;documentStore-&gt;filterDocs(self::COLLECTION, $filter);

        $buildings = [];

        foreach ($cursor as $doc) {
            $buildings[] = $doc[self::STATE];
        }

        return $buildings;
    }
}

</code></pre>
<p><code>src/Domain/Resolver/UserBuildingResolver.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Resolver;

use EventEngine\DocumentStore\DocumentStore;
use EventEngine\Util\VariableType;
use MyService\Domain\Resolver\Query\GetUserBuildingList;

final class UserBuildingResolver implements Resolver
{
    /**
     * @var DocumentStore
     */
    private $documentStore;

    /**
     * @var string
     */
    private $userBuildingCollection;

    /**
     * @var string
     */
    private $buildingCollection;

    public function __construct(DocumentStore $documentStore, string $userBuildingCol, string $buildingCol)
    {
        $this-&gt;documentStore = $documentStore;
        $this-&gt;userBuildingCollection = $userBuildingCol;
        $this-&gt;buildingCollection = $buildingCol;
    }

    public function resolve(Query $query): array
    {
        if(!$query instanceof GetUserBuildingList) {
            throw new \RuntimeException("Invalid query. Can only handle " . GetUserBuildingList::class 
                . '. But got ' . VariableType::determine($query));
        }
        
        $userBuilding = $this-&gt;documentStore-&gt;getDoc(
            $this-&gt;userBuildingCollection,
            $query-&gt;name()-&gt;toString()
        );

        if(!$userBuilding) {
            return [
                'user' =&gt; $query-&gt;name()-&gt;toString(),
                'building' =&gt; null
            ];
        }

        $building = $this-&gt;documentStore-&gt;getDoc(
            $this-&gt;buildingCollection,
            $userBuilding['buildingId']
        );

        if(!$building) {
            return [
                'user' =&gt; $query-&gt;name()-&gt;toString(),
                'building' =&gt; null
            ];
        }

        return [
            'user' =&gt; $query-&gt;name()-&gt;toString(),
            'building' =&gt; $building['state'],
        ];
    }
}

</code></pre>
<p><code>src/System/Flavour/MyServiceMessagePort.php</code></p>
<pre><code class="language-php">public function callResolver($customQuery, $resolver)
{
    if(! $resolver instanceof Resolver) {
        throw new \RuntimeException("Unsupported resolver. Got " . VariableType::determine($resolver));
    }

    return $resolver-&gt;resolve($customQuery);
}
</code></pre>
<p class="alert alert-success">All methods of the <code>Functional\Port</code> are implemented. Good job! But we're not done yet.</p>
<h2 id="2-11-10">Switching The Flavour</h2>
<p>The flavour is configured in <code>src/System/SystemServices.php</code> and can be changed there:</p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\System;

use EventEngine\Data\ImmutableRecordDataConverter;
use EventEngine\Logger\LogEngine;
use EventEngine\Logger\SimpleMessageEngine;
use EventEngine\Messaging\Message;
use EventEngine\Prooph\V7\EventStore\GenericProophEvent;
use EventEngine\Runtime\Flavour;
use EventEngine\Runtime\FunctionalFlavour;
use Monolog\Handler\StreamHandler;
use Monolog\Logger;
use MyService\System\Api\EventEngineConfig;
use MyService\System\Api\SystemQuery;
use MyService\System\Api\SystemType;
use MyService\System\Flavour\MyServiceMessagePort;
use Prooph\Common\Messaging\NoOpMessageConverter;
use Prooph\ServiceBus\Message\HumusAmqp\AmqpMessageProducer;
use Psr\Log\LoggerInterface;

trait SystemServices
{
    public function systemDescriptions(): array
    {
        return [
            SystemType::class,
            SystemQuery::class,
            EventEngineConfig::class,
        ];
    }

    public function flavour(): Flavour
    {
        return $this-&gt;makeSingleton(Flavour::class, function () {
            return new FunctionalFlavour(new MyServiceMessagePort(), new ImmutableRecordDataConverter());
        });
    }

    public function healthCheckResolver(): HealthCheckResolver
    {
        return $this-&gt;makeSingleton(HealthCheckResolver::class, function () {
            return new HealthCheckResolver();
        });
    }

    public function logger(): LoggerInterface
    {
        return $this-&gt;makeSingleton(LoggerInterface::class, function () {
            $streamHandler = new StreamHandler('php://stderr');

            return new Logger('EventEngine', [$streamHandler]);
        });
    }

    public function logEngine(): LogEngine
    {
        return new SimpleMessageEngine($this-&gt;logger());
    }

    public function uiExchange(): UiExchange
    {
        return $this-&gt;makeSingleton(UiExchange::class, function () {
            $this-&gt;assertMandatoryConfigExists('rabbit.connection');

            $connection = new \Humus\Amqp\Driver\AmqpExtension\Connection(
                $this-&gt;config()-&gt;arrayValue('rabbit.connection')
            );

            $connection-&gt;connect();

            $channel = $connection-&gt;newChannel();

            $exchange = $channel-&gt;newExchange();

            $exchange-&gt;setName($this-&gt;config()-&gt;stringValue('rabbit.ui_exchange', 'ui-exchange'));

            $exchange-&gt;setType('fanout');

            $humusProducer = new \Humus\Amqp\JsonProducer($exchange);

            $messageProducer = new \Prooph\ServiceBus\Message\HumusAmqp\AmqpMessageProducer(
                $humusProducer,
                new NoOpMessageConverter()
            );

            return new class($messageProducer) implements UiExchange {
                private $producer;
                public function __construct(AmqpMessageProducer $messageProducer)
                {
                    $this-&gt;producer = $messageProducer;
                }

                public function __invoke(Message $event): void
                {
                    $this-&gt;producer-&gt;__invoke(GenericProophEvent::fromArray([
                        'uuid' =&gt; $event-&gt;uuid()-&gt;toString(),
                        'message_name' =&gt; $event-&gt;messageName(),
                        'payload' =&gt; $event-&gt;payload(),
                        'metadata' =&gt; $event-&gt;metadata(),
                        'created_at' =&gt; $event-&gt;createdAt()
                    ]));
                }
            };
        });
    }
}

</code></pre>
<p class="alert alert-success">Everything set up 🎉. Refactoring can start!</p>
<h2 id="2-11-11">Refactoring</h2>
<p>Switching the Flavour means all generic messages have to be replaced with their concrete implementations.</p>
<p class="alert alert-info">In a larger project we might want to switch to another Flavour step by step. In that case a "Proxy Flavour" is required that
uses <strong>PrototypingFlavour</strong> and <strong>FunctionalFlavour</strong> (or OopFlavour) internally together with a mapping of already migrated parts of
the application.</p>
<p><code>src/Domain/Model/Building.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Model;

use MyService\Domain\Model\Building\Command\AddBuilding;
use MyService\Domain\Model\Building\Command\CheckInUser;
use MyService\Domain\Model\Building\Command\CheckOutUser;
use MyService\Domain\Model\Building\Event\BuildingAdded;
use MyService\Domain\Model\Building\Event\DoubleCheckInDetected;
use MyService\Domain\Model\Building\Event\DoubleCheckOutDetected;
use MyService\Domain\Model\Building\Event\UserCheckedIn;
use MyService\Domain\Model\Building\Event\UserCheckedOut;

final class Building
{
    public static function add(AddBuilding $addBuilding): \Generator
    {
        yield BuildingAdded::fromArray($addBuilding-&gt;toArray());
    }

    public static function whenBuildingAdded(BuildingAdded $buildingAdded): Building\State
    {
        return Building\State::fromArray($buildingAdded-&gt;toArray());
    }

    public static function checkInUser(Building\State $state, CheckInUser $checkInUser): \Generator
    {
        if($state-&gt;isUserCheckedIn($checkInUser-&gt;name())) {
            yield DoubleCheckInDetected::fromArray($checkInUser-&gt;toArray());
            return;
        }

        yield UserCheckedIn::fromArray($checkInUser-&gt;toArray());
    }

    public static function whenUserCheckedIn(Building\State $state, UserCheckedIn $userCheckedIn): Building\State
    {
        return $state-&gt;withCheckedInUser($userCheckedIn-&gt;name());
    }

    public static function whenDoubleCheckInDetected(Building\State $state, DoubleCheckInDetected $event): Building\State
    {
        //No state change required, simply return current state
        return $state;
    }

    public static function checkOutUser(Building\State $state, CheckOutUser $checkOutUser): \Generator
    {
        if(!$state-&gt;isUserCheckedIn($checkOutUser-&gt;name())) {
            yield DoubleCheckOutDetected::fromArray($checkOutUser-&gt;toArray());
            return;
        }

        yield UserCheckedOut::fromArray($checkOutUser-&gt;toArray());
    }

    public static function whenUserCheckedOut(Building\State $state, UserCheckedOut $userCheckedOut): Building\State
    {
        return $state-&gt;withCheckedOutUser($userCheckedOut-&gt;name());
    }

    public static function whenDoubleCheckOutDetected(Building\State $state, DoubleCheckOutDetected $event): Building\State
    {
        return $state;
    }
}

</code></pre>
<p><code>Building\State</code> should make use of the new data types as well:</p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Model\Building;

use EventEngine\Data\ImmutableRecord;
use EventEngine\Data\ImmutableRecordLogic;

final class State implements ImmutableRecord
{
    use ImmutableRecordLogic;
    
    public const BUILDING_ID = 'buildingId';
    public const NAME = 'name';

    /**
     * @var BuildingId
     */
    private $buildingId;

    /**
     * @var BuildingName
     */
    private $name;

    /**
     * @var Username[]
     */
    private $users = [];

    private static function arrayPropItemTypeMap(): array
    {
        return ['users' =&gt; Username::class];
    }

    /**
     * Called in constructor after setting props but before not null assertion
     *
     * Override to set default props after construction
     */
    private function init(): void
    {
        //Build internal users map
        $users = [];
        foreach ($this-&gt;users as $username) {
            $users[$username-&gt;toString()] = null;
        }
        $this-&gt;users = $users;
    }

    /**
     * @return BuildingId
     */
    public function buildingId(): BuildingId
    {
        return $this-&gt;buildingId;
    }

    /**
     * @return BuildingName
     */
    public function name(): BuildingName
    {
        return $this-&gt;name;
    }

    /**
     * @return Username[]
     */
    public function users(): array
    {
        return array_map(function (string $username) {
            return Username::fromString($username);
        }, array_keys($this-&gt;users));
    }

    public function withCheckedInUser(Username $username): State
    {
        $copy = clone $this;
        $copy-&gt;users[$username-&gt;toString()] = null;
        return $copy;
    }

    public function withCheckedOutUser(Username $username): State
    {
        if(!$this-&gt;isUserCheckedIn($username)) {
            return $this;
        }

        $copy = clone $this;
        unset($copy-&gt;users[$username-&gt;toString()]);
        return $copy;
    }

    public function isUserCheckedIn(Username $username): bool
    {
        return array_key_exists($username-&gt;toString(), $this-&gt;users);
    }
}

</code></pre>
<p><code>UserBuildingList</code> projector now needs to implement the interface <code>EventEngine\Projecting\CustomEventProjector</code>
instead of <code>EventEngine\Projecting\Projector</code>:</p>
<p><code>src/Domain/Projector/UserBuildingList.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\Domain\Projector;

use EventEngine\DocumentStore\DocumentStore;
use EventEngine\Projecting\CustomEventProjector;
use MyService\Domain\Api\Payload;
use EventEngine\Projecting\AggregateProjector;
use MyService\Domain\Model\Building\Event\UserCheckedIn;
use MyService\Domain\Model\Building\Event\UserCheckedOut;

final class UserBuildingList implements CustomEventProjector
{
    /**
     * @var DocumentStore
     */
    private $documentStore;

    public function __construct(DocumentStore $documentStore)
    {
        $this-&gt;documentStore = $documentStore;
    }

    public function prepareForRun(string $projectionVersion, string $projectionName): void
    {
        if(!$this-&gt;documentStore-&gt;hasCollection(self::generateCollectionName($projectionVersion, $projectionName))) {
            $this-&gt;documentStore-&gt;addCollection(
                self::generateCollectionName($projectionVersion, $projectionName)
            /* Note: we could pass index configuration as a second argument, see docs for details */
            );
        }
    }

    public function handle(string $appVersion, string $projectionName, $event): void
    {
        $collection = $this-&gt;generateCollectionName($appVersion, $projectionName);

        switch (true) {
            case $event instanceof UserCheckedIn:
                $this-&gt;documentStore-&gt;addDoc(
                    $collection,
                    $event-&gt;name()-&gt;toString(), //Use username as doc id
                    [Payload::BUILDING_ID =&gt; $event-&gt;buildingId()-&gt;toString()]
                );
                break;
            case $event instanceof UserCheckedOut:
                $this-&gt;documentStore-&gt;deleteDoc($collection, $event-&gt;name()-&gt;toString());
                break;
            default:
                //Ignore unknown events
        }
    }
    
    public function deleteReadModel(string $appVersion, string $projectionName): void
    {
        $this-&gt;documentStore-&gt;dropCollection(self::generateCollectionName($appVersion, $projectionName));
    }

    public static function generateCollectionName(string $projectionVersion, string $projectionName): string
    {
        //We can use the naming strategy of the aggregate projector for our custom projection
        return AggregateProjector::generateCollectionName($projectionVersion, $projectionName);
    }
}

</code></pre>
<p>The <code>UiExchange</code> event listener included in the skeleton application needs to b aligned, too.
First, the corresponding interface should handle any type of event:</p>
<p><code>src/System/UiExchange.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\System;

interface UiExchange
{
    public function __invoke($event): void;
}

</code></pre>
<p>Second, an implementation of the interface should handle our event objects. The skeleton simply uses an anonymous class
to implement the interface. It can be found and changed in <code>src/System/SystemServices.php</code>.</p>
<p class="alert alert-warning">It's an anonymous class because the UiExchange is only included in the skeleton to demonstrate how events can be pushed
to a message queue and consumed by a UI. The implementation is not meant to be used in production. You can get some inspiration
from it, but please work out a production grade solution yourself.</p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyService\System;

use EventEngine\Data\ImmutableRecordDataConverter;
use EventEngine\Logger\LogEngine;
use EventEngine\Logger\SimpleMessageEngine;
use EventEngine\Messaging\MessageBag;
use EventEngine\Prooph\V7\EventStore\GenericProophEvent;
use EventEngine\Runtime\Flavour;
use EventEngine\Runtime\FunctionalFlavour;
use Monolog\Handler\StreamHandler;
use Monolog\Logger;
use MyService\Domain\Api\Event;
use MyService\System\Api\EventEngineConfig;
use MyService\System\Api\SystemQuery;
use MyService\System\Api\SystemType;
use MyService\System\Flavour\MyServiceMessagePort;
use Prooph\Common\Messaging\NoOpMessageConverter;
use Prooph\ServiceBus\Message\HumusAmqp\AmqpMessageProducer;
use Psr\Log\LoggerInterface;

trait SystemServices
{
    /* ... */

    public function uiExchange(): UiExchange
    {
        return $this-&gt;makeSingleton(UiExchange::class, function () {
            $this-&gt;assertMandatoryConfigExists('rabbit.connection');

            $connection = new \Humus\Amqp\Driver\AmqpExtension\Connection(
                $this-&gt;config()-&gt;arrayValue('rabbit.connection')
            );

            $connection-&gt;connect();

            $channel = $connection-&gt;newChannel();

            $exchange = $channel-&gt;newExchange();

            $exchange-&gt;setName($this-&gt;config()-&gt;stringValue('rabbit.ui_exchange', 'ui-exchange'));

            $exchange-&gt;setType('fanout');

            $humusProducer = new \Humus\Amqp\JsonProducer($exchange);

            $messageProducer = new \Prooph\ServiceBus\Message\HumusAmqp\AmqpMessageProducer(
                $humusProducer,
                new NoOpMessageConverter()
            );

            $flavour = $this-&gt;flavour();

            return new class($messageProducer, $flavour) implements UiExchange {
                private $producer;
                private $flavour;
                public function __construct(AmqpMessageProducer $messageProducer, Flavour $flavour)
                {
                    $this-&gt;producer = $messageProducer;
                    $this-&gt;flavour = $flavour;
                }

                public function __invoke($event): void
                {
                    $messageBag = new MessageBag(
                        Event::nameOf($event),
                        MessageBag::TYPE_EVENT,
                        $event
                    );

                    $event = $this-&gt;flavour-&gt;prepareNetworkTransmission($messageBag);

                    $this-&gt;producer-&gt;__invoke(GenericProophEvent::fromArray([
                        'uuid' =&gt; $event-&gt;uuid()-&gt;toString(),
                        'message_name' =&gt; $event-&gt;messageName(),
                        'payload' =&gt; $event-&gt;payload(),
                        'metadata' =&gt; $event-&gt;metadata(),
                        'created_at' =&gt; $event-&gt;createdAt()
                    ]));
                }
            };
        });
    }
}

</code></pre>
<p>That's it! You can use the <a href="http://localhost:8080/swagger/index.html#/">Swagger UI</a> to test changes.</p>
<p>Or wait! We did not run the tests!</p>
<pre><code class="language-bash">docker-compose run php php vendor/bin/phpunit
</code></pre>
<p>Doesn't look good, right? Let's fix them!</p>
<p><code>TestCaseAbstract::assertRecordedEvent()</code> method need to be aligned:</p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyServiceTest;

use EventEngine\DocumentStore\DocumentStore;
use EventEngine\EventEngine;
use EventEngine\EventStore\EventStore;
use EventEngine\Logger\DevNull;
use EventEngine\Logger\SimpleMessageEngine;
use EventEngine\Messaging\Message;
use EventEngine\Messaging\MessageProducer;
use EventEngine\Persistence\InMemoryConnection;
use EventEngine\Prooph\V7\EventStore\InMemoryMultiModelStore;
use EventEngine\Util\MessageTuple;
use MyService\Domain\Api\Event;
use MyService\ServiceFactory;
use MyServiceTest\Mock\EventQueueMock;
use MyServiceTest\Mock\MockContainer;
use PHPUnit\Framework\TestCase;

class TestCaseAbstract extends TestCase
{
    /* ... */

    protected function assertRecordedEvent(string $eventName, array $payload, array $events, $assertNotRecorded = false): void
    {
        $isRecorded = false;

        foreach ($events as $evt) {
            if($evt === null) {
                continue;
            }

            //Convert domain events to raw data
            $evtName = Event::nameOf($evt);
            $evtPayload = $evt-&gt;toArray();

            if($eventName === $evtName) {
                $isRecorded = true;

                if(!$assertNotRecorded) {
                    $this-&gt;assertEquals($payload, $evtPayload, "Payload of recorded event $evtName does not match with expected payload.");
                }
            }
        }

        if($assertNotRecorded) {
            $this-&gt;assertFalse($isRecorded, "Event $eventName is recorded");
        } else {
            $this-&gt;assertTrue($isRecorded, "Event $eventName is not recorded");
        }
    }
}

</code></pre>
<p><code>NotifySecurityTest</code> contains a mocked <code>UiExchange</code>. We changed the interface earlier, but did not change the mock.
The test itself needs minor adjustments, too.</p>
<p><code>tests/Integration/NotifySecurityTest.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyServiceTest\Integration;

use MyService\Domain\Api\Command;
use MyService\Domain\Api\Event;
use MyService\Domain\Api\Payload;
use MyService\Domain\Model\Building\Event\DoubleCheckInDetected;
use MyService\System\UiExchange;
use MyServiceTest\IntegrationTestCase;

final class NotifySecurityTest extends IntegrationTestCase
{
    const BUILDING_ID = '7c5f0c8a-54f2-4969-9596-b5bddc1e9421';
    const BUILDING_NAME = 'Acme Headquarters';
    const USERNAME = 'John';

    private $uiExchange;

    protected function setUp()
    {
        parent::setUp();

        //Mock UiExchange with an anonymous class that keeps track of the last received message
        $this-&gt;uiExchange = new class implements UiExchange {

            private $lastReceivedMessage;

            public function __invoke($event): void
            {
                $this-&gt;lastReceivedMessage = $event;
            }

            public function lastReceivedMessage()
            {
                return $this-&gt;lastReceivedMessage;
            }
        };

        // Mocks are passed to EE set up method
        // The IntegrationTestCase loads all EE descriptions
        // and uses the configured Flavour (PrototypingFlavour in our case)
        // to set up Event Engine
        $this-&gt;setUpEventEngine([
            UiExchange::class =&gt; $this-&gt;uiExchange,
        ]);

        /**
         * We can pass fixtures to the database set up:
         *
         * Stream to events map:
         *
         * [streamName =&gt; Event[]]
         *
         * Collection to documents map:
         *
         * [collectionName =&gt; [docId =&gt; doc]]
         */
        $this-&gt;setUpDatabase([
            // We use the default write model stream in the buildings app
            // and add a history for the test building
            // aggregate state is derived from history automatically during set up
            $this-&gt;eventEngine-&gt;writeModelStreamName() =&gt; [
                $this-&gt;makeEvent(Event::BUILDING_ADDED, [
                    Payload::BUILDING_ID =&gt; self::BUILDING_ID,
                    Payload::NAME =&gt; self::BUILDING_NAME
                ]),
                $this-&gt;makeEvent(Event::USER_CHECKED_IN, [
                    Payload::BUILDING_ID =&gt; self::BUILDING_ID,
                    Payload::NAME =&gt; self::USERNAME
                ]),
            ]
        ]);
    }

    /**
     * @test
     */
    public function it_detects_double_check_in_and_notifies_security()
    {
        //Try to check in John twice
        $checkInJohn = $this-&gt;makeCommand(Command::CHECK_IN_USER, [
            Payload::BUILDING_ID =&gt; self::BUILDING_ID,
            Payload::NAME =&gt; self::USERNAME
        ]);

        $this-&gt;eventEngine-&gt;dispatch($checkInJohn);

        //The IntegrationTestCase sets up an in-memory queue (accessible by $this-&gt;eventQueue)
        //You can inspect published events or simply process the queue
        //so that event listeners get invoked like our mocked UiExchange listener
        $this-&gt;processEventQueueWhileNotEmpty();

        //Now $this-&gt;lastPublishedEvent should point to the event received by UiExchange mock
        $this-&gt;assertNotNull($this-&gt;uiExchange-&gt;lastReceivedMessage());

        $this-&gt;assertInstanceOf(DoubleCheckInDetected::class, $this-&gt;uiExchange-&gt;lastReceivedMessage());

        $this-&gt;assertEquals([
            Payload::BUILDING_ID =&gt; self::BUILDING_ID,
            Payload::NAME =&gt; self::USERNAME
        ], $this-&gt;uiExchange-&gt;lastReceivedMessage()-&gt;toArray());
    }
}

</code></pre>
<p>Next on the list is <code>BuildingTest</code>.
<code>tests/Domain/Model/BuildingTest.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyServiceTest\Domain\Model;

use MyService\Domain\Api\Command;
use MyService\Domain\Api\Event;
use MyService\Domain\Api\Payload;
use MyServiceTest\UnitTestCase;
use Ramsey\Uuid\Uuid;
use MyService\Domain\Model\Building;

final class BuildingTest extends UnitTestCase
{
    private $buildingId;
    private $buildingName;
    private $username;

    protected function setUp()
    {
        $this-&gt;buildingId = Uuid::uuid4()-&gt;toString();
        $this-&gt;buildingName = 'Acme Headquarters';
        $this-&gt;username = 'John';

        parent::setUp();
    }

    /**
     * @test
     */
    public function it_checks_in_a_user()
    {
        //Prepare expected aggregate state
        $state = Building\State::fromArray([
            Building\State::BUILDING_ID =&gt; $this-&gt;buildingId,
            Building\State::NAME =&gt; $this-&gt;buildingName
        ]);

        //Use test helper UnitTestCase::makeCommand() to construct command
        $command = Building\Command\CheckInUser::fromArray([
            Building\State::BUILDING_ID =&gt; $this-&gt;buildingId,
            Building\State::NAME =&gt; $this-&gt;username,
        ]);

        //Aggregate functions yield events, we have to collect them with a test helper
        $events = $this-&gt;collectNewEvents(
            Building::checkInUser($state, $command)
        );

        //Another test helper to assert that list of recorded events contains given event
        $this-&gt;assertRecordedEvent(Event::USER_CHECKED_IN, [
            Payload::BUILDING_ID =&gt; $this-&gt;buildingId,
            Payload::NAME =&gt; $this-&gt;username
        ], $events);
    }
}

</code></pre>
<p>And last adjustments in <code>UserBuildingListTest::it_manages_list_of_users_with_building_reference()</code>.
The projector expects dedicated event objects now.</p>
<p><code>tests/Domain/Projector/UserBuildingListTest.php</code></p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace MyServiceTest\Domain\Projector;

use EventEngine\DocumentStore\Filter\AnyFilter;
use MyService\Domain\Api\Event;
use MyService\Domain\Api\Payload;
use MyService\Domain\Api\Projection;
use MyService\Domain\Model\Building\Event\UserCheckedIn;
use MyService\Domain\Model\Building\Event\UserCheckedOut;
use MyService\Domain\Projector\UserBuildingList;
use MyServiceTest\UnitTestCase;

final class UserBuildingListTest extends UnitTestCase
{
    const PRJ_VERSION = '0.1.0';
    const BUILDING_ID = '7c5f0c8a-54f2-4969-9596-b5bddc1e9421';
    const USERNAME1 = 'John';
    const USERNAME2 = 'Jane';

    /**
     * @var UserBuildingList
     */
    private $projector;

    protected function setUp()
    {
        parent::setUp();

        //DocumentStore is set up in parent::setUp()
        $this-&gt;projector = new UserBuildingList($this-&gt;documentStore);
        $this-&gt;projector-&gt;prepareForRun(
            self::PRJ_VERSION,
            Projection::USER_BUILDING_LIST
        );
    }

    /**
     * @test
     */
    public function it_manages_list_of_users_with_building_reference()
    {
        $collection = UserBuildingList::generateCollectionName(
            self::PRJ_VERSION,
            Projection::USER_BUILDING_LIST
        );

        $johnCheckedIn = UserCheckedIn::fromArray([
            Payload::BUILDING_ID =&gt; self::BUILDING_ID,
            Payload::NAME =&gt; self::USERNAME1
        ]);

        $this-&gt;projector-&gt;handle(
            self::PRJ_VERSION,
            Projection::USER_BUILDING_LIST,
            $johnCheckedIn
        );

        $users = iterator_to_array($this-&gt;documentStore-&gt;filterDocs(
            $collection,
            new AnyFilter()
        ));

        $this-&gt;assertEquals($users, [
            'John' =&gt; ['buildingId' =&gt; self::BUILDING_ID]
        ]);

        $janeCheckedIn = UserCheckedIn::fromArray([
            Payload::BUILDING_ID =&gt; self::BUILDING_ID,
            Payload::NAME =&gt; self::USERNAME2
        ]);

        $this-&gt;projector-&gt;handle(
            self::PRJ_VERSION,
            Projection::USER_BUILDING_LIST,
            $janeCheckedIn
        );

        $users = iterator_to_array($this-&gt;documentStore-&gt;filterDocs(
            $collection,
            new AnyFilter()
        ));

        $this-&gt;assertEquals($users, [
            'John' =&gt; ['buildingId' =&gt; self::BUILDING_ID],
            'Jane' =&gt; ['buildingId' =&gt; self::BUILDING_ID],
        ]);

        $johnCheckedOut = UserCheckedOut::fromArray([
            Payload::BUILDING_ID =&gt; self::BUILDING_ID,
            Payload::NAME =&gt; self::USERNAME1
        ]);

        $this-&gt;projector-&gt;handle(
            self::PRJ_VERSION,
            Projection::USER_BUILDING_LIST,
            $johnCheckedOut
        );

        $users = iterator_to_array($this-&gt;documentStore-&gt;filterDocs(
            $collection,
            new AnyFilter()
        ));

        $this-&gt;assertEquals($users, [
            'Jane' =&gt; ['buildingId' =&gt; self::BUILDING_ID],
        ]);
    }
}

</code></pre>
<p class="alert alert-success"><strong>Tests are green again. Refactoring finished successfully. Was it worth the effort?</strong>
Switching the Flavour is quite some workt to do, isn't it? Depending on the amount of already written code and tests this task can take some days and you need to make sure
that you don't break existing functionality. On the other hand you get a fully decoupled domain model.
Of course, it's also possible to use another Flavour right from the beginning. But keep in mind, that the PrototypingFlavour saves a lot of time in the early days
of a project. You don't know if the first app version really meets business and user needs. You can only try and experiment. The faster you have a working
app, the faster you can get feedback from users and stakeholders. A lean implementation and simple infrastructure gives you a lot of flexibility at the beginning.
Starting with a MVP is not a new concept. Event Engine just gives you a nice tool to build one and
reuse parts of your experiments in later project phases. Also using CQRS / ES from day one gives you full advantage of a reactive system.</p>
<p>Still curious to see what the <strong>OopFlavour</strong> can do? The last bonus part sheds light on it.</p>
</div>        </div>
    </div>
</div>

<footer>
    <div class="links">
        <div class="container">
            <div class="row">
                <div class="prev col-xs-6">
                                            <a href="https://event-engine.io/tutorial/bonusII.html">Previous</a>                                    </div>
                <div class="next col-xs-6">
                                            <a href="https://event-engine.io/tutorial/bonusIV.html">Next</a>                                    </div>
            </div>
        </div>
    </div>
    <div id="copyright">
        <div class="container">
            <div class="row">
                <div class="col-md-12">
                    <p><a href="http://prooph-software.de/about.html">Imprint</a> | Powered by <a href="https://github.com/tobiju/bookdown-bootswatch-templates" title="Visit project to generate your own docs">Bookdown Bootswatch Templates</a>.</p>
                </div>
            </div>
        </div>
    </div>
</footer>
</div>
<span id="forkongithub"><a href="https://github.com/proophsoftware/event-machine-docs">Fork me on GitHub</a></span><script src="//code.jquery.com/jquery-2.2.0.min.js"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"
        integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS"
        crossorigin="anonymous"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/0.6.0/lunr.min.js"></script>
<script src="//bartaz.github.io/sandbox.js/jquery.highlight.js"></script>
<script src="//tobiju.github.io/share/prismjs/main.js"></script>
<script src="//tobiju.github.io/share/prismjs/prism.js"></script>
<script type="text/javascript">

    function Search() {
        this.store = {};
        this.index = lunr(function () {
            this.ref('id');
            this.field('title', {boost: 10});
            this.field('content');
        });
        this.searchResults = $('.js-search-results').addClass('list-search-results');
    }

    Search.prototype = {
        constructor: Search,
        init: function () {
            this.createIndex();
            this.bindEvents();
        },
        createIndex: function () {
            var $this = this,
                indexFilePath = $('.js-search-input').data('roothref') + 'index.json';

            $.getJSON(indexFilePath, function (data) {
                $.each(data, function (key, item) {
                    $this.index.add({
                        id: item.id,
                        title: item.title,
                        content: item.content
                    });

                    $this.store[item.id] = {
                        href: item.id,
                        title: item.title,
                        content: item.content
                    }
                });
            });
        },
        bindEvents: function () {
            var $this = this;

            $('html')
                .on('click', function (event) {
                    $this.close($(this), event);
                });

            $('.js-search-input, .js-search-results')
                .on('click', function (event) {
                    $this.click($(this), event);
                });

            $('.js-search-input')
                .on('focus', function (event) {
                    $this.focus($(this), event);
                })
                .on('keyup', function (event) {
                    $this.search($(this), event)
                })
                .on('keydown', function (event) {
                    if ($('.js-search-results ul').is(':visible')){
                        $this.navigation($(this), event)
                    }
                })
        },
        click: function (element, event) {
            event.stopPropagation();
        },
        focus: function (element, event) {
            this.searchInputWidth = element.css('width');
            element.animate({
                'width': 600
            }, 500);
            $('#js-navbar-collapse > ul').fadeOut();
        },
        close: function (element, event) {
            var $this = this;

            $('.js-search-results').hide();
            $('.js-search-input').animate({
                'width': $this.searchInputWidth
            }, 500);
            $('#js-navbar-collapse > ul').fadeIn();
        },
        search: function (element, event) {
            var $this = this;

            if (event.keyCode == 13 || event.keyCode == 38 || event.keyCode == 40) {
                return;
            }

            var query = element.val(),
                results = $this.index.search(query);

            if (!results.length) {
                $this.searchResults.empty();
                return;
            }

            var resultsList = results.reduce(function (ul, result) {
                var item = $this.store[result.ref];
                var title = $('<b>').text(item.title);

                var cropText = $this.cropText(item.content, query);
                if (cropText.length === 0) {
                    cropText = $('<p>').html(item.content.substring(0, 120) + "...");
                }
                var content = content = $('<p>').html(cropText);

                var div = $('<div>')
                    .append(title)
                    .append(content);
                var a = $('<a>').attr('href', item.href)
                    .append(div);
                var li = $('<li>')
                    .append(a);
                ul.append(li);

                return ul;
            }, $('<ul>'));

            this.searchResults.html(resultsList);

            $('.js-search-results').show();
            $(".js-search-results li:first-child").addClass('selected');
        },
        cropText: function (content, query) {
            var cropedText = '',
                re = new RegExp("\\s?(.{0,30})?" + query + ".*?\\b(.{0,30}.)?\\s?", "gi");

            $.each(content.match(re), function (key, value) {
                cropedText += '...' + value + '...';
            });

            return cropedText;
        },
        navigation: function (element, event) {
            var selected = null,
                listSelector = ".js-search-results ul",
                listItemSelector = listSelector + " li",
                selectedListItemSelector = listItemSelector + ".selected",
                selectedListItemSelectorAnchor = listItemSelector + ".selected a";

            // enter
            if (event.keyCode == 13) {
                event.preventDefault();
                this.close();
                window.location.replace($(selectedListItemSelectorAnchor).attr('href'));
            }

            // up
            if (event.keyCode == 38) {
                selected = $(selectedListItemSelector);
                $(listItemSelector).removeClass("selected");

                if (selected.prev().length == 0) {
                    selected.siblings().last().addClass("selected");
                } else {
                    selected.prev().addClass("selected");
                }

                selected = $(selectedListItemSelector);
                this.scrollListUp(selected);
            }

            // down
            if (event.keyCode == 40) {
                selected = $(selectedListItemSelector);
                $(listItemSelector).removeClass("selected");

                if (selected.next().length == 0) {
                    selected.siblings().first().addClass("selected");
                } else {
                    selected.next().addClass("selected");
                }

                selected = $(selectedListItemSelector);
                this.scrollListDown(selected);
            }
        },
        scrollListDown: function (element) {
            var ul = element.parent(),
                ulHeight = ul.height(),
                ulBottomPosition = ulHeight + ul.scrollTop(),
                liBottomPosition = element.position().top + element.height();

            if (liBottomPosition > ulBottomPosition) {
                ul.scrollTop(liBottomPosition - ulHeight);
            }

            if (element.is(':first-child')) {
                ul.scrollTop(0);
            }
        },
        scrollListUp: function (element) {
            var ul = element.parent(),
                ulTopPosition = ul.scrollTop(),
                liTopPosition = element.position().top;

            if (liTopPosition < ulTopPosition) {
                ul.scrollTop(element.position().top);
            }

            if (element.is(':last-child')) {
                ul.scrollTop(element.position().top - element.height());
            }
        }
    };

    $(function () {
        var search = new Search();
        search.init();
    });
</script>
<script src="https://bartaz.github.io/sandbox.js/jquery.highlight.js"></script>
</body></html>

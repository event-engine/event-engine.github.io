[{"id":"https:\/\/event-engine.github.io\/intro.html#1","title":"About Event Engine","content":"Prooph Event Engine takes away all the boring, time consuming parts of event sourcing to speed up development of event sourced applications and increase the fun. It can be used for prototypes as well as full featured applications."},{"id":"https:\/\/event-engine.github.io\/intro.html#1-1","title":"Origin","content":"Event Engine was originally designed as a \"workshop framework\" for CQRS and Event Sourcing and is inspired by the Dreyfus model."},{"id":"https:\/\/event-engine.github.io\/intro.html#1-1-1","title":"Beginner friendly","content":" The Dreyfus model distinguishes five levels of competence, from novice to mastery. At the absolute beginner level people execute tasks based on \u00e2\u0080\u009crigid adherence to taught rules or plans\u00e2\u0080\u009d. Beginners need recipes. They don\u00e2\u0080\u0099t need a list of parts, or a dozen different ways to do the same thing. Instead what works are step by step instructions that they can internalize. As they practice them over time they learn the reasoning behind them, and learn to deviate from them and improvise, but they first need to feel like they\u00e2\u0080\u0099re doing something. (source: https:\/\/lambdaisland.com\/blog\/25-05-2017-simple-and-happy-is-clojure-dying-and-what-has-ruby-got-to-do-with-it)"},{"id":"https:\/\/event-engine.github.io\/intro.html#1-1-2","title":"Rapid Application Development","content":"It turned out that Event Engine is not only a very good CQRS and Event Sourcing learning framework but that the same concept can be used for rapid application development (RAD). RAD frameworks focus on developer happiness and coding speed. Both can be achieved by using conventions, which allow the framework to do a lot of work \"under the hood\" Developers can focus on the important part: developing the application."},{"id":"https:\/\/event-engine.github.io\/intro.html#1-2","title":"Event Engine Flavours","content":"Event Engine Flavours make it possible to turn a rapidly developed prototype into a rock solid application. You can switch from the default PrototypingFlavour to either the FunctionalFlavour or OopFlavour. Finally, you can implement your own Flavour to build your very own CQRS \/ ES framework.Learn More"},{"id":"https:\/\/event-engine.github.io\/intro.html#1-3","title":"Pros","content":" Developed and maintained by prooph core team members Ready-to-use skeleton Less code to write Guided event sourcing extension points to inject custom logic Audit log from day one (no data loss) Multi-Model-Store Replay functionality Projections based on domain events PSR friendly http message box OpenAPI v3 Swagger integration "},{"id":"https:\/\/event-engine.github.io\/intro.html#1-4","title":"Cons","content":" Not suitable for monolithic architectures "},{"id":"https:\/\/event-engine.github.io\/intro.html#1-4-1","title":"You may want to use Event Engine if:","content":" Your project is in an early stage and you need to try out different ideas or deliver features very fast You want to establish a Microservices architecture rather than building a monolithic system You want to automate business processes You have to develop a workflow-oriented service You're new to the concepts of CQRS and Event Sourcing and want to learn them "},{"id":"https:\/\/event-engine.github.io\/intro.html#1-5","title":"Conclusion","content":"Try the tutorial and build a prototype with Event Engine!"},{"id":"https:\/\/event-engine.github.io\/intro.html#1-6","title":"Powered By","content":"Event Engine is maintained by the prooph software team. Prooph software offers commercial support and workshops for Event Engine as well as for the prooph components.If you are interested please get in touch"},{"id":"https:\/\/event-engine.github.io\/tutorial\/intro.html#2-1","title":"Introduction","content":"Event Engine is a rapid application development (RAD) framework. The basic concepts will be explained throughout the tutorial. Once finished, you should be able to start with your own project. The API docs will help you along the way."},{"id":"https:\/\/event-engine.github.io\/tutorial\/intro.html#2-1-1","title":"Tutorial Domain","content":"We're going to build a backend for a small web application where you can register buildings and then check in and check out users in the buildings. The backend will expose a messagebox endpoint that excepts commands and queries. Each time a user is checked in or checked out we get a notification via a websocket connection.The screenshot is taken from InspectIO - a domain modelling tool for (remote) teams that supports living documentation. Event Engine users can request free access in the chat.Credits: The tutorial domain is the same as the one used by Marco Pivetta in his CQRS and Event Sourcing Workshops."},{"id":"https:\/\/event-engine.github.io\/tutorial\/intro.html#2-1-2","title":"Application set up","content":"Please make sure you have Docker and Docker Compose installed.Note: Docker is THE ONLY supported set up at the moment. If you don't want to install docker you need PHP 7.4+ and Postgres 9.4+."},{"id":"https:\/\/event-engine.github.io\/tutorial\/intro.html#2-1-2-1","title":"Clone Event Engine Skeleton","content":"Change into your working directory and use composer to create a new project based on the event engine skeleton using ee-buildings as project name.$ docker run --rm -it -v $(pwd):\/app prooph\/composer:7.4 create-project event-engine\/php-engine-skeleton ee-buildings Change into the newly created project dir ee-buildings, start the docker containers and run the set up script for the event store.$ cd ee-buildings $ sudo chown -R $(id -u -n):$(id -g -n) . $ docker-compose up -d $ docker-compose run php php scripts\/create_event_stream.php The last command should output done. otherwise it will throw an exception."},{"id":"https:\/\/event-engine.github.io\/tutorial\/intro.html#2-1-2-2-1","title":"Database","content":"Verify database set up by connecting to the Postgres database using:host: localhost port: 5432 dbname: event_engine user: postgres pwd: dev Note: Credentials are defined in app.env and can be changed there.You should see three tables: event_streams, projections and _&lt;sha1&gt;. The latter is a table created by prooph\/event-store. It will contain all domain events."},{"id":"https:\/\/event-engine.github.io\/tutorial\/intro.html#2-1-2-2-2","title":"Webserver","content":"Head over to https:\/\/localhost to check if the containers are up and running. After accepting the self-signed certificate you should see a simple \"It works\" message."},{"id":"https:\/\/event-engine.github.io\/tutorial\/intro.html#2-1-2-2-3","title":"Event Engine Cockpit","content":"By default Event Engine exposes commands (we will learn more about them in a minute), events, and queries via a message box endpoint. We can use Event Engine Cockpit to interact with the backend.The Event Engine skeleton ships with a ready to use Cockpit configuration. Open https:\/\/localhost:4444 in your browser and try the built-in HealthCheck query.You should get a JSON response similar to that one:{ \"system\": true } If everything works correctly we are ready to implement our first use case: Add a buildingIf something is not working as expected (now or later in the tutorial) please check the trouble shooting section of the event-engine\/php-engine-skeleton README first."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partI.html#2-2","title":"Part I - Add A Building","content":"We're going to add the first action to our buildings application. In a CQRS system, such as Event Engine, operations and processes are triggered by messages. Those messages can have three different types and define the API of the application. In the first part of the tutorial we learn the first message type: command."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partI.html#2-2-1","title":"API","content":"The Event Engine skeleton includes an API folder (src\/Domain\/Api) that contains a predefined set of EventEngineDescription classes. We will look at these descriptions step by step and start with src\/Domain\/Api\/Command.php:Throughout the tutorial we'll use the default namespace of the skeleton MyService. If you use the skeleton for a project, you can replace it with your own.&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; class Command implements EventEngineDescription { \/** * Define command names using constants * * @example * * const REGISTER_USER = 'RegisterUser'; *\/ \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { \/\/Describe commands of the service and corresponding payload schema (used for input validation) } } The Command description is used to group all commands of our application into one file and add semantic meaning to our code. Replace the comment with a real constant const ADD_BUILDING = 'AddBuilding'; and register the command in the describe method.&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use EventEngine\\JsonSchema\\JsonSchema; class Command implements EventEngineDescription { const ADD_BUILDING = 'AddBuilding'; \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;registerCommand( Command::ADD_BUILDING, JsonSchema::object( [ 'buildingId' =&gt; JsonSchema::uuid(), 'name' =&gt; JsonSchema::string(['minLength' =&gt; 2]) ] ) ); } } Event Engine supports JSON Schema to describe messages. The advantage of JSON schema is that we can configure validation rules for our messages. Whenever Event Engine receives a message (command, event or query) it uses the defined JSON Schema for that message to validate the input. We configure it once and Event Engine takes care of the rest."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partI.html#2-2-2","title":"Descriptions","content":"Event Engine Descriptions are very important. They are called at \"compile time\" and used to configure Event Engine. Descriptions can be cached to speed up bootstrapping. Find more information in the API docs @TODO: link docs."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partI.html#2-2-3","title":"Cockpit Integration","content":"Switch to the Cockpit UI and reload the schema (press refresh button in top menu). Cockpit should show a new command called AddBuilding in the commands section.Click on \"commands\" in the left sidebar and then on \"Not Categorized\" to see the command. Send the AddBuilding command with this payload:{ \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"Acme Headquarters\" } Response:{ \"exception\": { \"message\": \"No routing information found for command AddBuilding\", \"details\": \"...\" } } Our command cannot be handled because a command handler is missing. In Event Engine commands can be routed directly to Aggregates. In part II you'll learn more about pure aggregates.Sum up: Event Engine Descriptions allow you to easily describe the API of your application using messages. The messages get a unique name and payload is described with JSON Schema which allow us to add validation rules. The messages and their schema can be used by Event Engine Cockpit to interact with the backend service."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partII.html#2-3","title":"Part II - The Building Aggregate","content":"In Event Engine we can take a short cut and skip command handlers. This is possible because Aggregates in Event Engine are stateless and pure. This means that they don't have internal state and also no dependencies.Simply put: they are just functionsEvent Engine can take over the boilerplate and we, as developers, can focus on the business logic. I'll explain in greater detail later, but first we want to see a pure aggregate function in action.Note: If you've worked with a CQRS framework before, it's maybe confusing because normally a command is handled by a command handler (comparable to an application service that handles a domain action) and the command handler would load a business entity or \"DDD\" aggregate from a repository. We still use the aggregate concept but make use of a functional programming approach. It keeps the domain model lean and testable and allows some nice optimizations for RAD infrastructure.Let's add the first aggregate called Building in a new Model folder:&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model; use EventEngine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { \/\/yield domain events } } As you can see the Building class uses static methods. It does not extend from a base class and has no dependencies. We could also use plain PHP functions instead but unfortunately PHP does not provide function autoloading (yet), so we stick to static methods and group all methods of an aggregate in a class.Building::add() receives AddBuilding messages (of type command) and should perform the business logic needed to add a new building to our application. But instead of adding a new building directly we're ask to yield a domain event.A neat feature called Flavours allows you to choose between different programming styles. Throughout the tutorial we use the PrototypingFlavour. Two bonus parts at the end of the tutorial introduce the FunctionalFlavour and OopFlavour."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partII.html#2-3-1","title":"Domain Events","content":"Domain events are the second message type used by Event Engine. The domain model is event sourced, meaning it records all state changes in a series of domain events. These domain events are yielded by aggregate methods and stored in an event store managed by Event Engine. The series of events can then be used to calculate the current state of an aggregate. We will see that in action in a later part of the tutorial and get a better understanding of the technique when we add more use cases.For now let's add the first domain event in src\/Domain\/Api\/Event:&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use EventEngine\\JsonSchema\\JsonSchema; class Event implements EventEngineDescription { const BUILDING_ADDED = 'BuildingAdded'; \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;registerEvent( self::BUILDING_ADDED, JsonSchema::object( [ 'buildingId' =&gt; JsonSchema::uuid(), 'name' =&gt; JsonSchema::string(['minLength' =&gt; 2]) ] ) ); } } It looks similar to the AddBuilding command but uses a past tense name. That is a very important difference. Commands tell the application what it should do and events represent facts that have happened."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partII.html#2-3-2","title":"Yielding Events","content":"Aggregate methods can yield null, one domain event or multiple domain events depending on the result of the executed business logic. If an aggregate method yields null it indicates that no important fact happened and no event needs to be recorded. In many cases an aggregate method will yield one event which is the fact caused by the corresponding command. But there is no one-to-one connection between commands and events. In some cases more than one event is needed to communicate important facts or an error event is yielded instead of the expected event (we'll see that later).For the first use case we simply yield a BuildingAdded domain event when Building::add() is called with a AddBuilding command.&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model; use MyService\\Domain\\Api\\Event; use EventEngine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { yield [Event::BUILDING_ADDED, $addBuilding-&gt;payload()]; } } The special array syntax for yielding events is a short cut used by Event Engine. It creates the event based on given event name and payload and stores it in the event stream."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partII.html#2-3-3","title":"Aggregate Description","content":"If we switch back to Cockpit and send the AddBuilding command again, Event Engine still complains about a missing command handler. We need to tell Event Engine about our new aggregate and that it is responsible for handling AddBuilding commands. We can do this in another Event Engine Description in src\/Domain\/Api\/Aggregate.&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use MyService\\Domain\\Model\\Building; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; class Aggregate implements EventEngineDescription { const BUILDING = 'Building'; \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;process(Command::ADD_BUILDING) -&gt;withNew(self::BUILDING) -&gt;identifiedBy('buildingId') -&gt;handle([Building::class, 'add']) -&gt;recordThat(Event::BUILDING_ADDED); } } The connection between command and aggregate is described in a very verbose and readable way. Our IDE can suggest the describing methods of Event Engine's fluent interface and it is easy to remember each step. process tells Event Engine that the following description is for the given command name. withNew\/withExisting tells Event Engine which aggregate handles the command and if the aggregate exists already or a new one should be created. identifiedBy tells Event Engine which message payload property should be used to identify the responsible aggregate. Every command sent to the aggregate and every event yielded by the aggregate should contain this property handle takes a callable argument which is the aggregate method responsible for handling the command defined in process. We use the callable array syntax of PHP which can be analyzed by modern IDEs like PHPStorm for auto completion and refactorings. recordThat tells Event Engine which event is yielded by the aggregate's command handling method. If we try again to send AddBuilding (or reload the schema in Cockpit) we get a new error:{ \"exception\": { \"message\": \"No apply function specified for event: BuildingAdded\", \"details\": \"...\" } } Command handling works now but an apply function is missing. In part III of the tutorial you'll learn how to add such a function and why it is needed."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partIII.html#2-4","title":"Part III - Aggregate State","content":"In part II we took a closer look at pure aggregate functions (implemented as static class methods in PHP because of missing function autoloading capabilities). Pure functions don't have side effects and are stateless. This makes them easy to test and understand. But an aggregate without state? How can an aggregate protect invariants (its main purpose) without state?The aggregate needs a way \"to look back\". It needs to know what happened in the past according to its own lifecycle. Without its current state and without information about past changes the aggregate could only execute business logic and enforce business rules based on the given information of the current command passed to a handling function. In most cases this is not enough.The functional programming solution to that problem is to pass the current state (which is computed from past events) to each command handling function (except the one handling the first command). This means that aggregate behaviour (command handling functions) and aggregate state (a data structure of a certain type) are two different things and separated from each other. How this is implemented in Event Engine is shown in this part of the tutorial."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partIII.html#2-4-1","title":"Applying Domain Events","content":"Aggregate state is computed by iterating over all recorded domain events of the aggregate history starting with the oldest event. Event Engine does not provide a generic way to compute current state, instead the aggregate should have an apply function for each recorded event. Those apply functions are often prefixed with when followed by the event name.Let's add such a function for our BuildingAdded domain event.&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model; use MyService\\Domain\\Api\\Event; use EventEngine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { yield [Event::BUILDING_ADDED, $addBuilding-&gt;payload()]; } public static function whenBuildingAdded(Message $buildingAdded): Building\\State { \/\/@TODO: Return new state for the aggregate } } BuildingAdded communicates that a new lifecycle of a building was started (new building was added to our system), so the Building::whenBuildingAdded() function has to return a new state object and does not receive a current state object as an argument (next when* function will receive one!).But what does the State object look like? Well, you can use whatever you want. Event Engine does not care about a particular implementation (see docs for details). However, Event Engine ships with a default implementation of an ImmutableRecord. We use that implementation in the tutorial, but it is your choice if you want to use it, too.Create a State class in src\/Domain\/Model\/Building (new directory):&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model\\Building; use EventEngine\\Data\\ImmutableRecord; use EventEngine\\Data\\ImmutableRecordLogic; final class State implements ImmutableRecord { use ImmutableRecordLogic; public const BUILDING_ID = 'buildingId'; public const NAME = 'name'; \/** * @var string *\/ private $buildingId; \/** * @var string *\/ private $name; \/** * @return string *\/ public function buildingId(): string { return $this-&gt;buildingId; } \/** * @return string *\/ public function name(): string { return $this-&gt;name; } } Note: You can use PHPStorm to generate the Getter-Methods. You only have to write the private properties and add the doc blocks with @var type hints. Then use PHPStorm's ability to add the Getter-Methods (ALT+EINF). By default PHPStorm sets a get* prefix for each method. However, immutable records don't have setter methods and don't work with the get* prefix. Just change the template in your PHPStorm config: Settings -&gt; Editor -&gt; File and Code Templates -&gt; PHP Getter Method to:\/** * @return ${TYPE_HINT} *\/ public ${STATIC} function ${FIELD_NAME}()#if(${RETURN_TYPE}): ${RETURN_TYPE}#else#end { #if (${STATIC} == \"static\") return self::$${FIELD_NAME}; #else return $this-&gt;${FIELD_NAME}; #end } Now we can return a new Building\\State from Building::whenBuildingAdded().&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model; use MyService\\Domain\\Api\\Event; use EventEngine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { yield [Event::BUILDING_ADDED, $addBuilding-&gt;payload()]; } public static function whenBuildingAdded(Message $buildingAdded): Building\\State { return Building\\State::fromArray($buildingAdded-&gt;payload()); } } Finally, we have to tell Event Engine about that apply function to complete the AddBuilding use case description. In src\/Domain\/Api\/Aggregate:&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use MyService\\Domain\\Model\\Building; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; class Aggregate implements EventEngineDescription { const BUILDING = 'Building'; \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;process(Command::ADD_BUILDING) -&gt;withNew(self::BUILDING) -&gt;identifiedBy('buildingId') -&gt;handle([Building::class, 'add']) -&gt;recordThat(Event::BUILDING_ADDED) \/\/Map recorded event to apply function -&gt;apply([Building::class, 'whenBuildingAdded']); } } We're done with the write model for the first use case. If you send the AddBuilding command again using Cockpit:{ \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"Acme Headquarters\" } ... you should receive a new error.{ \"exception\": { \"message\": \"SQLSTATE[42P01]: Undefined table: 7 ERROR: relation \\\"building_projection_0_1_0\\\" does not exist ...\", \"details\": \"...\" } } Sorry for that many errors. But learning by mistake is the best way to learn!"},{"id":"https:\/\/event-engine.github.io\/tutorial\/partIII.html#2-4-2","title":"MultiModelStore","content":"The skeleton comes preconfigured with a so called MultiModelStore. Such a store is capable of storing events and state of an aggregate in one transaction.Using a MultiModelStore reduces the problem of eventual consistency, which many see as a main drawback of Event Sourcing. This hybrid approach has its own downsides, discussed in more details in the docs (@TODO: link docs). However, in Event Engine you can switch between \"state only\", \"events and state\" and \"events only\" mode on a per aggregate basis. That's really powerful. You can choose the right storage strategy for each scenario and continuously fine tune the system.The error is caused by a missing state table for our Building aggregate. At the beginning of the tutorial we've only set up the write model event stream. By default all recorded events of all aggregates are stored in that stream table. A similar table for aggregate state does not exist. We have to create one for each aggregate."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partIII.html#2-4-2-1","title":"Buildings Collection","content":"Add a new php file called create_collections.php next to the create_event_stream.php file in the scripts folder:&lt;?php declare(strict_types=1); require_once 'vendor\/autoload.php'; $container = require 'config\/container.php'; \/** @var \\EventEngine\\DocumentStore\\DocumentStore $documentStore *\/ $documentStore = $container-&gt;get(EventEngine\\DocumentStore\\DocumentStore::class); if(!$documentStore-&gt;hasCollection('buildings')) { echo \"Creating collection buildings.\\n\"; $documentStore-&gt;addCollection('buildings'); } echo \"done.\\n\"; Run the script with:docker-compose run php php scripts\/create_collections.php If you look at the Postgres database, you'll see a new buildings table.Ok, what did we do?The MultiModelStore is composed of an EventStore and a DocumentStore. Both use the same underlying database which is Postgres in our case and they share the same \\PDO connection.src\/Persistence\/PersistenceServices.php contains the actual set up logic:public function multiModelStore(): MultiModelStore { return $this-&gt;makeSingleton(MultiModelStore::class, function () { return new ComposedMultiModelStore( $this-&gt;transactionalConnection(), $this-&gt;eventEngineEventStore(), $this-&gt;documentStore() ); }); } This allows the MultiModelStore to control the transaction for both. The DocumentStore interface is inspired by MongoDB's API. Postgres can be used as a document store due to JSON support. You don't need to worry about the low level JSON API but can instead use the high level abstraction provided by Event Engine."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partIII.html#2-4-2-2","title":"Aggregate Storage Settings","content":"We've just created a new table in Postgres called buildings using the high level DocumentStore abstraction provided by Event Engine, but the error complains about a missing table called building_projection_0_1_0. Event Engine applies a default naming strategy for aggregate state collections (in case of Postgres collection equals table) if not specified otherwise.We can tell Event Engine to use the buildings collection instead by adding a hint to the aggregate description in src\/Domain\/Api\/Aggregate.php:&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use MyService\\Domain\\Model\\Building; class Aggregate implements EventEngineDescription { const BUILDING = 'Building'; \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;process(Command::ADD_BUILDING) -&gt;withNew(self::BUILDING) -&gt;identifiedBy('buildingId') -&gt;handle([Building::class, 'add']) -&gt;recordThat(Event::BUILDING_ADDED) -&gt;apply([Building::class, 'whenBuildingAdded']) -&gt;storeStateIn('buildings'); \/\/Use buildings collection for aggregate state } } Send the command again:{ \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"Acme Headquarters\" } This time the command goes through. If everything is fine the message box returns a 202 command accepted response.Event Engine emphasizes a CQRS and Event Sourcing architecture. For commands this means that no data is returned. The write model has received and processed the command AddBuilding successfully but we don't know what the new application state looks like. We will use a query, which is the third message type, to get this data. Head over to tutorial part IV to learn more about queries and application state management using the MultiModelStore."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partIV.html#2-5","title":"Part IV - Projections and Queries","content":"In part III of the tutorial we implemented the first write model use case: Add a new building. Connect to the Postgres database and check the event stream table _4228e4a00331b5d5e751db0481828e22a2c3c8ef. The table should contain the first domain event yielded by the Building aggregate. no event_id event_name payload metadata created_at 1 bce42506-... BuildingAdded {\"buildingId\":\"9ee8d8a8-...\",\"name\":\"Acme Headquarters\"} {\"_aggregate_id\": \"9ee8d8a8-...\", \"_causation_id\": \"e482f5b8-...\", \"_aggregate_type\": \"Building\", \"_causation_name\": \"AddBuilding\", \"_aggregate_version\": 1} 2018-02-14 22:09:32.039848 If you're wondering why the event stream table has a sha1 hashed name this is because by default prooph\/event-store uses that naming strategy to avoid database vendor specific character constraints. You can however configure a different naming strategy if you don't like it.The write model only needs an event stream to store information but the read side has a hard time querying it. As long as we only have a few events in the stream queries are simple and fast. But over time this table will grow and contain many different events. To stay flexible we need to separate the write side from the read side. An event sourced system normally uses projections to create materialized views of the application state and keep them in sync with the write model.The problem with projections is eventual consistency. A highly distributed system has to deal with eventual consistency. In fact, many modern systems already deal with it in one way or the other, for example if you use Elastic Search or Redis next to your primary database.However, Event Engine gives you fine grained control of consistency versus performance and availability. All through an easy to use high level API. The tutorial only covers the tip of the iceberg. But for now it's enough to know that you have many options. Once you've internalized the basics, you can customize the skeleton to meet your needs."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partIV.html#2-5-1","title":"Permanent Snapshots","content":"As already discussed in the last tutorial part, Event Engine offers an alternative to async projections namely the MultiModelStore. You can think of it like a projection or a snapshot mechanism that runs within the same transaction as the write model does. The result is a snapshot of the aggregate state that is always in sync with its persisted events. Hence, it is safe to rely on the state without worrying about eventual consistency issues.If you look at the buildings table of the Postgres DB, you should see one row with two columns id and doc with id being the buildingId and doc being the JSON representation of the Building\\State.Event Engine allows you to start with permanent snapshots and switch to async projections later by adjusting the configuration."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partIV.html#2-5-2","title":"Cockpit","content":"With Event Engine Cockpit developers can inspect aggregates and view state and recorded events side by side. Reload the schema in Cockpit (refresh button in top menu) and inspect the building aggregate."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partIV.html#2-5-3","title":"Query, Resolver and Return Type","content":"We already know that Event Engine uses JSON Schema to describe message types and define validation rules. For queries we can also register return types in Event Engine.Registering types is done in src\/Domain\/Api\/Type.&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\JsonSchema\\JsonSchema; use EventEngine\\JsonSchema\\Type\\ObjectType; use MyService\\Domain\\Model\\Building; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; class Type implements EventEngineDescription { const BUILDING = 'Building'; private static function building(): ObjectType { return JsonSchema::object([ Building\\State::BUILDING_ID =&gt; JsonSchema::uuid(), Building\\State::NAME =&gt; JsonSchema::string(), ]); } \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;registerType(self::BUILDING, self::building()); } } We describe Building\\State using JSON Schema and register the type in Event Engine.Note: Using aggregate state as return type for queries couples the write model with the read model. However, you can replace the return type definition at any time. So we can use the short cut in an early stage and switch to a decoupled version later.Next step is to register the query in src\/Domain\/Api\/Query:&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use EventEngine\\JsonSchema\\JsonSchema; class Query implements EventEngineDescription { const BUILDING = 'Building'; public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;registerQuery(self::BUILDING, JsonSchema::object([ 'buildingId' =&gt; JsonSchema::uuid(), ])) -&gt;resolveWith(\/* ??? *\/) -&gt;setReturnType(JsonSchema::typeRef(Type::BUILDING)); } } Queries are named like the \"things\" they return. This results in a clean and easy to use message box schema.Please note that the return type is a reference: JsonSchema::typeRef().Last but not least, the query needs to be handled by a so-called resolver. Create a new class called BuildingResolver in a new directory Resolver in src\/Domain.&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Resolver; use EventEngine\\Messaging\\Message; use EventEngine\\Querying\\Resolver; final class BuildingResolver implements Resolver { \/** * @param Message $query * @return mixed *\/ public function resolve(Message $query) { \/\/ TODO: Implement resolve() method. } } The BuildingResolver implements EventEngine\\Querying\\Resolver. It receives the query message as the only argument.Task of the resolver is to query the read model. While looking at snapshots and projections we briefly discussed Event Engine's DocumentStore API. The resolver can use it to access documents organized in collections. Let's see how that works.&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Resolver; use EventEngine\\DocumentStore\\DocumentStore; use EventEngine\\Messaging\\Message; use EventEngine\\Querying\\Resolver; final class BuildingResolver implements Resolver { \/** * @var DocumentStore *\/ private $documentStore; public function __construct(DocumentStore $documentStore) { $this-&gt;documentStore = $documentStore; } \/** * @param Message $query * @return array *\/ public function resolve(Message $query): array { $buildingId = $query-&gt;get('buildingId'); $buildingDoc = $this-&gt;documentStore-&gt;getDoc('buildings', $buildingId); if(!$buildingDoc) { throw new \\RuntimeException(\"Building not found\", 404); } return $buildingDoc['state']; } } The implementation is self explanatory, but a few notes should be made.Each Event Engine message has a get and a getOrDefault method which are both short cuts to access keys of the message payload. The difference between the two is obvious. If the payload key is NOT set and you use get the message will throw an exception. If the payload key is NOT set and you use getOrDefault you get back the default passed as the second argument.The second note is about $buildingDoc['state']. The document store returns raw data stored as a document. And because we use the MultiModeStore to persist aggregate state, it is stored as a snapshot of the form:{ \"id\": \"&lt;aggregate_id&gt;\", \"doc\": { \"state\": {\"state\": {\"of\": \"the aggregate\"}}, \"version\": 1 } } We don't want to expose internal storage format to public consumers. Therefor, the resolver only returns what is stored in the state property of the document.We could also use a DTO instead of returning an array to add more type safety to the resolver. The DTO should either has a toArray method or implement \\JsonSerializable so that the message box can turn it into a JSON response. By the way, the message box is part of the skeleton. Feel free to adjust it, if you want to use a serializer library.Finally, we need to configure Event Engine's DI container to inject the dependencies into our new resolver."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partIV.html#2-5-4","title":"Discolight PSR-11 Container","content":"Event Engine can use any PSR-11 compatible container. By default it uses a very simple implementation called Discolight included in the Event Engine package family. The DI container is inspired by bitExpert\/disco but removes the need for annotations. Dependencies are aggregated in a single ServiceFactory class which is located directly in src.The ServiceFactory pulls dependencies from modules. The skeleton organizes modules by system layers: Domain: contains everything related to the business logic Http: contains the message box and other PSR-15 middleware Persistence: contains classes and definitions related to storage System: contains things like a logger and the default HealthCheckResolver Each module has a &lt;Module&gt;Services trait, which is loaded into the ServiceFactory. It's an easy way to group dependencies using plain PHP. No configuration files, no magic and IDE support without extra plugins.When working with Event Engine you'll recognize that you don't need a heavy DI container. You have a single message box instead of a growing number of controllers. You don't have heavy application services, but small single purpose ones like the resolver we've just added. You don't need repositories for entities, because Event Engine manages persistence based on aggregate logic and descriptions. In fact, the entire CQRS \/ ES application architecture ensures that you use small building blocks and coordinate them by using messages.To set up the BuildingResolver adjust src\/Domain\/DomainServices.php:&lt;?php declare(strict_types=1); namespace MyService\\Domain; use MyService\\Domain\\Api\\Aggregate; use MyService\\Domain\\Api\\Command; use MyService\\Domain\\Api\\Event; use MyService\\Domain\\Api\\Listener; use MyService\\Domain\\Api\\Projection; use MyService\\Domain\\Api\\Query; use MyService\\Domain\\Api\\Type; use MyService\\Domain\\Resolver\\BuildingResolver; trait DomainServices { public function buildingResolver(): BuildingResolver { return $this-&gt;makeSingleton(BuildingResolver::class, function () { return new BuildingResolver($this-&gt;documentStore()); }); } public function domainDescriptions(): array { return [ Type::class, Command::class, Event::class, Query::class, Aggregate::class, Projection::class, Listener::class, ]; } } A few notes about the trait. It uses methods defined in other &lt;Module&gt;Services traits or in the main ServiceFactory. PHPStorm can suggest and resolve methods, because all traits are combined in the ServiceFactory. This allows you to quickly navigate the dependency tree. Something that is really painful when using most other DI container solutions.$this-&gt;makeSingleton() is a helper method that turns the requested service in a singleton. All subsequent calls to buildingResolver() will return the same instance instead of a new one. Return services directly if the container should provide a new instance on each $container-&gt;get(Service::class) call.domainDescriptions() is a method required by the main ServiceFactory. It returns all Event Engine descriptions of the module so that they are registered in Event Engine.Finally, tell Event Engine that the BuildingResolver is responsible for the Building query:&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use EventEngine\\JsonSchema\\JsonSchema; use MyService\\Domain\\Resolver\\BuildingResolver; class Query implements EventEngineDescription { const BUILDING = 'Building'; public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;registerQuery(self::BUILDING, JsonSchema::object([ 'buildingId' =&gt; JsonSchema::uuid(), ])) -&gt;resolveWith(BuildingResolver::class) -&gt;setReturnType(JsonSchema::typeRef(Type::BUILDING)); } } Ok! We should be able to query buildings by buildingId now. Switch to Cockpit and reload the schema. The query list should contain a new Query: Building. If we send that query with the buildingId used in AddBuilding:{ \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\" } We get back:{ \"name\": \"Acme Headquarters\", \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\" } Awesome, isn't it?"},{"id":"https:\/\/event-engine.github.io\/tutorial\/partIV.html#2-5-5","title":"Optional Query Arguments","content":"Resolvers can also handle multiple queries. This is useful when different queries can be resolved by accessing the same read model collection. A second query for the BuildingResolver would be one that lists all buildings or a subset filtered by name.Add the query to src\/Domain\/Api\/Query:&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use EventEngine\\JsonSchema\\JsonSchema; use MyService\\Domain\\Resolver\\BuildingResolver; class Query implements EventEngineDescription { const BUILDING = 'Building'; const BUILDINGS = 'Buildings'; \/\/&lt;-- New query, note the plural public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;registerQuery(self::BUILDING, JsonSchema::object([ 'buildingId' =&gt; JsonSchema::uuid(), ])) -&gt;resolveWith(BuildingResolver::class) -&gt;setReturnType(JsonSchema::typeRef(Type::BUILDING)); \/\/New query $eventEngine-&gt;registerQuery( self::BUILDINGS, JsonSchema::object( [], \/\/No required arguments for this query \/\/Optional argument name, is a nullable string ['name' =&gt; JsonSchema::nullOr(JsonSchema::string()-&gt;withMinLength(1))] ) ) \/\/Resolve query with same resolver ... -&gt;resolveWith(BuildingResolver::class) \/\/... but return an array of Building type -&gt;setReturnType(JsonSchema::array( JsonSchema::typeRef(Type::BUILDING) )); } } The refactored BuildingResolver looks like this:&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Resolver; use EventEngine\\DocumentStore\\DocumentStore; use EventEngine\\DocumentStore\\Filter\\AnyFilter; use EventEngine\\DocumentStore\\Filter\\LikeFilter; use EventEngine\\Messaging\\Message; use EventEngine\\Querying\\Resolver; use MyService\\Domain\\Api\\Query; final class BuildingResolver implements Resolver { \/** * @var DocumentStore *\/ private $documentStore; public function __construct(DocumentStore $documentStore) { $this-&gt;documentStore = $documentStore; } \/** * @param Message $query * @return array *\/ public function resolve(Message $query): array { switch ($query-&gt;messageName()) { case Query::BUILDING: return $this-&gt;resolveBuilding($query-&gt;get('buildingId')); case Query::BUILDINGS: return $this-&gt;resolveBuildings($query-&gt;getOrDefault('name', null)); } } private function resolveBuilding(string $buildingId): array { $buildingDoc = $this-&gt;documentStore-&gt;getDoc('buildings', $buildingId); if(!$buildingDoc) { throw new \\RuntimeException(\"Building not found\", 404); } return $buildingDoc['state']; } private function resolveBuildings(string $nameFilter = null): array { $filter = $nameFilter? new LikeFilter('state.name', \"%$nameFilter%\") : new AnyFilter(); $cursor = $this-&gt;documentStore-&gt;findDocs('buildings', $filter); $buildings = []; foreach ($cursor as $doc) { $buildings[] = $doc['state']; } return $buildings; } } BuildingResolver can resolve both queries by mapping the query name to an internal resolve* method. For the new Buildings query the resolver makes use of DocumentStore\\Filters. The LikeFilter works the same way as a SQL like expression using % as a placeholder. AnyFilter matches any documents in the collection. There are many more filters available. Read more about filters in the docs (@TODO: link docs).You can test the new query using Cockpit. This is an example query with a name filter:{ \"name\": \"Acme\" } Add some more buildings and play with the queries. Try to exchange the LikeFilter with an EqFilter for example. Or see what happens if you pass an empty string as name filter.Since aggregate state is stored as a snapshot, we need to keep in mind that state is the root property. Nested keys can be referenced using dot notation (f.e. \"state.name\"). If you don't use the MultiModelStore and create your own read models, then you don't need that snapshot format. But remember: without the MultiModelStore you definitely need to deal with eventual consistency whenever reading data from a read model.In part VI we get back to the write model and learn how to work with process managers. But before we continue, we should clean up our code a bit. Part V describes what we can improve."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partV.html#2-6","title":"Part V - DRY","content":"You may have noticed that we use the static classes in src\/Domain\/Api as a central place to define constants. At least we did that for messages (Command, Event, Query) and aggregate names. We did not touch src\/Domain\/Api\/Payload and src\/Domain\/Api\/Schema yet.The idea behind those two classes is to group some common constants and static methods so that we don't have to repeat them over and over again. This makes it much easier to refactor the codebase later."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partV.html#2-6-1","title":"Payload","content":"In src\/Domain\/Api\/Payload we simply define a constant for each possible message payload key. We've used two keys so far: buildingId and name so we should add them ...&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; class Payload { \/\/Predefined keys for query payloads, see MyService\\Domain\\Api\\Schema::queryPagination() for further information const SKIP = 'skip'; const LIMIT = 'limit'; const BUILDING_ID = 'buildingId'; const NAME = 'name'; } ... and replace plain strings with the constants in our codebase:src\/Domain\/Api\/Aggregate&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use MyService\\Domain\\Model\\Building; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; class Aggregate implements EventEngineDescription { const BUILDING = 'Building'; \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;process(Command::ADD_BUILDING) -&gt;withNew(self::BUILDING) -&gt;identifiedBy(Payload::BUILDING_ID) \/\/&lt;-- AggregateId payload property -&gt;handle([Building::class, 'add']) -&gt;recordThat(Event::BUILDING_ADDED) -&gt;apply([Building::class, 'whenBuildingAdded']); \/* ... *\/ } } src\/Domain\/Api\/Command&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use EventEngine\\JsonSchema\\JsonSchema; class Command implements EventEngineDescription { const ADD_BUILDING = 'AddBuilding'; \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;registerCommand( Command::ADD_BUILDING, JsonSchema::object( [ Payload::BUILDING_ID =&gt; JsonSchema::uuid(), Payload::NAME =&gt; JsonSchema::string(['minLength' =&gt; 2]) ] ) ); } } src\/Domain\/Api\/Event&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use EventEngine\\JsonSchema\\JsonSchema; class Event implements EventEngineDescription { const BUILDING_ADDED = 'BuildingAdded'; \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;registerEvent( self::BUILDING_ADDED, JsonSchema::object( [ Payload::BUILDING_ID =&gt; JsonSchema::uuid(), Payload::NAME =&gt; JsonSchema::string(['minLength' =&gt; 2]) ] ) ); } } src\/Domain\/Api\/Query&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use EventEngine\\JsonSchema\\JsonSchema; use MyService\\Domain\\Resolver\\BuildingResolver; class Query implements EventEngineDescription { const BUILDING = 'Building'; const BUILDINGS = 'Buildings'; \/\/&lt;-- New query, note the plural public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;registerQuery(self::BUILDING, JsonSchema::object([ Payload::BUILDING_ID =&gt; JsonSchema::uuid(), ])) -&gt;resolveWith(BuildingResolver::class) -&gt;setReturnType(JsonSchema::typeRef(Type::BUILDING)); \/\/New query $eventEngine-&gt;registerQuery( self::BUILDINGS, JsonSchema::object( [], \/\/No required arguments for this query \/\/Optional argument name, is a nullable string [Payload::NAME =&gt; JsonSchema::nullOr(JsonSchema::string()-&gt;withMinLength(1))] ) ) \/\/Resolve query with same finder ... -&gt;resolveWith(BuildingResolver::class) \/\/... but return an array of Building type -&gt;setReturnType(JsonSchema::array( JsonSchema::typeRef(Aggregate::BUILDING) )); } } src\/Domain\/Resolver\/BuildingResolver&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Resolver; use EventEngine\\DocumentStore\\DocumentStore; use EventEngine\\DocumentStore\\Filter\\AnyFilter; use EventEngine\\DocumentStore\\Filter\\LikeFilter; use EventEngine\\Messaging\\Message; use EventEngine\\Querying\\Resolver; use MyService\\Domain\\Api\\Payload; use MyService\\Domain\\Api\\Query; final class BuildingResolver implements Resolver { public const COLLECTION = 'buildings'; public const STATE = 'state'; public const STATE_DOT = 'state.'; \/** * @var DocumentStore *\/ private $documentStore; public function __construct(DocumentStore $documentStore) { $this-&gt;documentStore = $documentStore; } \/** * @param Message $query * @return array *\/ public function resolve(Message $query): array { switch ($query-&gt;messageName()) { case Query::BUILDING: return $this-&gt;resolveBuilding($query-&gt;get(Payload::BUILDING_ID)); case Query::BUILDINGS: return $this-&gt;resolveBuildings($query-&gt;getOrDefault(Payload::NAME, null)); } } private function resolveBuilding(string $buildingId): array { $buildingDoc = $this-&gt;documentStore-&gt;getDoc(self::COLLECTION, $buildingId); if(!$buildingDoc) { throw new \\RuntimeException(\"Building not found\", 404); } return $buildingDoc[self::STATE]; } private function resolveBuildings(string $nameFilter = null): array { $filter = $nameFilter? new LikeFilter(self::STATE_DOT . Payload::NAME, \"%$nameFilter%\") : new AnyFilter(); $cursor = $this-&gt;documentStore-&gt;findDocs(self::COLLECTION, $filter); $buildings = []; foreach ($cursor as $doc) { $buildings[] = $doc[self::STATE]; } return $buildings; } } scripts\/create_collections.php&lt;?php declare(strict_types=1); require_once 'vendor\/autoload.php'; $container = require 'config\/container.php'; \/** @var \\EventEngine\\DocumentStore\\DocumentStore $documentStore *\/ $documentStore = $container-&gt;get(EventEngine\\DocumentStore\\DocumentStore::class); if(!$documentStore-&gt;hasCollection(\\MyService\\Domain\\Resolver\\BuildingResolver::COLLECTION)) { echo \"Creating collection buildings.\\n\"; $documentStore-&gt;addCollection( \\MyService\\Domain\\Resolver\\BuildingResolver::COLLECTION ); } echo \"done.\\n\"; The buildings collection name is now also defined as a constant. Because BuildingResolver is responsible for building related queries, it owns the collection constant. That's not a hard rule but in our case it's a good documentation, especially in the aggregate description. All information about buildings is in one place now:&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use MyService\\Domain\\Model\\Building; use MyService\\Domain\\Resolver\\BuildingResolver; class Aggregate implements EventEngineDescription { const BUILDING = 'Building'; \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;process(Command::ADD_BUILDING) -&gt;withNew(self::BUILDING) -&gt;identifiedBy(Payload::BUILDING_ID) -&gt;handle([Building::class, 'add']) -&gt;recordThat(Event::BUILDING_ADDED) -&gt;apply([Building::class, 'whenBuildingAdded']) -&gt;storeStateIn(BuildingResolver::COLLECTION); \/\/Use buildings collection for aggregate state } } "},{"id":"https:\/\/event-engine.github.io\/tutorial\/partV.html#2-6-2","title":"Schema","content":"Schema definitions are another area where DRY (Don't Repeat Yourself) makes a lot of sense. A good practice is to define a schema for each payload key and reuse it when registering messages. Type references (JsonSchema::typeRef) should also be wrapped by a schema method. Open src\/Domain\/Api\/Schema and add the static methods:&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\JsonSchema\\JsonSchema; use EventEngine\\JsonSchema\\Type\\StringType; use EventEngine\\JsonSchema\\Type\\TypeRef; use EventEngine\\JsonSchema\\Type\\UuidType; class Schema { public static function buildingId(): UuidType { return JsonSchema::uuid(); } public static function buildingName(): StringType { return JsonSchema::string()-&gt;withMinLength(1); } public static function buildingNameFilter(): StringType { return JsonSchema::string()-&gt;withMinLength(1); } public static function building(): TypeRef { return JsonSchema::typeRef(Type::BUILDING); } public static function buildingList(): ArrayType { return JsonSchema::array(self::building()); } \/* ... *\/ } Doing this creates one place that gives us an overview of all domain specific schema definitions and we can simply change them if requirements change.Note: Even if we only use \"name\" in message payload for building names we use a more precise method name in Schema. A message defines the context so we can use a shorter payload key but the schema should be explicit.You can now replace all schema definitions.src\/Domain\/Api\/Command&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use EventEngine\\JsonSchema\\JsonSchema; class Command implements EventEngineDescription { const ADD_BUILDING = 'AddBuilding'; \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;registerCommand( Command::ADD_BUILDING, JsonSchema::object( [ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::buildingName(), ] ) ); } } src\/Domain\/Api\/Event&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use EventEngine\\JsonSchema\\JsonSchema; class Event implements EventEngineDescription { const BUILDING_ADDED = 'BuildingAdded'; \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;registerEvent( self::BUILDING_ADDED, JsonSchema::object( [ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::buildingName(), ] ) ); } } src\/Domain\/Api\/Query&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use EventEngine\\JsonSchema\\JsonSchema; use MyService\\Domain\\Resolver\\BuildingResolver; class Query implements EventEngineDescription { const BUILDING = 'Building'; const BUILDINGS = 'Buildings'; public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;registerQuery(self::BUILDING, JsonSchema::object([ Payload::BUILDING_ID =&gt; Schema::buildingId(), ])) -&gt;resolveWith(BuildingResolver::class) -&gt;setReturnType(Schema::building()); $eventEngine-&gt;registerQuery( self::BUILDINGS, JsonSchema::object( [], [Payload::NAME =&gt; JsonSchema::nullOr(Schema::buildingNameFilter())] ) ) -&gt;resolveWith(BuildingResolver::class) -&gt;setReturnType(Schema::buildingList()); } } We're done with the refactoring and ready to add the next use case. Head over to part VI."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partVI.html#2-7","title":"Part VI - Check in User","content":"The second use case of our Building Management system checks users into buildings. Users are identified by their name."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partVI.html#2-7-1","title":"Command","content":"Let's add a new command for the use case in src\/Domain\/Api\/Command:&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use EventEngine\\JsonSchema\\JsonSchema; class Command implements EventEngineDescription { const ADD_BUILDING = 'AddBuilding'; const CHECK_IN_USER = 'CheckInUser'; \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { \/* ... *\/ $eventEngine-&gt;registerCommand( Command::CHECK_IN_USER, JsonSchema::object([ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::username(), ]) ); } } We can reuse Payload::NAME but assign a different schema so that we can change schema for a building name without influencing the schema of user name:&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\JsonSchema\\JsonSchema; use EventEngine\\JsonSchema\\Type\\ArrayType; use EventEngine\\JsonSchema\\Type\\StringType; use EventEngine\\JsonSchema\\Type\\TypeRef; use EventEngine\\JsonSchema\\Type\\UuidType; class Schema { \/* ... *\/ public static function username(): StringType { return JsonSchema::string()-&gt;withMinLength(1); } } "},{"id":"https:\/\/event-engine.github.io\/tutorial\/partVI.html#2-7-2","title":"Event","content":"&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use EventEngine\\JsonSchema\\JsonSchema; class Event implements EventEngineDescription { const BUILDING_ADDED = 'BuildingAdded'; const USER_CHECKED_IN = 'UserCheckedIn'; \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;registerEvent( self::BUILDING_ADDED, JsonSchema::object( [ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::buildingName(), ] ) ); $eventEngine-&gt;registerEvent( self::USER_CHECKED_IN, JsonSchema::object([ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::username(), ]) ); } } "},{"id":"https:\/\/event-engine.github.io\/tutorial\/partVI.html#2-7-3","title":"Aggregate","content":"Did you notice that we are getting faster? Once, you're used to Event Engine's API you can develop at the speed of light ;).A user can only check into an existing building. builidngId is part of the command payload and should reference a building in our system. For the command handling aggregate function this means that we also have state of the aggregate and Event Engine will pass that state as the first argument to the command handling function as well as to the event apply function:&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model; use MyService\\Domain\\Api\\Event; use MyService\\Domain\\Api\\Payload; use EventEngine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { yield [Event::BUILDING_ADDED, $addBuilding-&gt;payload()]; } public static function whenBuildingAdded(Message $buildingAdded): Building\\State { return Building\\State::fromArray($buildingAdded-&gt;payload()); } public static function checkInUser(Building\\State $state, Message $checkInUser): \\Generator { yield [Event::USER_CHECKED_IN, $checkInUser-&gt;payload()]; } public static function whenUserCheckedIn(Building\\State $state, Message $userCheckedIn): Building\\State { return $state-&gt;withCheckedInUser($userCheckedIn-&gt;get(Payload::NAME)); } } Building::checkInUser() is still a dumb function (we will change that in a minute) but Building::whenUserCheckedIn() contains an interesting detail. Building\\State is an immutable record. But we can add with* methods to it to modify state. You may know these with* methods from the PSR-7 standard. It is a common practice to prefix state changing methods of immutable objects with with. Those methods should return a new instance with the modified state rather than changing its own state. Here is the implementation of Building\\State::withCheckedInUser(string $username): Building\\State:&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model\\Building; use MyService\\Domain\\Api\\Schema; use EventEngine\\Data\\ImmutableRecord; use EventEngine\\Data\\ImmutableRecordLogic; use EventEngine\\JsonSchema\\JsonSchema; use EventEngine\\JsonSchema\\Type; final class State implements ImmutableRecord { use ImmutableRecordLogic; public const BUILDING_ID = 'buildingId'; public const NAME = 'name'; \/** * @var string *\/ private $buildingId; \/** * @var string *\/ private $name; \/** * @var array *\/ private $users = []; private static function arrayPropItemTypeMap(): array { return ['users' =&gt; JsonSchema::TYPE_STRING]; } \/** * @return string *\/ public function buildingId(): string { return $this-&gt;buildingId; } \/** * @return string *\/ public function name(): string { return $this-&gt;name; } \/** * @return array *\/ public function users(): array { return array_keys($this-&gt;users); } public function withCheckedInUser(string $username): State { $copy = clone $this; $copy-&gt;users[$username] = null; return $copy; } public function isUserCheckedIn(string $username): bool { return array_key_exists($username, $this-&gt;users); } } We can make a copy of the record and modify that. The original record is not modified, and we return the copy to satisfy the immutable record contract.Besides withCheckedInUser we've added a new property, users, and a getter for it. We also overrode the private static method arrayPropItemTypeMap of ImmutableRecordLogic to define a type hint for the items in the users array property. Unfortunately, we can only type hint for array in PHP, and it is not possible to use return type hints like string[]. Hopefully this will change in a future version of PHP, but, for now, we have to live with the workaround and give ImmutableRecordLogic a hint that array items of the users property are of type string.Note: ImmutableRecordLogic derives type information by inspecting return types of getter methods named like their corresponding private properties.Internally, user names are used as the array index so the same user cannot appear twice in the list. With Building\\State::isUserCheckedIn(string $username): bool we can look up if the given user is currently in the building. Building\\State::users() on the other hand returns a list of user names. Internal state is used for fast look ups and external schema is used for the read model. More on that in a minute."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partVI.html#2-7-4","title":"Command Processing","content":"&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use MyService\\Domain\\Model\\Building; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; class Aggregate implements EventEngineDescription { const BUILDING = 'Building'; \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { \/* ... *\/ $eventEngine-&gt;process(Command::CHECK_IN_USER) -&gt;withExisting(self::BUILDING) -&gt;handle([Building::class, 'checkInUser']) -&gt;recordThat(Event::USER_CHECKED_IN) -&gt;apply([Building::class, 'whenUserCheckedIn']); } } Pretty much the same command processing description but with command, event and function names based on the new use case. An important difference is that we use -&gt;withExisting instead of -&gt;withNew. As already stated this tells Event Engine to look up an existing Building using the buildingId from the CheckInUser command.The following command should check in John into the Acme Headquarters.{ \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"John\" } Looks good! And what does the response of the Buildings query look now?{ \"name\": \"Acme\" } Response[ { \"name\": \"Acme Headquarters\", \"users\": [ \"John\" ], \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\" } ] Great! We get back the list of users checked into the building."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partVI.html#2-7-5","title":"Protect Invariants","content":"One of the main tasks of an aggregate is to protect invariants. A user cannot check in twice. The Building aggregate should enforce the business rule:&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model; use MyService\\Domain\\Api\\Event; use MyService\\Domain\\Api\\Payload; use EventEngine\\Messaging\\Message; final class Building { public static function add(Message $addBuilding): \\Generator { yield [Event::BUILDING_ADDED, $addBuilding-&gt;payload()]; } public static function whenBuildingAdded(Message $buildingAdded): Building\\State { return Building\\State::fromArray($buildingAdded-&gt;payload()); } public static function checkInUser(Building\\State $state, Message $checkInUser): \\Generator { if($state-&gt;isUserCheckedIn($checkInUser-&gt;get(Payload::NAME))) { throw new \\DomainException(sprintf( \"User %s is already in the building\", $checkInUser-&gt;get(Payload::NAME) )); } yield [Event::USER_CHECKED_IN, $checkInUser-&gt;payload()]; } public static function whenUserCheckedIn(Building\\State $state, Message $userCheckedIn): Building\\State { return $state-&gt;withCheckedInUser($userCheckedIn-&gt;get(Payload::NAME)); } } The command handling function can make use of $state passed to it as this will always be the current state of the aggregate. If the given user is already checked in we throw an exception to stop command processing.Let's try it:{ \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"John\" } Response:{ \"exception\": { \"message\": \"User John is already in the building\", \"details\": \"...\" } } Throwing an exception is the simplest way to protect invariants. However, with event sourcing we have a different (and in most cases) better option. This will be covered in the next part."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partVII.html#2-8","title":"Part VII - The Unhappy Path","content":"Developers tend to work out the happy path of a feature only and throw exceptions in every unknown situation. This behaviour is often caused by bad project management. Developers get domain knowledge from Jira tickets written by a product owner (Jira is used here as a synonym for any ticket system) instead of talking to domain experts face-to-face. Most tickets don't include unhappy paths until they happen and find their way back to the developer as a bug ticket.Is this really the best way to deal with unexpected scenarios? Wouldn't it be better to prepare for the unhappy paths as well? Sure, it takes more time upfront but saves a lot of time later when the application runs in production and can deal with failure scenarios in a sane way.Our Building aggregate does a bad job with regards to failure handling. Imagine a user is already in a building and tries to check in again. What does that mean in the real world? First of all it is not possible to be in and out of a building at the same time. So either a hacker has stolen the identity or system state is broken for whatever reason. Deciding if entrance to the building is blocked or not should be made by the business. And regardless of the decision it is always interesting to have an event in the event stream about the double check in. This makes monitoring much simpler than scanning error logs.We've talked to the domain experts and they want us to notify security in case of a DoubleCheckIn. With Event Engine this is as simple as throwing an exception ;)The screenshot is taken from InspectIO - a domain modelling tool for (remote) teams that supports living documentation. Event Engine users can request free access in the chat.We need an event to record a DoubleCheckIn:&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use EventEngine\\JsonSchema\\JsonSchema; class Event implements EventEngineDescription { const BUILDING_ADDED = 'BuildingAdded'; const USER_CHECKED_IN = 'UserCheckedIn'; const DOUBLE_CHECK_IN_DETECTED = 'DoubleCheckInDetected'; \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { \/* ... *\/ $eventEngine-&gt;registerEvent( self::DOUBLE_CHECK_IN_DETECTED, JsonSchema::object([ Payload::BUILDING_ID =&gt; Schema::buildingId(), Payload::NAME =&gt; Schema::username(), ]) ); } } Now that we have the event we can replace the exception and yield a DoubleCheckInDetected event:&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model; use MyService\\Domain\\Api\\Event; use MyService\\Domain\\Api\\Payload; use EventEngine\\Messaging\\Message; final class Building { \/* ... *\/ public static function checkInUser(Building\\State $state, Message $checkInUser): \\Generator { if($state-&gt;isUserCheckedIn($checkInUser-&gt;get(Payload::NAME))) { yield [Event::DOUBLE_CHECK_IN_DETECTED, $checkInUser-&gt;payload()]; return; \/\/&lt;-- Note: we need to return, otherwise UserCheckedIn would be yielded, too } yield [Event::USER_CHECKED_IN, $checkInUser-&gt;payload()]; } \/* ... *\/ public static function whenDoubleCheckInDetected(Building\\State $state, Message $event): Building\\State { \/\/No state change required, simply return current state return $state; } } Event Engine requires an event apply function for each event type, even if state does not change and it needs to know that Building::checkInUser() yields DoubleCheckInDetected in some situations:&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use MyService\\Domain\\Model\\Building; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; class Aggregate implements EventEngineDescription { const BUILDING = 'Building'; \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { \/* ... *\/ $eventEngine-&gt;process(Command::CHECK_IN_USER) -&gt;withExisting(self::BUILDING) -&gt;handle([Building::class, 'checkInUser']) -&gt;recordThat(Event::USER_CHECKED_IN) -&gt;apply([Building::class, 'whenUserCheckedIn']) -&gt;orRecordThat(Event::DOUBLE_CHECK_IN_DETECTED) -&gt;apply([Building::class, 'whenDoubleCheckInDetected']); } } Try to check John in again:{ \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"John\" } Instead of an error we get a 202 command accepted response.But when we look at the aggregate details page in Cockpit, we see a DoubleCheckInDetected event."},{"id":"https:\/\/event-engine.github.io\/tutorial\/partVII.html#2-8-1","title":"Process Manager","content":"To complete the user story we have to notify security. The security team uses a dedicated monitoring application that can receive arbitrary notification messages. To communicate with that external system we can use a so-called process manager or policy. Maybe you're more familiar with the term event listener but be careful to not mix it with event listeners known from web frameworks like Symfony or Laravel. Listeners in Event Engine react to domain events and trigger follow up commands for actions, like sending emails or interacting with external systems.We can simulate the security monitoring system with a small JS app shipped with the php-engine-skeleton. Open http:\/\/localhost:8080\/ws.html in your browser.Note: If the app shows a connection error then try to log into the rabbit mgmt console first: https:\/\/localhost:8081. Accept the self-signed certificate and login with usr: prooph pwd: prooph. If you're logged in switch back to http:\/\/localhost:8080\/ws.html and reload the page.If the app says Status: Connected to websocket: ui-queue it is ready to receive messages from Event Engine.In src\/System\/SystemServices you can find a factory method for MyService\\System\\UiExchange. It's a default domain event listener shipped with the skeleton that can be used to push events on a RabbitMQ ui-exchange. The exchange is preconfigured (you can see that in the rabbit mgmt UI) and the JS app connects to a corresponding ui-queue.In src\/Domain\/Api\/Listener we can put the pieces together:&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use MyService\\System\\UiExchange; class Listener implements EventEngineDescription { public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;on(Event::DOUBLE_CHECK_IN_DETECTED, UiExchange::class); } } Whenever a DoubleCheckInDetected event is recorded and written to the stream Event Engine invokes the UiExchange listener that takes the event and pushes it to rabbit.Try to check John in again, while keeping an eye on the monitoring app http:\/\/localhost:8080\/ws.html.{ \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\", \"name\": \"John\" } ]"},{"id":"https:\/\/event-engine.github.io\/tutorial\/partVII.html#2-8-2","title":"The End","content":"Congratulations! You've mastered the Event Engine tutorial. There are two bonus parts available to learn more about custom projections and testing with Event Engine. And another two bonus parts introduce Event Engine Flavours. Choose your own Flavour and maximize personal developer experience with Event Engine.The Event Engine API docs contain a lot more details.The prooph software team offers commercial project support and workshops for Event Engine and the prooph components. Our workshops include Event Storming sessions and guidance on how to turn the results into working prototypes using Event Engine. We can also show and discuss framework integrations. Event Engine can easily be integrated with Symfony, Laravel and other PHP web frameworks. The skeleton is based on Laminas Strategility so you can handle http related tasks, like authentication, using PSR-15 middleware. But again, other web frameworks play nicely with Event Engine!If you are interested please get in touch!"},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusI.html#2-9","title":"Bonus I - Custom Projection","content":"The product owner comes along with a new feature request. They need a way to look up the building a user is checked into, if any."},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusI.html#2-9-1","title":"Exercise","content":"Before we implement that feature you're asked to implement the check out user use case. Add a command CheckOutUser and an event UserCheckedOut. Let the Building aggregate and Building\\State handle the command and make sure that DoubleCheckOutDetected can also be monitored using the monitoring UI.The screenshot is taken from InspectIO - a domain modelling tool for (remote) teams that supports living documentation. Event Engine users can request free access in the chat.Does it work? Great!"},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusI.html#2-9-2","title":"Implement a Projector","content":"What we need is a list of usernames and a reference to the building they are checked into. A custom projection can keep track of UserCheckedIn and UserCheckedOut events to keep the list up-to-date.First check in John again (in case he is checked out because you've successfully tested the CheckOutUser command)!To do that we need our own EventEngine\\Projecting\\Projector implementation. Create a new class called UserBuildingList in src\/Domain\/Projector with the following content:&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Projector; use EventEngine\\DocumentStore\\DocumentStore; use MyService\\Domain\\Api\\Event; use MyService\\Domain\\Api\\Payload; use EventEngine\\Messaging\\Message; use EventEngine\\Projecting\\AggregateProjector; use EventEngine\\Projecting\\Projector; final class UserBuildingList implements Projector { \/** * @var DocumentStore *\/ private $documentStore; public function __construct(DocumentStore $documentStore) { $this-&gt;documentStore = $documentStore; } public function prepareForRun(string $projectionVersion, string $projectionName): void { if(!$this-&gt;documentStore-&gt;hasCollection(self::generateCollectionName($projectionVersion, $projectionName))) { $this-&gt;documentStore-&gt;addCollection( self::generateCollectionName($projectionVersion, $projectionName) \/* Note: we could pass index configuration as a second argument, see docs for details *\/ ); } } public function handle(string $projectionVersion, string $projectionName, Message $event): void { $collection = self::generateCollectionName($projectionVersion, $projectionName); switch ($event-&gt;messageName()) { case Event::USER_CHECKED_IN: $this-&gt;documentStore-&gt;addDoc( $collection, $event-&gt;get(Payload::NAME), \/\/Use username as doc id [Payload::BUILDING_ID =&gt; $event-&gt;get(Payload::BUILDING_ID)] ); break; case Event::USER_CHECKED_OUT: $this-&gt;documentStore-&gt;deleteDoc($collection, $event-&gt;get(Payload::NAME)); break; default: \/\/Ignore unknown events } } public function deleteReadModel(string $appVersion, string $projectionName): void { $this-&gt;documentStore-&gt;dropCollection(self::generateCollectionName($appVersion, $projectionName)); } public static function generateCollectionName(string $projectionVersion, string $projectionName): string { \/\/We can use the naming strategy of the aggregate projector for our custom projection return AggregateProjector::generateCollectionName($projectionVersion, $projectionName); } } Make the projector available as a service in src\/Domain\/DomainServices:&lt;?php declare(strict_types=1); namespace MyService\\Domain; use MyService\\Domain\\Api\\Aggregate; use MyService\\Domain\\Api\\Command; use MyService\\Domain\\Api\\Event; use MyService\\Domain\\Api\\Listener; use MyService\\Domain\\Api\\Projection; use MyService\\Domain\\Api\\Query; use MyService\\Domain\\Api\\Type; use MyService\\Domain\\Projector\\UserBuildingList; use MyService\\Domain\\Resolver\\BuildingResolver; trait DomainServices { public function buildingResolver(): BuildingResolver { return $this-&gt;makeSingleton(BuildingResolver::class, function () { return new BuildingResolver($this-&gt;documentStore()); }); } public function userBuildingListProjector(): UserBuildingList { return $this-&gt;makeSingleton(UserBuildingList::class, function () { return new UserBuildingList($this-&gt;documentStore()); }); } public function domainDescriptions(): array { return [ Type::class, Command::class, Event::class, Query::class, Aggregate::class, Projection::class, Listener::class, ]; } } And describe the projector in src\/Domain\/Api\/Projection:&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use EventEngine\\Persistence\\Stream; use MyService\\Domain\\Projector\\UserBuildingList; class Projection implements EventEngineDescription { const USER_BUILDING_LIST = 'user_building_list'; \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;watch(Stream::ofWriteModel()) -&gt;with(self::USER_BUILDING_LIST, UserBuildingList::class) -&gt;filterEvents([ Event::USER_CHECKED_IN, Event::USER_CHECKED_OUT, ]); } } Projections are deactivated by default, because we assume that you want to start with the MultiModelStore only. Added deployment complexity and eventual consistency are the main drawbacks of projections. On the other hand, they help to keep queries simple and fast. During my developer career I've spent countless hours with analyzing, migrating and improving query logic. Developers tend to put too much logic into queries. We've learned to normalize the write model to keep it consistent and throw SQL, Elastic, MongoDB, ... query power against every problem. More often than not, this ends up in large and complex queries, hard to understand, debug and expand. Sounds familiar? Projections to the rescue!Having said this, let's activate the default write-model-projection shipped with the skeleton. It's a prooph\/event-store v7 read model projection, that watches the standard write model stream of Event Engine. To activate it, uncomment the appropriate docker container in docker-compose.yml: event_engine_projection: image: prooph\/php:7.2-cli volumes: - .:\/app depends_on: - postgres command: php \/app\/bin\/event_engine_projection.php # Needed so that projection is automatically restarted when new events are registered in event engine restart: on-failure env_file: - .\/app.env and start it with:docker-compose up -d If you look at the Postgres DB you should see a new table called user_building_list_0_1_0 with one row: id doc John {\"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\"} If the table is empty make sure that you've checked in John. If that's the case, your projection might have a problem. Check the troubleshooting section of the skeleton README.The write-model-projection is a single long-running php process. It polls the event store for new events and forwards them to Event Engine. Event Engine checks its projection descriptions and invokes all projectors interested in the forwarded events. If you add another projection and want to fill it with past data, you can run the script docker-compose run --rm php php bin\/reset.php. Projections are versioned (version can be defined as a third argument in the projection description, default is 0.1.0). This way, it's possible to generate a new read model version during deployment while the old version is still available (version is part of the table name)."},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusI.html#2-9-3","title":"Look up","content":"We can add a new query, resolver and corresponding type definitions to complete the look up feature.src\/Domain\/Api\/Type&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use MyService\\Domain\\Model\\Building; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use EventEngine\\JsonSchema\\JsonSchema; use EventEngine\\JsonSchema\\Type\\ObjectType; class Type implements EventEngineDescription { const HEALTH_CHECK = 'HealthCheck'; const USER_BUILDING = 'UserBuilding'; \/\/&lt;-- new type \/* ... *\/ private static function userBuilding(): ObjectType { return JsonSchema::object([ 'user' =&gt; Schema::username(), 'building' =&gt; Schema::building()-&gt;asNullable(), \/\/&lt;-- type ref to building, can be null ]); } \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;registerType(Aggregate::BUILDING, self::building()); $eventEngine-&gt;registerType(self::USER_BUILDING, self::userBuilding()); \/\/&lt;-- type registration } } src\/Domain\/Api\/Schema&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\JsonSchema\\JsonSchema; use EventEngine\\JsonSchema\\Type\\ArrayType; use EventEngine\\JsonSchema\\Type\\StringType; use EventEngine\\JsonSchema\\Type\\TypeRef; use EventEngine\\JsonSchema\\Type\\UuidType; class Schema { \/* ... *\/ public static function username(): StringType { return JsonSchema::string()-&gt;withMinLength(1); } public static function userBuilding(): TypeRef { return JsonSchema::typeRef(Type::USER_BUILDING); } \/* ... *\/ } src\/Domain\/Resolver\/UserBuildingResolver&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Resolver; use EventEngine\\DocumentStore\\DocumentStore; use EventEngine\\Messaging\\Message; use EventEngine\\Querying\\Resolver; use MyService\\Domain\\Api\\Payload; final class UserBuildingResolver implements Resolver { \/** * @var DocumentStore *\/ private $documentStore; \/** * @var string *\/ private $userBuildingCollection; \/** * @var string *\/ private $buildingCollection; public function __construct(DocumentStore $documentStore, string $userBuildingCol, string $buildingCol) { $this-&gt;documentStore = $documentStore; $this-&gt;userBuildingCollection = $userBuildingCol; $this-&gt;buildingCollection = $buildingCol; } public function resolve(Message $query): array { $userBuilding = $this-&gt;documentStore-&gt;getDoc( $this-&gt;userBuildingCollection, $query-&gt;get(Payload::NAME) ); if(!$userBuilding) { return [ 'user' =&gt; $query-&gt;get(Payload::NAME), 'building' =&gt; null ]; } $building = $this-&gt;documentStore-&gt;getDoc( $this-&gt;buildingCollection, $userBuilding['buildingId'] ); if(!$building) { return [ 'user' =&gt; $query-&gt;get(Payload::NAME), 'building' =&gt; null ]; } return [ 'user' =&gt; $query-&gt;get(Payload::NAME), 'building' =&gt; $building['state'], ]; } } src\/Domain\/DomainServices&lt;?php declare(strict_types=1); namespace MyService\\Domain; use MyService\\Domain\\Api\\Aggregate; use MyService\\Domain\\Api\\Command; use MyService\\Domain\\Api\\Event; use MyService\\Domain\\Api\\Listener; use MyService\\Domain\\Api\\Projection; use MyService\\Domain\\Api\\Query; use MyService\\Domain\\Api\\Type; use MyService\\Domain\\Projector\\UserBuildingList; use MyService\\Domain\\Resolver\\BuildingResolver; use MyService\\Domain\\Resolver\\UserBuildingResolver; trait DomainServices { public function buildingResolver(): BuildingResolver { return $this-&gt;makeSingleton(BuildingResolver::class, function () { return new BuildingResolver($this-&gt;documentStore()); }); } public function userBuildingResolver(): UserBuildingResolver { return $this-&gt;makeSingleton(UserBuildingResolver::class, function () { return new UserBuildingResolver( $this-&gt;documentStore(), UserBuildingList::generateCollectionName( '0.1.0', Projection::USER_BUILDING_LIST), BuildingResolver::COLLECTION ); }); } public function userBuildingListProjector(): UserBuildingList { return $this-&gt;makeSingleton(UserBuildingList::class, function () { return new UserBuildingList($this-&gt;documentStore()); }); } public function domainDescriptions(): array { return [ Type::class, Command::class, Event::class, Query::class, Aggregate::class, Projection::class, Listener::class, ]; } } src\/Domain\/Api\/Query&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use MyService\\Domain\\Resolver\\UserBuildingResolver; use ... class Query implements EventEngineDescription { \/* ... *\/ const USER_BUILDING = 'UserBuilding'; public static function describe(EventEngine $eventEngine): void { \/* ... *\/ $eventEngine-&gt;registerQuery( self::USER_BUILDING, JsonSchema::object(['name' =&gt; Schema::username()]) ) -&gt;resolveWith(UserBuildingResolver::class) -&gt;setReturnType(Schema::userBuilding()); } } Cockpit - UserBuilding query{ \"name\": \"John\" } Response{ \"user\": \"John\", \"building\": { \"name\": \"Acme Headquarters\", \"users\": [ \"John\" ], \"buildingId\": \"9ee8d8a8-3bd3-4425-acee-f6f08b8633bb\" } } An hour of work (with a bit more practice even less) and we are ready to ship the new feature! Rapid application development at its best! RAD is ok, but please don't skip testing! In the second bonus part of the tutorial we'll learn that Event Engine makes it easy to run integration tests. Don't miss it!"},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusII.html#2-10","title":"Bonus II - Unit and Integration Tests","content":"Unit testing the different parts of the application is easy. In most cases we have single purpose classes and functions that can be tested without mocking."},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusII.html#2-10-1","title":"Testing Aggregate functions","content":"Aggregate functions are pure which makes them easy to test. php-engine-skeleton provides some test helpers in tests\/BaseTestCase.php, so, if you extend from that base class, you're ready to go. Add a the folders Domain\/Model in tests and a class BuildingTest with the following content:&lt;?php declare(strict_types=1); namespace MyServiceTest\\Domain\\Model; use MyService\\Domain\\Api\\Command; use MyService\\Domain\\Api\\Event; use MyService\\Domain\\Api\\Payload; use MyServiceTest\\UnitTestCase; use Ramsey\\Uuid\\Uuid; use MyService\\Domain\\Model\\Building; final class BuildingTest extends UnitTestCase { private $buildingId; private $buildingName; private $username; protected function setUp(): void { $this-&gt;buildingId = Uuid::uuid4()-&gt;toString(); $this-&gt;buildingName = 'Acme Headquarters'; $this-&gt;username = 'John'; parent::setUp(); } \/** * @test *\/ public function it_checks_in_a_user() { \/\/Prepare expected aggregate state $state = Building\\State::fromArray([ Building\\State::BUILDING_ID =&gt; $this-&gt;buildingId, Building\\State::NAME =&gt; $this-&gt;buildingName ]); \/\/Use test helper UnitTestCase::makeCommand() to construct command $command = $this-&gt;makeCommand(Command::CHECK_IN_USER, [ Building\\State::BUILDING_ID =&gt; $this-&gt;buildingId, Building\\State::NAME =&gt; $this-&gt;username, ]); \/\/Aggregate functions yield events, we have to collect them with a test helper $events = $this-&gt;collectNewEvents( Building::checkInUser($state, $command) ); \/\/Another test helper to assert that list of recorded events contains given event $this-&gt;assertRecordedEvent(Event::USER_CHECKED_IN, [ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;username ], $events); } } You can run tests with:docker-compose run php php vendor\/bin\/phpunit -vvv "},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusII.html#2-10-2","title":"Testing Projectors","content":"Testing projectors is also easy when they use the DocumentStore API to manage projections. Event Engine ships with an InMemoryDocumentStore implementation that works great in test cases. Here is an example:tests\/Domain\/Projector\/UserBuildingListTest.php&lt;?php declare(strict_types=1); namespace MyServiceTest\\Domain\\Projector; use EventEngine\\DocumentStore\\Filter\\AnyFilter; use MyService\\Domain\\Api\\Event; use MyService\\Domain\\Api\\Payload; use MyService\\Domain\\Api\\Projection; use MyService\\Domain\\Projector\\UserBuildingList; use MyServiceTest\\UnitTestCase; final class UserBuildingListTest extends UnitTestCase { const PRJ_VERSION = '0.1.0'; const BUILDING_ID = '7c5f0c8a-54f2-4969-9596-b5bddc1e9421'; const USERNAME1 = 'John'; const USERNAME2 = 'Jane'; \/** * @var UserBuildingList *\/ private $projector; protected function setUp(): void { parent::setUp(); \/\/DocumentStore is set up in parent::setUp() $this-&gt;projector = new UserBuildingList($this-&gt;documentStore); $this-&gt;projector-&gt;prepareForRun( self::PRJ_VERSION, Projection::USER_BUILDING_LIST ); } \/** * @test *\/ public function it_manages_list_of_users_with_building_reference() { $collection = UserBuildingList::generateCollectionName( self::PRJ_VERSION, Projection::USER_BUILDING_LIST ); $johnCheckedIn = $this-&gt;makeEvent(Event::USER_CHECKED_IN, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME1 ]); $this-&gt;projector-&gt;handle( self::PRJ_VERSION, Projection::USER_BUILDING_LIST, $johnCheckedIn ); $users = iterator_to_array($this-&gt;documentStore-&gt;findDocs( $collection, new AnyFilter() )); $this-&gt;assertEquals($users, [ 'John' =&gt; ['buildingId' =&gt; self::BUILDING_ID] ]); $janeCheckedIn = $this-&gt;makeEvent(Event::USER_CHECKED_IN, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME2 ]); $this-&gt;projector-&gt;handle( self::PRJ_VERSION, Projection::USER_BUILDING_LIST, $janeCheckedIn ); $users = iterator_to_array($this-&gt;documentStore-&gt;findDocs( $collection, new AnyFilter() )); $this-&gt;assertEquals($users, [ 'John' =&gt; ['buildingId' =&gt; self::BUILDING_ID], 'Jane' =&gt; ['buildingId' =&gt; self::BUILDING_ID], ]); $johnCheckedOut = $this-&gt;makeEvent(Event::USER_CHECKED_OUT, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME1 ]); $this-&gt;projector-&gt;handle( self::PRJ_VERSION, Projection::USER_BUILDING_LIST, $johnCheckedOut ); $users = iterator_to_array($this-&gt;documentStore-&gt;findDocs( $collection, new AnyFilter() )); $this-&gt;assertEquals($users, [ 'Jane' =&gt; ['buildingId' =&gt; self::BUILDING_ID], ]); } } "},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusII.html#2-10-3","title":"Testing Resolvers","content":"Resolvers can be tested in the same manner as projectors, using the InMemoryDocumentStore with test data. I will leave implementing these tests as an exercise for you ;)"},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusII.html#2-10-4","title":"Integration Tests","content":"If you want to test the \"whole thing\" then you can extend your test class from IntegrationTestCase. It sets up Event Engine with an InMemoryEventStore and an InMemoryDocumentStore. A special PSR-11 MockContainer ensures that all other services are mocked. Let's see it in action. The annotated integration test should be self explanatory.tests\/Integration\/NotifySecurityTest.php&lt;?php declare(strict_types=1); namespace MyServiceTest\\Integration; use EventEngine\\Messaging\\Message; use MyService\\Domain\\Api\\Command; use MyService\\Domain\\Api\\Event; use MyService\\Domain\\Api\\Payload; use MyService\\System\\UiExchange; use MyServiceTest\\IntegrationTestCase; final class NotifySecurityTest extends IntegrationTestCase { const BUILDING_ID = '7c5f0c8a-54f2-4969-9596-b5bddc1e9421'; const BUILDING_NAME = 'Acme Headquarters'; const USERNAME = 'John'; private $uiExchange; protected function setUp(): void { parent::setUp(); \/\/Mock UiExchange with an anonymous class that keeps track of the last received message $this-&gt;uiExchange = new class implements UiExchange { private $lastReceivedMessage; public function __invoke(Message $event): void { $this-&gt;lastReceivedMessage = $event; } public function lastReceivedMessage(): Message { return $this-&gt;lastReceivedMessage; } }; \/\/ Mocks are passed to EE set up method \/\/ The IntegrationTestCase loads all EE descriptions \/\/ and uses the configured Flavour (PrototypingFlavour in our case) \/\/ to set up Event Engine $this-&gt;setUpEventEngine([ UiExchange::class =&gt; $this-&gt;uiExchange, ]); \/** * We can pass fixtures to the database set up: * * Stream to events map: * * [streamName =&gt; Event[]] * * Collection to documents map: * * [collectionName =&gt; [docId =&gt; doc]] *\/ $this-&gt;setUpDatabase([ \/\/ We use the default write model stream in the buildings app \/\/ and add a history for the test building \/\/ aggregate state is derived from history automatically during set up $this-&gt;eventEngine-&gt;writeModelStreamName() =&gt; [ $this-&gt;makeEvent(Event::BUILDING_ADDED, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::BUILDING_NAME ]), $this-&gt;makeEvent(Event::USER_CHECKED_IN, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME ]), ] ]); } \/** * @test *\/ public function it_detects_double_check_in_and_notifies_security() { \/\/Try to check in John twice $checkInJohn = $this-&gt;makeCommand(Command::CHECK_IN_USER, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME ]); $this-&gt;eventEngine-&gt;dispatch($checkInJohn); \/\/The IntegrationTestCase sets up an in-memory queue (accessible by $this-&gt;eventQueue) \/\/You can inspect published events or simply process the queue \/\/so that event listeners get invoked like our mocked UiExchange listener $this-&gt;processEventQueueWhileNotEmpty(); \/\/Now $this-&gt;lastPublishedEvent should point to the event received by UiExchange mock $this-&gt;assertNotNull($this-&gt;uiExchange-&gt;lastReceivedMessage()); $this-&gt;assertEquals(Event::DOUBLE_CHECK_IN_DETECTED, $this-&gt;uiExchange-&gt;lastReceivedMessage()-&gt;messageName()); $this-&gt;assertEquals([ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME ], $this-&gt;uiExchange-&gt;lastReceivedMessage()-&gt;payload()); } } With a solid test suite in place, we can safely start refactoring our code towards a rich domain model. The next bonus part introduces stricter types for state and messages."},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIII.html#2-11","title":"Bonus III - Functional Flavour","content":"Event Engine has a nice feature called Flavours. A Flavour lets you customize the way Event Engine interacts with your code. Throughout the tutorial we worked with the PrototypingFlavour, which is the default.As the name suggests, the PrototypingFlavour is optimized for rapid development. For example instead of defining classes for each type of message, Event Engine passes its default Message implementation to aggregate functions, process managers, resolvers and projectors. You don't need to care about serialization and mapping.If you want to try out new ideas, PrototypingFlavour is your best friend. Following Domain-Driven Design best practices Continuous Discovery and Agile Development are key drivers for successful projects. This requires experimentation and with the PrototypingFlavour it's easier than ever."},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIII.html#2-11-1","title":"Harden The Domain Model","content":"Experimentation is great, but at some point you'll be satisfied with the domain model and want to turn it into a clean and robust implementation. That's very important for long-lived applications. Fortunately, Event Engine offers two additional Flavours. One is called the FunctionalFlavour and the other one OopFlavour. Finally, you can implement your own EventEngine\\Runtime\\Flavour to turn Event Engine into your very own CQRS \/ ES framework.First let's look at the FunctionalFlavour. It's similar to what we did so far, except that explicit message types are used instead of generic Event Engine messages."},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIII.html#2-11-2","title":"Functional Port","content":"The FunctionalFlavour requires an implementation of EventEngine\\Runtime\\Functional\\Port. Here you have to define custom mapping and serialization logic for message types. Create a new class MyServiceMessagePort in src\/System\/Flavour:&lt;?php declare(strict_types=1); namespace MyService\\System\\Flavour; use EventEngine\\Messaging\\CommandDispatchResult; use EventEngine\\Messaging\\Message; use EventEngine\\Messaging\\MessageBag; use EventEngine\\Runtime\\Functional\\Port; final class MyServiceMessagePort implements Port { \/** * @param Message $message * @return mixed The custom message *\/ public function deserialize(Message $message) { \/\/ TODO: Implement deserialize() method. } \/** * @param mixed $customMessage * @return array *\/ public function serializePayload($customMessage): array { \/\/ TODO: Implement serializePayload() method. } \/** * @param mixed $customCommand * @return MessageBag *\/ public function decorateCommand($customCommand): MessageBag { \/\/ TODO: Implement decorateCommand() method. } \/** * @param mixed $customEvent * @return MessageBag *\/ public function decorateEvent($customEvent): MessageBag { \/\/ TODO: Implement decorateEvent() method. } \/** * @param string $aggregateIdPayloadKey * @param mixed $command * @return string *\/ public function getAggregateIdFromCommand(string $aggregateIdPayloadKey, $command): string { \/\/ TODO: Implement getAggregateIdFromCommand() method. } \/** * @param mixed $customCommand * @param mixed $preProcessor Custom preprocessor * @return mixed|CommandDispatchResult Custom message or CommandDispatchResult *\/ public function callCommandPreProcessor($customCommand, $preProcessor) { \/\/ TODO: Implement callCommandPreProcessor() method. } \/** * Commands returned by the controller are dispatched automatically * * @param mixed $customCommand * @param mixed $controller * @return mixed[]|null|CommandDispatchResult Array of custom commands or null|CommandDispatchResult to indicate that no further action is required *\/ public function callCommandController($customCommand, $controller) { \/\/ TODO: Implement callCommandController() method. } \/** * @param mixed $customCommand * @param mixed $contextProvider * @return mixed *\/ public function callContextProvider($customCommand, $contextProvider) { \/\/ TODO: Implement callContextProvider() method. } public function callResolver($customQuery, $resolver) { \/\/ TODO: Implement callResolver() method. } } We'll implement the interface step by step and define a mapping strategy along the way."},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIII.html#2-11-3","title":"Deserialize","content":"First method is deserialize:\/** * @param Message $message * @return mixed The custom message *\/ public function deserialize(Message $message) { \/\/ TODO: Implement deserialize() method. } An Event Engine message is passed as argument and the method should return a custom message. The first important decision is required:Which serialization technique do we want to use? Some people prefer handcrafted serialization, while others prefer conventions or serializers. The good news is, every technique can be used! It just needs to be implemented in the Port.To keep the tutorial simple, we're going to use the tools shipped with Event Engine. That said, our messages become ImmutableRecords and use the built-in serialization technique provided by ImmutableRecordLogic.The fact that messages are still coupled with the framework is not important here. It's our decision as developers to do it, but nothing required by Event Engine. We could also write our own serialization mechanism or use a third-party tool like FPP.Let's create some types and messages first:src\/Domain\/Model\/Building\/BuildingId.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model\\Building; use Ramsey\\Uuid\\Uuid; use Ramsey\\Uuid\\UuidInterface; final class BuildingId { private $buildingId; public static function generate(): self { return new self(Uuid::uuid4()); } public static function fromString(string $buildingId): self { return new self(Uuid::fromString($buildingId)); } private function __construct(UuidInterface $buildingId) { $this-&gt;buildingId = $buildingId; } public function toString(): string { return $this-&gt;buildingId-&gt;toString(); } public function equals($other): bool { if (!$other instanceof self) { return false; } return $this-&gt;buildingId-&gt;equals($other-&gt;buildingId); } public function __toString(): string { return $this-&gt;buildingId-&gt;toString(); } } src\/Domain\/Model\/Building\/BuildingName.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model\\Building; final class BuildingName { private $name; public static function fromString(string $name): self { return new self($name); } private function __construct(string $name) { $this-&gt;name = $name; } public function toString(): string { return $this-&gt;name; } public function equals($other): bool { if(!$other instanceof self) { return false; } return $this-&gt;name === $other-&gt;name; } public function __toString(): string { return $this-&gt;name; } } src\/Domain\/Model\/Building\/Username.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model\\Building; final class Username { private $name; public static function fromString(string $name): self { return new self($name); } private function __construct(string $name) { $this-&gt;name = $name; } public function toString(): string { return $this-&gt;name; } public function equals($other): bool { if(!$other instanceof self) { return false; } return $this-&gt;name === $other-&gt;name; } public function __toString(): string { return $this-&gt;name; } } src\/Domain\/Model\/Building\/Command\/AddBuilding.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model\\Building\\Command; use MyService\\Domain\\Model\\Building\\BuildingId; use MyService\\Domain\\Model\\Building\\BuildingName; use EventEngine\\Data\\ImmutableRecord; use EventEngine\\Data\\ImmutableRecordLogic; final class AddBuilding implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var BuildingId *\/ private $buildingId; \/** * @var BuildingName *\/ private $name; \/** * @return BuildingId *\/ public function buildingId(): BuildingId { return $this-&gt;buildingId; } \/** * @return BuildingName *\/ public function name(): BuildingName { return $this-&gt;name; } } src\/Domain\/Model\/Building\/Command\/CheckInUser.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model\\Building\\Command; use MyService\\Domain\\Model\\Building\\BuildingId; use MyService\\Domain\\Model\\Building\\Username; use EventEngine\\Data\\ImmutableRecord; use EventEngine\\Data\\ImmutableRecordLogic; final class CheckInUser implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var BuildingId *\/ private $buildingId; \/** * @var Username *\/ private $name; \/** * @return BuildingId *\/ public function buildingId(): BuildingId { return $this-&gt;buildingId; } \/** * @return Username *\/ public function name(): Username { return $this-&gt;name; } } src\/Domain\/Model\/Building\/Command\/CheckOutUser.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model\\Building\\Command; use MyService\\Domain\\Model\\Building\\BuildingId; use MyService\\Domain\\Model\\Building\\Username; use EventEngine\\Data\\ImmutableRecord; use EventEngine\\Data\\ImmutableRecordLogic; final class CheckOutUser implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var BuildingId *\/ private $buildingId; \/** * @var Username *\/ private $name; \/** * @return BuildingId *\/ public function buildingId(): BuildingId { return $this-&gt;buildingId; } \/** * @return Username *\/ public function name(): Username { return $this-&gt;name; } } Ok, much more classes now. Each property has its own value object like BuildingId, BuildingName and Username. Again, that's not a requirement but it adds type safety to the implementation and serves as documentation. Don't worry about the amount of code. Most of it can be generated using PHPStorm templates. Event Engine docs contain useful tips. Another possibility is the already mentioned library FPP.With the value objects in place we've added a class for each command and implemented them as immutable records. Now we need a factory to instantiate a command with information taken from Event Engine messages. MyService\\Domain\\Api\\Command already contains command specific information. Let's add the factory there.&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use MyService\\Domain\\Model\\Building\\Command\\AddBuilding; use MyService\\Domain\\Model\\Building\\Command\\CheckInUser; use MyService\\Domain\\Model\\Building\\Command\\CheckOutUser; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use EventEngine\\JsonSchema\\JsonSchema; class Command implements EventEngineDescription { const ADD_BUILDING = 'AddBuilding'; const CHECK_IN_USER = 'CheckInUser'; const CHECK_OUT_USER = 'CheckOutUser'; const CLASS_MAP = [ self::ADD_BUILDING =&gt; AddBuilding::class, self::CHECK_IN_USER =&gt; CheckInUser::class, self::CHECK_OUT_USER =&gt; CheckOutUser::class, ]; public static function createFromNameAndPayload(string $commandName, array $payload) { $class = self::CLASS_MAP[$commandName] ?? false; if($class === false) { throw new \\InvalidArgumentException(\"Unknown command name: $commandName\"); } \/\/Commands use ImmutableRecordLogic and therefor have a fromArray method return $class::fromArray($payload); } public static function nameOf($command): string { $name = array_search(\\get_class($command), self::CLASS_MAP); if($name === false) { throw new \\InvalidArgumentException(\"Unknown command. Cannot find a name for class: \" . \\get_class($command)); } return $name; } \/* ... *\/ } Finally, the factory can be used in the Port:src\/System\/Flavour\/MyServiceMessagePort.php\/** * @param Message $message * @return mixed The custom message *\/ public function deserialize(Message $message) { switch ($message-&gt;messageType()) { case Message::TYPE_COMMAND: return Command::createFromNameAndPayload($message-&gt;messageName(), $message-&gt;payload()); break; } } A similar implementation is required for events and queries:src\/Domain\/Model\/Building\/Event\/BuildingAdded.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model\\Building\\Event; use MyService\\Domain\\Model\\Building\\BuildingId; use MyService\\Domain\\Model\\Building\\BuildingName; use EventEngine\\Data\\ImmutableRecord; use EventEngine\\Data\\ImmutableRecordLogic; final class BuildingAdded implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var BuildingId *\/ private $buildingId; \/** * @var BuildingName *\/ private $name; \/** * @return BuildingId *\/ public function buildingId(): BuildingId { return $this-&gt;buildingId; } \/** * @return BuildingName *\/ public function name(): BuildingName { return $this-&gt;name; } } src\/Domain\/Model\/Building\/Event\/UserCheckedIn.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model\\Building\\Event; use MyService\\Domain\\Model\\Building\\BuildingId; use MyService\\Domain\\Model\\Building\\Username; use EventEngine\\Data\\ImmutableRecord; use EventEngine\\Data\\ImmutableRecordLogic; final class UserCheckedIn implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var BuildingId *\/ private $buildingId; \/** * @var Username *\/ private $name; \/** * @return BuildingId *\/ public function buildingId(): BuildingId { return $this-&gt;buildingId; } \/** * @return Username *\/ public function name(): Username { return $this-&gt;name; } } src\/Domain\/Model\/Building\/Event\/DoubleCheckInDetected.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model\\Building\\Event; use MyService\\Domain\\Model\\Building\\BuildingId; use MyService\\Domain\\Model\\Building\\Username; use EventEngine\\Data\\ImmutableRecord; use EventEngine\\Data\\ImmutableRecordLogic; final class DoubleCheckInDetected implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var BuildingId *\/ private $buildingId; \/** * @var Username *\/ private $name; \/** * @return BuildingId *\/ public function buildingId(): BuildingId { return $this-&gt;buildingId; } \/** * @return Username *\/ public function name(): Username { return $this-&gt;name; } } src\/Domain\/Model\/Building\/Event\/UserCheckedOut.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model\\Building\\Event; use MyService\\Domain\\Model\\Building\\BuildingId; use MyService\\Domain\\Model\\Building\\Username; use EventEngine\\Data\\ImmutableRecord; use EventEngine\\Data\\ImmutableRecordLogic; final class UserCheckedOut implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var BuildingId *\/ private $buildingId; \/** * @var Username *\/ private $name; \/** * @return BuildingId *\/ public function buildingId(): BuildingId { return $this-&gt;buildingId; } \/** * @return Username *\/ public function name(): Username { return $this-&gt;name; } } src\/Domain\/Model\/Building\/Event\/DoubleCheckOutDetected.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model\\Building\\Event; use MyService\\Domain\\Model\\Building\\BuildingId; use MyService\\Domain\\Model\\Building\\Username; use EventEngine\\Data\\ImmutableRecord; use EventEngine\\Data\\ImmutableRecordLogic; final class DoubleCheckOutDetected implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var BuildingId *\/ private $buildingId; \/** * @var Username *\/ private $name; \/** * @return BuildingId *\/ public function buildingId(): BuildingId { return $this-&gt;buildingId; } \/** * @return Username *\/ public function name(): Username { return $this-&gt;name; } } src\/Domain\/Api\/Event.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use MyService\\Domain\\Model\\Building\\Event\\BuildingAdded; use MyService\\Domain\\Model\\Building\\Event\\DoubleCheckInDetected; use MyService\\Domain\\Model\\Building\\Event\\DoubleCheckOutDetected; use MyService\\Domain\\Model\\Building\\Event\\UserCheckedIn; use MyService\\Domain\\Model\\Building\\Event\\UserCheckedOut; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use EventEngine\\JsonSchema\\JsonSchema; class Event implements EventEngineDescription { const BUILDING_ADDED = 'BuildingAdded'; const USER_CHECKED_IN = 'UserCheckedIn'; const USER_CHECKED_OUT = 'UserCheckedOut'; const DOUBLE_CHECK_IN_DETECTED = 'DoubleCheckInDetected'; const DOUBLE_CHECK_OUT_DETECTED = 'DoubleCheckOutDetected'; const CLASS_MAP = [ self::BUILDING_ADDED =&gt; BuildingAdded::class, self::USER_CHECKED_IN =&gt; UserCheckedIn::class, self::USER_CHECKED_OUT =&gt; UserCheckedOut::class, self::DOUBLE_CHECK_IN_DETECTED =&gt; DoubleCheckInDetected::class, self::DOUBLE_CHECK_OUT_DETECTED =&gt; DoubleCheckOutDetected::class, ]; public static function createFromNameAndPayload(string $eventName, array $payload) { $class = self::CLASS_MAP[$eventName] ?? false; if($class === false) { throw new \\InvalidArgumentException(\"Unknown event name: $eventName\"); } \/\/Events use ImmutableRecordLogic and therefor have a fromArray method return $class::fromArray($payload); } public static function nameOf($event): string { $name = array_search(\\get_class($event), self::CLASS_MAP); if($name === false) { throw new \\InvalidArgumentException(\"Unknown event. Cannot find a name for class: \" . \\get_class($event)); } return $name; } \/* ... *\/ } src\/Domain\/Resolver\/Query\/GetBuilding.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Resolver\\Query; use EventEngine\\Data\\ImmutableRecord; use EventEngine\\Data\\ImmutableRecordLogic; use MyService\\Domain\\Model\\Building\\BuildingId; final class GetBuilding implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var BuildingId *\/ private $buildingId; \/** * @return BuildingId *\/ public function buildingId(): BuildingId { return $this-&gt;buildingId; } } src\/Domain\/Resolver\/Query\/GetBuildings.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Resolver\\Query; use EventEngine\\Data\\ImmutableRecord; use EventEngine\\Data\\ImmutableRecordLogic; final class GetBuildings implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var string|null *\/ private $buildingNameFilter; \/** * @return string|null *\/ public function buildingNameFilter(): ?string { return $this-&gt;buildingNameFilter; } } src\/Domain\/Resolver\/Query\/GetUserBuildingList.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Resolver\\Query; use EventEngine\\Data\\ImmutableRecord; use EventEngine\\Data\\ImmutableRecordLogic; use MyService\\Domain\\Model\\Building\\Username; final class GetUserBuildingList implements ImmutableRecord { use ImmutableRecordLogic; \/** * @var Username *\/ private $name; \/** * @return Username *\/ public function name(): Username { return $this-&gt;name; } } src\/Domain\/Api\/Query.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use EventEngine\\JsonSchema\\JsonSchema; use EventEngine\\Messaging\\MessageBag; use MyService\\Domain\\Resolver\\BuildingResolver; use MyService\\Domain\\Resolver\\Query\\GetBuilding; use MyService\\Domain\\Resolver\\Query\\GetBuildings; use MyService\\Domain\\Resolver\\Query\\GetUserBuildingList; use MyService\\Domain\\Resolver\\UserBuildingResolver; use MyService\\System\\Api\\SystemQuery; class Query implements EventEngineDescription { \/** * Default Query, used to perform health checks using messagebox endpoint *\/ const HEALTH_CHECK = 'HealthCheck'; const BUILDING = 'Building'; const BUILDINGS = 'Buildings'; const USER_BUILDING = 'UserBuilding'; const CLASS_MAP = [ self::BUILDING =&gt; GetBuilding::class, self::BUILDINGS =&gt; GetBuildings::class, self::USER_BUILDING =&gt; GetUserBuildingList::class, ]; public static function createFromNameAndPayload(string $queryName, array $payload) { if($queryName === SystemQuery::HEALTH_CHECK) { return new MessageBag( SystemQuery::HEALTH_CHECK, MessageBag::TYPE_QUERY, [] ); } $class = self::CLASS_MAP[$queryName] ?? false; if($class === false) { throw new \\InvalidArgumentException(\"Unknown query name: $queryName\"); } \/\/Queries use ImmutableRecordLogic and therefor have a fromArray method return $class::fromArray($payload); } public static function nameOf($query): string { if($query instanceof MessageBag) { return $query-&gt;messageName(); } $name = array_search(\\get_class($query), self::CLASS_MAP); if($name === false) { throw new \\InvalidArgumentException(\"Unknown query. Cannot find a name for class: \" . \\get_class($query)); } return $name; } \/* ... *\/ } src\/System\/Flavour\/MyServiceMessagePort.php\/** * @param Message $message * @return mixed The custom message *\/ public function deserialize(Message $message) { switch ($message-&gt;messageType()) { case Message::TYPE_COMMAND: return Command::createFromNameAndPayload($message-&gt;messageName(), $message-&gt;payload()); case Message::TYPE_EVENT: return Event::createFromNameAndPayload($message-&gt;messageName(), $message-&gt;payload()); case Message::TYPE_QUERY: return Query::createFromNameAndPayload($message-&gt;messageName(), $message-&gt;payload()); } } "},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIII.html#2-11-4","title":"Serialize Payload","content":"To convert our own message types to Event Engine messages we have to implement the serializePayload method:src\/System\/Flavour\/MyServiceMessagePort.php\/** * @param mixed $customMessage * @return array *\/ public function serializePayload($customMessage): array { if(is_array($customMessage)) { return $customMessage; } if(!$customMessage instanceof ImmutableRecord) { throw new \\RuntimeException( \"Invalid message passed to \" . __METHOD__ . \". Should be an immutable record, but got \" . (\\is_object($customMessage)? \\get_class($customMessage) : \\gettype($customMessage))); } return $customMessage-&gt;toArray(); } "},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIII.html#2-11-5","title":"Decorate Command \/ Event","content":"decorateCommand and decorateEvent are special methods called for each dispatched command and all yielded events. The expected return type is EventEngine\\Messaging\\MessageBag. You can think of it as an envelop for custom messages. The MessageBag can be used to add metadata information. Event Engine adds information like aggregate id, aggregate type, aggregate version, causation id (command id) and causation name (command name) by default. If you want to add additional metadata, just pass it to the MessageBag constructor (optional argument).Decorating a custom event with a MessageBag has the advantage that a custom message can be carried through the Event Engine layer without serialization. Event Engine assumes a normal message and adds aggregate specific metadata like described above. The MessageBag is then passed back to the configured flavour to call a corresponding apply function. The flavour can access the decorated event and pass it to the function. All without serialization in between. A similar approach is used when commands are passed to preprocessors or controllers (concepts not included in the tutorial, but you can read about them in the docs).src\/System\/Flavour\/MyServiceMessagePort.php\/** * @param mixed $customCommand * @return MessageBag *\/ public function decorateCommand($customCommand): MessageBag { return new MessageBag( Command::nameOf($customCommand), MessageBag::TYPE_COMMAND, $customCommand \/\/, [] &lt;- you could add additional metadata here ); } \/** * @param mixed $customEvent * @return MessageBag *\/ public function decorateEvent($customEvent): MessageBag { return new MessageBag( Event::nameOf($customEvent), MessageBag::TYPE_EVENT, $customEvent \/\/, [] &lt;- you could add additional metadata here ); } "},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIII.html#2-11-5-1","title":"Get Aggregate ID from Command","content":"Event Engine has a built-in way to locate existing aggregates using a generic command handler and repository. But it needs the correct aggregateId. Each command should contain the same aggregateId property. Remember that this information is part of an Event Engine description:src\/Api\/Aggregate&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use MyService\\Domain\\Model\\Building; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; class Aggregate implements EventEngineDescription { const BUILDING = 'Building'; \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;process(Command::ADD_BUILDING) -&gt;withNew(self::BUILDING) -&gt;identifiedBy(Payload::BUILDING_ID) \/\/&lt;-- AggregateId payload property -&gt;handle([Building::class, 'add']) -&gt;recordThat(Event::BUILDING_ADDED) -&gt;apply([Building::class, 'whenBuildingAdded']); \/* ... *\/ } } Each Building command should have a buildingId property. Our newly created commands have buildingId() methods that we could call. An explicit implementation looks like this:\/** * @param string $aggregateIdPayloadKey * @param mixed $command * @return string *\/ public function getAggregateIdFromCommand(string $aggregateIdPayloadKey, $command): string { if($command instanceof AddBuilding || $command instanceof CheckInUser || $command instanceof CheckOutUser) { return $command-&gt;buildingId()-&gt;toString(); } throw new \\RuntimeException(\"Unknown command. Cannot get aggregate id from it. Got \" . get_class($command)); } But we would need to remember adding a new command here each time we add a new one to the system. That's annoying and interrupts the flow. Instead we can define an AggregateCommand interface that each command should implement.src\/Domain\/Model\/Base\/AggregateCommand.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model\\Base; interface AggregateCommand { public function aggregateId(): string; } src\/Domain\/Model\/Building\/Command\/AddBuilding.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model\\Building\\Command; use MyService\\Domain\\Model\\Base\\AggregateCommand; use MyService\\Domain\\Model\\Building\\BuildingId; use MyService\\Domain\\Model\\Building\\BuildingName; use EventEngine\\Data\\ImmutableRecord; use EventEngine\\Data\\ImmutableRecordLogic; final class AddBuilding implements ImmutableRecord, AggregateCommand \/\/&lt;-- Implement new interface { use ImmutableRecordLogic; \/** * @var BuildingId *\/ private $buildingId; \/** * @var BuildingName *\/ private $name; \/** * @return BuildingId *\/ public function buildingId(): BuildingId { return $this-&gt;buildingId; } \/** * @return BuildingName *\/ public function name(): BuildingName { return $this-&gt;name; } public function aggregateId(): string \/\/&lt;-- new method { return $this-&gt;buildingId-&gt;toString(); } } Do the same for CheckInUser and CheckOutUser!Done? Great! Then we can change the Port to handle any AggregateCommand:src\/System\/Flavour\/MyServiceMessagePort.php\/** * @param string $aggregateIdPayloadKey * @param mixed $command * @return string *\/ public function getAggregateIdFromCommand(string $aggregateIdPayloadKey, $command): string { if($command instanceof AggregateCommand) { return $command-&gt;aggregateId(); } throw new \\RuntimeException(\"Unknown command. Cannot get aggregate id from it. Got \" . get_class($command)); } "},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIII.html#2-11-6","title":"Call Command Preprocessor","content":"We don't know command preprocessors yet. In short: a command preprocessor can be called before a command is passed to an aggregate function. This can be useful in cases where you want to enrich a command with additional information or perform advanced validation that is not covered by Json Schema. Read more about command preprocessors in the docs.Since we don't use one in the building application, we don't really need to implement the method. Let's assume that our future command preprocessors will be simple callables:src\/System\/Flavour\/MyServiceMessagePort.php\/** * @param mixed $customCommand * @param mixed $preProcessor Custom preprocessor * @return mixed Custom message *\/ public function callCommandPreProcessor($customCommand, $preProcessor) { if(is_callable($preProcessor)) { return $preProcessor($customCommand); } throw new \\RuntimeException(\"Cannot call preprocessor. Got \" . (is_object($preProcessor)? get_class($preProcessor) : gettype($preProcessor)) ); } "},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIII.html#2-11-7","title":"Call Command Controller","content":"Instead of an aggregate a command can also be routed to a controller and the controller can decide if it forwards the command to an application service or return a list of other commands that are dispatched automatically. This is very useful for migrations or in scenarios where you want to use CQRS without event sourcing and without aggregates. In our demo application we don't use command controllers. Just like preprocessors we define them as callable.public function callCommandController($customCommand, $controller) { if(is_callable($controller)) { return $controller($customCommand); } throw new \\RuntimeException(\"Cannot call command controller. Got \" . (is_object($controller)? get_class($controller) : gettype($controller)) ); } "},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIII.html#2-11-8","title":"Call Context Provider","content":"Another concept that we don't know yet. A context provider can be used to inject context into aggregate functions. Read more about context providers in the docs (@TODO link docs).We're implementing a functional Flavour, so we expect a callable context provider passed to the port:src\/System\/Flavour\/MyServiceMessagePort.php\/** * @param mixed $customCommand * @param mixed $contextProvider * @return mixed *\/ public function callContextProvider($customCommand, $contextProvider) { if(is_callable($contextProvider)) { return $contextProvider($customCommand); } throw new \\RuntimeException(\"Cannot call context provider. Got \" . (is_object($contextProvider)? get_class($contextProvider) : gettype($contextProvider)) ); } "},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIII.html#2-11-9","title":"Call Resolver","content":"Last port method asks us to call a resolver. When using the PrototypingFlavour query resolvers should implement EventEngine\\Querying\\Resolver. But this is no longer possible because we want to pass our own queries to the resolvers and not Event Engine's generic message class. Hence, we need to define a project specific resolver interface instead along with a query marker interface:src\/Domain\/Resolver\/Query.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Resolver; interface Query { \/\/Query marker interface } src\/Domain\/Resolver\/Resolver.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Resolver; interface Resolver { \/** * @param Query $query * @return mixed array or object with toArray or JsonSerializable support *\/ public function resolve(Query $query); } Existing queries should implement the marker interface and resolvers should implement the new resolver interface:src\/Domain\/Resolver\/Query\/GetBuilding.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Resolver\\Query; use EventEngine\\Data\\ImmutableRecord; use EventEngine\\Data\\ImmutableRecordLogic; use MyService\\Domain\\Model\\Building\\BuildingId; use MyService\\Domain\\Resolver\\Query; final class GetBuilding implements ImmutableRecord, Query { use ImmutableRecordLogic; \/** * @var BuildingId *\/ private $buildingId; \/** * @return BuildingId *\/ public function buildingId(): BuildingId { return $this-&gt;buildingId; } } Add the interface to GetBuildings and GetUserBuildingList as well.src\/Domain\/Resolver\/BuildingResolver.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Resolver; use EventEngine\\DocumentStore\\DocumentStore; use EventEngine\\DocumentStore\\Filter\\AnyFilter; use EventEngine\\DocumentStore\\Filter\\LikeFilter; use MyService\\Domain\\Api\\Payload; use MyService\\Domain\\Model\\Building\\BuildingId; use MyService\\Domain\\Resolver\\Query\\GetBuilding; use MyService\\Domain\\Resolver\\Query\\GetBuildings; final class BuildingResolver implements Resolver { public const COLLECTION = 'buildings'; public const STATE = 'state'; public const STATE_DOT = 'state.'; \/** * @var DocumentStore *\/ private $documentStore; public function __construct(DocumentStore $documentStore) { $this-&gt;documentStore = $documentStore; } \/** * @param Query $query * @return array *\/ public function resolve(Query $query): array { switch (true) { case $query instanceof GetBuilding: return $this-&gt;resolveBuilding($query-&gt;buildingId()); case $query instanceof GetBuildings: return $this-&gt;resolveBuildings($query-&gt;name()); default: throw new \\RuntimeException(\"Query not supported. Got \" . VariableType::determine($query)); } } private function resolveBuilding(BuildingId $buildingId): array { $buildingDoc = $this-&gt;documentStore-&gt;getDoc(self::COLLECTION, $buildingId-&gt;toString()); if(!$buildingDoc) { throw new \\RuntimeException(\"Building not found\", 404); } return $buildingDoc[self::STATE]; } private function resolveBuildings(string $nameFilter = null): array { $filter = $nameFilter? new LikeFilter(self::STATE_DOT . Payload::NAME, \"%$nameFilter%\") : new AnyFilter(); $cursor = $this-&gt;documentStore-&gt;findDocs(self::COLLECTION, $filter); $buildings = []; foreach ($cursor as $doc) { $buildings[] = $doc[self::STATE]; } return $buildings; } } src\/Domain\/Resolver\/UserBuildingResolver.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Resolver; use EventEngine\\DocumentStore\\DocumentStore; use EventEngine\\Util\\VariableType; use MyService\\Domain\\Resolver\\Query\\GetUserBuildingList; final class UserBuildingResolver implements Resolver { \/** * @var DocumentStore *\/ private $documentStore; \/** * @var string *\/ private $userBuildingCollection; \/** * @var string *\/ private $buildingCollection; public function __construct(DocumentStore $documentStore, string $userBuildingCol, string $buildingCol) { $this-&gt;documentStore = $documentStore; $this-&gt;userBuildingCollection = $userBuildingCol; $this-&gt;buildingCollection = $buildingCol; } public function resolve(Query $query): array { if(!$query instanceof GetUserBuildingList) { throw new \\RuntimeException(\"Invalid query. Can only handle \" . GetUserBuildingList::class . '. But got ' . VariableType::determine($query)); } $userBuilding = $this-&gt;documentStore-&gt;getDoc( $this-&gt;userBuildingCollection, $query-&gt;name()-&gt;toString() ); if(!$userBuilding) { return [ 'user' =&gt; $query-&gt;name()-&gt;toString(), 'building' =&gt; null ]; } $building = $this-&gt;documentStore-&gt;getDoc( $this-&gt;buildingCollection, $userBuilding['buildingId'] ); if(!$building) { return [ 'user' =&gt; $query-&gt;name()-&gt;toString(), 'building' =&gt; null ]; } return [ 'user' =&gt; $query-&gt;name()-&gt;toString(), 'building' =&gt; $building['state'], ]; } } src\/System\/Flavour\/MyServiceMessagePort.phppublic function callResolver($customQuery, $resolver) { if(! $resolver instanceof Resolver) { throw new \\RuntimeException(\"Unsupported resolver. Got \" . VariableType::determine($resolver)); } return $resolver-&gt;resolve($customQuery); } All methods of the Functional\\Port are implemented. Good job! But we're not done yet."},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIII.html#2-11-10","title":"Switching The Flavour","content":"The flavour is configured in src\/System\/SystemServices.php and can be changed there:&lt;?php declare(strict_types=1); namespace MyService\\System; use EventEngine\\Data\\ImmutableRecordDataConverter; use EventEngine\\Logger\\LogEngine; use EventEngine\\Logger\\SimpleMessageEngine; use EventEngine\\Messaging\\Message; use EventEngine\\Prooph\\V7\\EventStore\\GenericProophEvent; use EventEngine\\Runtime\\Flavour; use EventEngine\\Runtime\\FunctionalFlavour; use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use MyService\\System\\Api\\EventEngineConfig; use MyService\\System\\Api\\SystemQuery; use MyService\\System\\Api\\SystemType; use MyService\\System\\Flavour\\MyServiceMessagePort; use Prooph\\Common\\Messaging\\NoOpMessageConverter; use Prooph\\ServiceBus\\Message\\HumusAmqp\\AmqpMessageProducer; use Psr\\Log\\LoggerInterface; trait SystemServices { \/* ... *\/ public function flavour(): Flavour { return $this-&gt;makeSingleton(Flavour::class, function () { return new FunctionalFlavour(new MyServiceMessagePort(), new ImmutableRecordDataConverter()); }); } \/* ... *\/ } Everything set up \u00f0\u009f\u008e\u0089. Refactoring can start!"},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIII.html#2-11-11","title":"Refactoring","content":"Switching the Flavour means all generic messages have to be replaced with their concrete implementations.In a larger project we might want to switch to another Flavour step by step. In that case a \"Proxy Flavour\" is required that uses PrototypingFlavour and FunctionalFlavour (or OopFlavour) internally together with a mapping of already migrated parts of the application.src\/Domain\/Model\/Building.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model; use MyService\\Domain\\Model\\Building\\Command\\AddBuilding; use MyService\\Domain\\Model\\Building\\Command\\CheckInUser; use MyService\\Domain\\Model\\Building\\Command\\CheckOutUser; use MyService\\Domain\\Model\\Building\\Event\\BuildingAdded; use MyService\\Domain\\Model\\Building\\Event\\DoubleCheckInDetected; use MyService\\Domain\\Model\\Building\\Event\\DoubleCheckOutDetected; use MyService\\Domain\\Model\\Building\\Event\\UserCheckedIn; use MyService\\Domain\\Model\\Building\\Event\\UserCheckedOut; final class Building { public static function add(AddBuilding $addBuilding): \\Generator { yield BuildingAdded::fromArray($addBuilding-&gt;toArray()); } public static function whenBuildingAdded(BuildingAdded $buildingAdded): Building\\State { return Building\\State::fromArray($buildingAdded-&gt;toArray()); } public static function checkInUser(Building\\State $state, CheckInUser $checkInUser): \\Generator { if($state-&gt;isUserCheckedIn($checkInUser-&gt;name())) { yield DoubleCheckInDetected::fromArray($checkInUser-&gt;toArray()); return; } yield UserCheckedIn::fromArray($checkInUser-&gt;toArray()); } public static function whenUserCheckedIn(Building\\State $state, UserCheckedIn $userCheckedIn): Building\\State { return $state-&gt;withCheckedInUser($userCheckedIn-&gt;name()); } public static function whenDoubleCheckInDetected(Building\\State $state, DoubleCheckInDetected $event): Building\\State { \/\/No state change required, simply return current state return $state; } public static function checkOutUser(Building\\State $state, CheckOutUser $checkOutUser): \\Generator { if(!$state-&gt;isUserCheckedIn($checkOutUser-&gt;name())) { yield DoubleCheckOutDetected::fromArray($checkOutUser-&gt;toArray()); return; } yield UserCheckedOut::fromArray($checkOutUser-&gt;toArray()); } public static function whenUserCheckedOut(Building\\State $state, UserCheckedOut $userCheckedOut): Building\\State { return $state-&gt;withCheckedOutUser($userCheckedOut-&gt;name()); } public static function whenDoubleCheckOutDetected(Building\\State $state, DoubleCheckOutDetected $event): Building\\State { return $state; } } Building\\State should make use of the new data types as well:&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model\\Building; use EventEngine\\Data\\ImmutableRecord; use EventEngine\\Data\\ImmutableRecordLogic; final class State implements ImmutableRecord { use ImmutableRecordLogic; public const BUILDING_ID = 'buildingId'; public const NAME = 'name'; \/** * @var BuildingId *\/ private $buildingId; \/** * @var BuildingName *\/ private $name; \/** * @var Username[] *\/ private $users = []; private static function arrayPropItemTypeMap(): array { return ['users' =&gt; Username::class]; } \/** * Called in constructor after setting props but before not null assertion * * Override to set default props after construction *\/ private function init(): void { \/\/Build internal users map $users = []; foreach ($this-&gt;users as $username) { $users[$username-&gt;toString()] = null; } $this-&gt;users = $users; } \/** * @return BuildingId *\/ public function buildingId(): BuildingId { return $this-&gt;buildingId; } \/** * @return BuildingName *\/ public function name(): BuildingName { return $this-&gt;name; } \/** * @return Username[] *\/ public function users(): array { return array_map(function (string $username) { return Username::fromString($username); }, array_keys($this-&gt;users)); } public function withCheckedInUser(Username $username): State { $copy = clone $this; $copy-&gt;users[$username-&gt;toString()] = null; return $copy; } public function withCheckedOutUser(Username $username): State { if(!$this-&gt;isUserCheckedIn($username)) { return $this; } $copy = clone $this; unset($copy-&gt;users[$username-&gt;toString()]); return $copy; } public function isUserCheckedIn(Username $username): bool { return array_key_exists($username-&gt;toString(), $this-&gt;users); } } UserBuildingList projector now needs to implement the interface EventEngine\\Projecting\\CustomEventProjector instead of EventEngine\\Projecting\\Projector:src\/Domain\/Projector\/UserBuildingList.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Projector; use EventEngine\\DocumentStore\\DocumentStore; use EventEngine\\Projecting\\CustomEventProjector; use MyService\\Domain\\Api\\Payload; use EventEngine\\Projecting\\AggregateProjector; use MyService\\Domain\\Model\\Building\\Event\\UserCheckedIn; use MyService\\Domain\\Model\\Building\\Event\\UserCheckedOut; final class UserBuildingList implements CustomEventProjector { \/** * @var DocumentStore *\/ private $documentStore; public function __construct(DocumentStore $documentStore) { $this-&gt;documentStore = $documentStore; } public function prepareForRun(string $projectionVersion, string $projectionName): void { if(!$this-&gt;documentStore-&gt;hasCollection(self::generateCollectionName($projectionVersion, $projectionName))) { $this-&gt;documentStore-&gt;addCollection( self::generateCollectionName($projectionVersion, $projectionName) \/* Note: we could pass index configuration as a second argument, see docs for details *\/ ); } } public function handle(string $appVersion, string $projectionName, $event): void { $collection = $this-&gt;generateCollectionName($appVersion, $projectionName); switch (true) { case $event instanceof UserCheckedIn: $this-&gt;documentStore-&gt;addDoc( $collection, $event-&gt;name()-&gt;toString(), \/\/Use username as doc id [Payload::BUILDING_ID =&gt; $event-&gt;buildingId()-&gt;toString()] ); break; case $event instanceof UserCheckedOut: $this-&gt;documentStore-&gt;deleteDoc($collection, $event-&gt;name()-&gt;toString()); break; default: \/\/Ignore unknown events } } public function deleteReadModel(string $appVersion, string $projectionName): void { $this-&gt;documentStore-&gt;dropCollection(self::generateCollectionName($appVersion, $projectionName)); } public static function generateCollectionName(string $projectionVersion, string $projectionName): string { \/\/We can use the naming strategy of the aggregate projector for our custom projection return AggregateProjector::generateCollectionName($projectionVersion, $projectionName); } } The UiExchange event listener included in the skeleton application needs to be aligned, too. First, the corresponding interface should handle any type of event:src\/System\/UiExchange.php&lt;?php declare(strict_types=1); namespace MyService\\System; interface UiExchange { public function __invoke($event): void; } Second, an implementation of the interface should handle our event objects. The skeleton simply uses an anonymous class to implement the interface. It can be found and changed in src\/System\/SystemServices.php.It's an anonymous class because the UiExchange is only included in the skeleton to demonstrate how events can be pushed to a message queue and consumed by a UI. The implementation is not meant to be used in production. You can get some inspiration from it, but please work out a production grade solution yourself.&lt;?php declare(strict_types=1); namespace MyService\\System; use EventEngine\\Data\\ImmutableRecordDataConverter; use EventEngine\\Logger\\LogEngine; use EventEngine\\Logger\\SimpleMessageEngine; use EventEngine\\Messaging\\MessageBag; use EventEngine\\Prooph\\V7\\EventStore\\GenericProophEvent; use EventEngine\\Runtime\\Flavour; use EventEngine\\Runtime\\FunctionalFlavour; use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use MyService\\Domain\\Api\\Event; use MyService\\System\\Api\\EventEngineConfig; use MyService\\System\\Api\\SystemQuery; use MyService\\System\\Api\\SystemType; use MyService\\System\\Flavour\\MyServiceMessagePort; use Prooph\\Common\\Messaging\\NoOpMessageConverter; use Prooph\\ServiceBus\\Message\\HumusAmqp\\AmqpMessageProducer; use Psr\\Log\\LoggerInterface; trait SystemServices { \/* ... *\/ public function uiExchange(): UiExchange { return $this-&gt;makeSingleton(UiExchange::class, function () { $this-&gt;assertMandatoryConfigExists('rabbit.connection'); $connection = new \\Humus\\Amqp\\Driver\\AmqpExtension\\Connection( $this-&gt;config()-&gt;arrayValue('rabbit.connection') ); $connection-&gt;connect(); $channel = $connection-&gt;newChannel(); $exchange = $channel-&gt;newExchange(); $exchange-&gt;setName($this-&gt;config()-&gt;stringValue('rabbit.ui_exchange', 'ui-exchange')); $exchange-&gt;setType('fanout'); $humusProducer = new \\Humus\\Amqp\\JsonProducer($exchange); $messageProducer = new \\Prooph\\ServiceBus\\Message\\HumusAmqp\\AmqpMessageProducer( $humusProducer, new NoOpMessageConverter() ); $flavour = $this-&gt;flavour(); return new class($messageProducer, $flavour) implements UiExchange { private $producer; private $flavour; public function __construct(AmqpMessageProducer $messageProducer, Flavour $flavour) { $this-&gt;producer = $messageProducer; $this-&gt;flavour = $flavour; } public function __invoke($event): void { $messageBag = new MessageBag( Event::nameOf($event), MessageBag::TYPE_EVENT, $event ); $event = $this-&gt;flavour-&gt;prepareNetworkTransmission($messageBag); $this-&gt;producer-&gt;__invoke(GenericProophEvent::fromArray([ 'uuid' =&gt; $event-&gt;uuid()-&gt;toString(), 'message_name' =&gt; $event-&gt;messageName(), 'payload' =&gt; $event-&gt;payload(), 'metadata' =&gt; $event-&gt;metadata(), 'created_at' =&gt; $event-&gt;createdAt() ])); } }; }); } } That's it! You can use Cockpit to test the changes.Or wait! We did not run the tests!docker-compose run php php vendor\/bin\/phpunit Doesn't look good, right? Let's fix it!TestCaseAbstract::assertRecordedEvent() method need to be aligned:&lt;?php declare(strict_types=1); namespace MyServiceTest; use EventEngine\\DocumentStore\\DocumentStore; use EventEngine\\EventEngine; use EventEngine\\EventStore\\EventStore; use EventEngine\\Logger\\DevNull; use EventEngine\\Logger\\SimpleMessageEngine; use EventEngine\\Messaging\\Message; use EventEngine\\Messaging\\MessageProducer; use EventEngine\\Persistence\\InMemoryConnection; use EventEngine\\Prooph\\V7\\EventStore\\InMemoryMultiModelStore; use EventEngine\\Util\\MessageTuple; use MyService\\Domain\\Api\\Event; use MyService\\ServiceFactory; use MyServiceTest\\Mock\\EventQueueMock; use MyServiceTest\\Mock\\MockContainer; use PHPUnit\\Framework\\TestCase; class TestCaseAbstract extends TestCase { \/* ... *\/ protected function assertRecordedEvent(string $eventName, array $payload, array $events, $assertNotRecorded = false): void { $isRecorded = false; foreach ($events as $evt) { if($evt === null) { continue; } \/\/Convert domain events to raw data $evtName = Event::nameOf($evt); $evtPayload = $evt-&gt;toArray(); if($eventName === $evtName) { $isRecorded = true; if(!$assertNotRecorded) { $this-&gt;assertEquals($payload, $evtPayload, \"Payload of recorded event $evtName does not match with expected payload.\"); } } } if($assertNotRecorded) { $this-&gt;assertFalse($isRecorded, \"Event $eventName is recorded\"); } else { $this-&gt;assertTrue($isRecorded, \"Event $eventName is not recorded\"); } } } NotifySecurityTest contains a mocked UiExchange. We changed the interface earlier, but did not change the mock. The test itself needs minor adjustments, too.tests\/Integration\/NotifySecurityTest.php&lt;?php declare(strict_types=1); namespace MyServiceTest\\Integration; use MyService\\Domain\\Api\\Command; use MyService\\Domain\\Api\\Event; use MyService\\Domain\\Api\\Payload; use MyService\\Domain\\Model\\Building\\Event\\DoubleCheckInDetected; use MyService\\System\\UiExchange; use MyServiceTest\\IntegrationTestCase; final class NotifySecurityTest extends IntegrationTestCase { const BUILDING_ID = '7c5f0c8a-54f2-4969-9596-b5bddc1e9421'; const BUILDING_NAME = 'Acme Headquarters'; const USERNAME = 'John'; private $uiExchange; protected function setUp(): void { parent::setUp(); \/\/Mock UiExchange with an anonymous class that keeps track of the last received message $this-&gt;uiExchange = new class implements UiExchange { private $lastReceivedMessage; public function __invoke($event): void { $this-&gt;lastReceivedMessage = $event; } public function lastReceivedMessage() { return $this-&gt;lastReceivedMessage; } }; \/\/ Mocks are passed to EE set up method \/\/ The IntegrationTestCase loads all EE descriptions \/\/ and uses the configured Flavour (PrototypingFlavour in our case) \/\/ to set up Event Engine $this-&gt;setUpEventEngine([ UiExchange::class =&gt; $this-&gt;uiExchange, ]); \/** * We can pass fixtures to the database set up: * * Stream to events map: * * [streamName =&gt; Event[]] * * Collection to documents map: * * [collectionName =&gt; [docId =&gt; doc]] *\/ $this-&gt;setUpDatabase([ \/\/ We use the default write model stream in the buildings app \/\/ and add a history for the test building \/\/ aggregate state is derived from history automatically during set up $this-&gt;eventEngine-&gt;writeModelStreamName() =&gt; [ $this-&gt;makeEvent(Event::BUILDING_ADDED, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::BUILDING_NAME ]), $this-&gt;makeEvent(Event::USER_CHECKED_IN, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME ]), ] ]); } \/** * @test *\/ public function it_detects_double_check_in_and_notifies_security() { \/\/Try to check in John twice $checkInJohn = $this-&gt;makeCommand(Command::CHECK_IN_USER, [ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME ]); $this-&gt;eventEngine-&gt;dispatch($checkInJohn); \/\/The IntegrationTestCase sets up an in-memory queue (accessible by $this-&gt;eventQueue) \/\/You can inspect published events or simply process the queue \/\/so that event listeners get invoked like our mocked UiExchange listener $this-&gt;processEventQueueWhileNotEmpty(); \/\/Now $this-&gt;lastPublishedEvent should point to the event received by UiExchange mock $this-&gt;assertNotNull($this-&gt;uiExchange-&gt;lastReceivedMessage()); $this-&gt;assertInstanceOf(DoubleCheckInDetected::class, $this-&gt;uiExchange-&gt;lastReceivedMessage()); $this-&gt;assertEquals([ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME ], $this-&gt;uiExchange-&gt;lastReceivedMessage()-&gt;toArray()); } } Next on the list is BuildingTest. tests\/Domain\/Model\/BuildingTest.php&lt;?php declare(strict_types=1); namespace MyServiceTest\\Domain\\Model; use MyService\\Domain\\Api\\Command; use MyService\\Domain\\Api\\Event; use MyService\\Domain\\Api\\Payload; use MyServiceTest\\UnitTestCase; use Ramsey\\Uuid\\Uuid; use MyService\\Domain\\Model\\Building; final class BuildingTest extends UnitTestCase { private $buildingId; private $buildingName; private $username; protected function setUp(): void { $this-&gt;buildingId = Uuid::uuid4()-&gt;toString(); $this-&gt;buildingName = 'Acme Headquarters'; $this-&gt;username = 'John'; parent::setUp(); } \/** * @test *\/ public function it_checks_in_a_user() { \/\/Prepare expected aggregate state $state = Building\\State::fromArray([ Building\\State::BUILDING_ID =&gt; $this-&gt;buildingId, Building\\State::NAME =&gt; $this-&gt;buildingName ]); \/\/Use test helper UnitTestCase::makeCommand() to construct command $command = Building\\Command\\CheckInUser::fromArray([ Building\\State::BUILDING_ID =&gt; $this-&gt;buildingId, Building\\State::NAME =&gt; $this-&gt;username, ]); \/\/Aggregate functions yield events, we have to collect them with a test helper $events = $this-&gt;collectNewEvents( Building::checkInUser($state, $command) ); \/\/Another test helper to assert that list of recorded events contains given event $this-&gt;assertRecordedEvent(Event::USER_CHECKED_IN, [ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;username ], $events); } } And last adjustments in UserBuildingListTest::it_manages_list_of_users_with_building_reference(). The projector expects dedicated event objects now.tests\/Domain\/Projector\/UserBuildingListTest.php&lt;?php declare(strict_types=1); namespace MyServiceTest\\Domain\\Projector; use EventEngine\\DocumentStore\\Filter\\AnyFilter; use MyService\\Domain\\Api\\Event; use MyService\\Domain\\Api\\Payload; use MyService\\Domain\\Api\\Projection; use MyService\\Domain\\Model\\Building\\Event\\UserCheckedIn; use MyService\\Domain\\Model\\Building\\Event\\UserCheckedOut; use MyService\\Domain\\Projector\\UserBuildingList; use MyServiceTest\\UnitTestCase; final class UserBuildingListTest extends UnitTestCase { const PRJ_VERSION = '0.1.0'; const BUILDING_ID = '7c5f0c8a-54f2-4969-9596-b5bddc1e9421'; const USERNAME1 = 'John'; const USERNAME2 = 'Jane'; \/** * @var UserBuildingList *\/ private $projector; protected function setUp(): void { parent::setUp(); \/\/DocumentStore is set up in parent::setUp() $this-&gt;projector = new UserBuildingList($this-&gt;documentStore); $this-&gt;projector-&gt;prepareForRun( self::PRJ_VERSION, Projection::USER_BUILDING_LIST ); } \/** * @test *\/ public function it_manages_list_of_users_with_building_reference() { $collection = UserBuildingList::generateCollectionName( self::PRJ_VERSION, Projection::USER_BUILDING_LIST ); $johnCheckedIn = UserCheckedIn::fromArray([ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME1 ]); $this-&gt;projector-&gt;handle( self::PRJ_VERSION, Projection::USER_BUILDING_LIST, $johnCheckedIn ); $users = iterator_to_array($this-&gt;documentStore-&gt;findDocs( $collection, new AnyFilter() )); $this-&gt;assertEquals($users, [ 'John' =&gt; ['buildingId' =&gt; self::BUILDING_ID] ]); $janeCheckedIn = UserCheckedIn::fromArray([ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME2 ]); $this-&gt;projector-&gt;handle( self::PRJ_VERSION, Projection::USER_BUILDING_LIST, $janeCheckedIn ); $users = iterator_to_array($this-&gt;documentStore-&gt;findDocs( $collection, new AnyFilter() )); $this-&gt;assertEquals($users, [ 'John' =&gt; ['buildingId' =&gt; self::BUILDING_ID], 'Jane' =&gt; ['buildingId' =&gt; self::BUILDING_ID], ]); $johnCheckedOut = UserCheckedOut::fromArray([ Payload::BUILDING_ID =&gt; self::BUILDING_ID, Payload::NAME =&gt; self::USERNAME1 ]); $this-&gt;projector-&gt;handle( self::PRJ_VERSION, Projection::USER_BUILDING_LIST, $johnCheckedOut ); $users = iterator_to_array($this-&gt;documentStore-&gt;findDocs( $collection, new AnyFilter() )); $this-&gt;assertEquals($users, [ 'Jane' =&gt; ['buildingId' =&gt; self::BUILDING_ID], ]); } } Tests are green again. Refactoring finished successfully. Was it worth the effort? Switching the Flavour is quite some work to do, isn't it? Depending on the amount of already written code and tests this task can take some days and you need to make sure that you don't break existing functionality. On the other hand you get a fully decoupled domain model. Of course, it's also possible to use another Flavour right from the beginning. But keep in mind, that the PrototypingFlavour saves a lot of time in the early days of a project. You don't know if the first app version really meets business and user needs. You can only try and experiment. The faster you have a working app, the faster you can get feedback from users and stakeholders. A lean implementation and simple infrastructure gives you a lot of flexibility at the beginning. Starting with a MVP is not a new concept. Event Engine just gives you a nice tool to build one and reuse parts of your experiments in later project phases. Also using CQRS \/ ES from day one gives you full advantage of a reactive system.Still curious to see what the OopFlavour can do? The last bonus part sheds light on it."},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIV.html#2-12","title":"Bonus IV - OOP Flavour","content":"The previous bonus part introduced Event Engine Flavours, especially the FunctionalFlavour. Biggest change was the replacement of generic Event Engine messages with dedicated message types."},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIV.html#2-12-1","title":"Original Object-Oriented Programming","content":"Event Engine emphasizes the usage of a functional core. That's true for the PrototypingFlavour and unfolds completely with the FunctionalFlavour. A functional core has huge advantages compared to its object-oriented counterpart. At least compared to the way we tend to work with objects in our projects the last twenty years or so.Dr. Alan Kay (who has coined the term) had quite a different idea of object-oriented programming back in 1967. I thought of objects being like biological cells and\/or individual computers on a network, only able to communicate with messages sourceLet that sink in - only able to communicate with messages.If you look at what we've built so far, you might recognize that we are very close to that statement. Resolver, Event Listener, Process Manager and Projector all are invoked with messages. They don't interact with each other directly. Event Engine takes over coordination. It's like the network Alan Kay is talking about. But what about aggregate functions? The functions are stateless and don't have side effects. They are pure. Immutable data types and messages (commands or events) are passed to them. With coordination performed by Event Engine pure functions work great."},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIV.html#2-12-2","title":"It Is Not Functional Programming","content":"We are not used to work with pure functions in PHP. It's not a functional programming language, right? Autoloading functions doesn't work so we are either forced to require all files manually or use the workaround shown in the tutorial to turn pure functions into static methods of otherwise useless classes.Personally, I don't have a big problem with the latter approach. I see those classes as the last part of the namespace or even similar to an ES6 module (if you're familiar with JavaScript). The module (PHP class) can export functions (public static functions) and use internal functions (private static functions). But I have to admit that it is a workaround."},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIV.html#2-12-3","title":"OopFlavour on top of FunctionalFlavour","content":"What can we do if the workaround is not acceptable for a project or personal taste? Exactly, we can pick another Flavour :DThe OopFlavour in a nutshell:Aggregate functions (command handling and apply functions) are combined with state into one object. Each aggregate manages its own state internally. Commands trigger state changes. A state change is first recorded as an event and then applied by the aggregate.You know what this means, right? I thought of objects being like biological cells and\/or individual computers on a network, only able to communicate with messages As I said, we're very close to that statement. That's the reason why the OopFlavour uses the FunctionalFlavour internally. It works on top of it only to combine aggregate functions and state. More on that in a minute. First we need a solid foundation for event sourced objects."},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIV.html#2-12-4","title":"OOP Port","content":"Similar to the Functional\\Port we need to implement an Oop\\Port to use the OopFlavour. Let's start again by looking at the required methods. Create a new class EventSourcedAggregatePort in src\/System\/Flavour:&lt;?php declare(strict_types=1); namespace MyService\\System\\Flavour; use EventEngine\\Runtime\\Oop\\Port; final class EventSourcedAggregatePort implements Port { \/** * @param string $aggregateType * @param callable $aggregateFactory * @param $customCommand * @param array $contextServices * @return mixed Created aggregate *\/ public function callAggregateFactory(string $aggregateType, callable $aggregateFactory, $customCommand, ...$contextServices) { \/\/ TODO: Implement callAggregateFactory() method. } \/** * @param mixed $aggregate * @param mixed $customCommand * @param array $contextServices *\/ public function callAggregateWithCommand($aggregate, $customCommand, ...$contextServices): void { \/\/ TODO: Implement callAggregateWithCommand() method. } \/** * @param mixed $aggregate * @return array of custom events *\/ public function popRecordedEvents($aggregate): array { \/\/ TODO: Implement popRecordedEvents() method. } \/** * @param mixed $aggregate * @param mixed $customEvent *\/ public function applyEvent($aggregate, $customEvent): void { \/\/ TODO: Implement applyEvent() method. } \/** * @param mixed $aggregate * @return array *\/ public function serializeAggregate($aggregate): array { \/\/ TODO: Implement serializeAggregate() method. } \/** * @param string $aggregateType * @param iterable $events history * @return mixed Aggregate instance *\/ public function reconstituteAggregate(string $aggregateType, iterable $events) { \/\/ TODO: Implement reconstituteAggregate() method. } \/** * @param string $aggregateType * @param array $state * @param int $version * @return mixed Aggregate instance *\/ public function reconstituteAggregateFromStateArray(string $aggregateType, array $state, int $version) { \/\/ TODO: Implement reconstituteAggregateFromStateArray() method. } } This time we don't work top to bottom but start in the middle. popRecordedEvents and applyEvent are the first targets.Same basic rules apply here as we discussed for the Functional\\Port. Event Engine does not require a specific strategy to work with event sourced aggregates. You can implement them in any way as long as the Oop\\Port is able to fulfill the contract. That said, the approach shown in the tutorial is just a suggestion. We're going to use a simple and pragmatic implementation with publicly accessible methods that are actually internal methods. You might want to hide them in your project using a decorator or PHP's Reflection API. Anyway, that would be overkill for the tutorial."},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIV.html#2-12-5","title":"Event Sourced Aggregate Root","content":"A state change is first recorded as an event and then applied by the aggregate.Let's create an interface for the port to rely on:src\/Domain\/Model\/Base\/AggregateRoot.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model\\Base; interface AggregateRoot { \/** * @return DomainEvent[] *\/ public function popRecordedEvents(): array; public function apply(DomainEvent $event): void; } We don't have a DomainEvent type yet. Add it next to the AggregateRoot interface in the same directory.src\/Model\/Base\/DomainEvent.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model\\Base; interface DomainEvent { \/\/Marker interface } With those two interfaces we can implement the first methods of the Oop\\Port:src\/System\/Flavour\/EventSourcedAggregatePort.php&lt;?php declare(strict_types=1); namespace MyService\\System\\Flavour; use MyService\\Domain\\Model\\Base\\AggregateRoot; use EventEngine\\Runtime\\Oop\\Port; final class EventSourcedAggregatePort implements Port { \/* ... *\/ \/** * @param mixed $aggregate * @return array of custom events *\/ public function popRecordedEvents($aggregate): array { if(!$aggregate instanceof AggregateRoot) { throw new \\RuntimeException( sprintf(\"Cannot pop recorded events. Given aggregate is not an instance of %s. Got %s\", AggregateRoot::class, (is_object($aggregate)? get_class($aggregate) : gettype($aggregate)) ) ); } return $aggregate-&gt;popRecordedEvents(); } \/** * @param mixed $aggregate * @param mixed $customEvent *\/ public function applyEvent($aggregate, $customEvent): void { if(!$aggregate instanceof AggregateRoot) { throw new \\RuntimeException( sprintf(\"Cannot apply event. Given aggregate is not an instance of %s. Got %s\", AggregateRoot::class, (is_object($aggregate)? get_class($aggregate) : gettype($aggregate)) ) ); } $aggregate-&gt;apply($customEvent); } \/* ... *\/ } "},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIV.html#2-12-6","title":"Aggregate Root Lifecycle","content":"Next two methods we are looking at are callAggregateFactory and reconstituteAggregate. The former starts the lifecycle of a new aggregate and the latter brings it back into shape by passing aggregate event history (all events previously recorded by the aggregate) to the method.Traits are a great way to reuse code snippets without inheritance. It's like copy and pasting methods from a blueprint into a class. Let's define one for common event sourcing logic that we can later use in aggregates.src\/Domain\/Model\/Base\/EventSourced.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model\\Base; trait EventSourced { \/** * @var DomainEvent[] *\/ private $recordedEvents = []; \/** * @param DomainEvent[] $domainEvents * @return EventSourced aggregate *\/ public static function reconstituteFromHistory(DomainEvent ...$domainEvents): AggregateRoot { $self = new self(); foreach ($domainEvents as $domainEvent) { $self-&gt;apply($domainEvent); } return $self; } private function __construct() { \/\/Do not override this!!!! \/\/Use named constructors aka public static factory methods to create aggregae instances! } private function recordThat(DomainEvent $event): void { $this-&gt;recordedEvents[] = $event; } \/** * @return DomainEvent[] *\/ public function popRecordedEvents(): array { $events = $this-&gt;recordedEvents; $this-&gt;recordedEvents = []; return $events; } public function apply(DomainEvent $event): void { $whenMethod = $this-&gt;deriveMethodNameFromEvent($event); if(!method_exists($this, $whenMethod)) { throw new \\RuntimeException(\\sprintf( \"Unable to apply event %s. Missing method %s in class %s\", \\get_class($event), $whenMethod, \\get_class($this) )); } $this-&gt;{$whenMethod}($event); } private function deriveMethodNameFromEvent(DomainEvent $event): string { $nameParts = \\explode('\\\\', \\get_class($event)); return 'when' . \\array_pop($nameParts); } } The trait provides implementations for popRecordedEvents and apply defined by AggregateRoot. But it contains some more stuff!"},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIV.html#2-12-6-1","title":"Derive Method Name From Event","content":"A convention is used that says: An aggregate should have an apply method for each domain event following the naming pattern \"when&lt;EventName&gt;\", whereby &lt;EventName&gt; is the class name of the event without namespace."},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIV.html#2-12-6-2","title":"Record That","content":"An aggregate should use recordThat to record new domain events. The trait takes care of storing recorded events internally until the Oop\\Port calls popRecordedEvents()."},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIV.html#2-12-6-3","title":"Private Empty Constructor","content":"While a trait cannot enforce a private empty __construct (it could be overridden by a class), it's still included in the trait as a reminder for future developers to not use __construct in aggregate roots but rather use named constructors. This rule is important for Oop\\Port::callAggregateFactory(). More on that in a minute."},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIV.html#2-12-6-4","title":"Reconstitute From History","content":"reconstituteFromHistory should be called by the Oop\\Port. But the port works against our AggregateRoot interface, so we should add such a method signature there, too.src\/Domain\/Model\/Base\/AggregateRoot.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model\\Base; interface AggregateRoot { public static function reconstituteFromHistory(DomainEvent ...$domainEvents): self; \/** * @return DomainEvent[] *\/ public function popRecordedEvents(): array; public function apply(DomainEvent $event): void; } Cool, we can implement the next port method now!src\/System\/Flavour\/EventSourcedAggregatePort.php&lt;?php declare(strict_types=1); namespace MyService\\System\\Flavour; use EventEngine\\Runtime\\Oop\\Port; use MyService\\Domain\\Api\\Aggregate; use MyService\\Domain\\Model\\Base\\AggregateRoot; use MyService\\Domain\\Model\\Building; final class EventSourcedAggregatePort implements Port { \/* ... *\/ \/** * @param string $aggregateType * @param iterable $events history * @return mixed Aggregate instance *\/ public function reconstituteAggregate(string $aggregateType, iterable $events) { $arClass = $this-&gt;getAggregateClassOfType($aggregateType); \/** @var AggregateRoot $arClass *\/ return $arClass::reconstituteFromHistory(...$events); } private function getAggregateClassOfType(string $aggregateType): string { switch ($aggregateType) { case Aggregate::BUILDING: return Building::class; default: throw new \\RuntimeException(\"Unknown aggregate type $aggregateType\"); } } } "},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIV.html#2-12-6-5","title":"Reconstitute From State Array","content":"The Oop\\Port contract requires another reconstitute method: reconstituteAggregateFromStateArray. It's pretty much the same as reconstituteAggregate but this time the aggregate needs to be reconstituted from a state array. Event Engine needs the functionality when it loads aggregate snapshots either taken by the MultiModelStore or the AggregateProjector.Another method is required in the AggregateRoot interface:src\/Domain\/Model\/Base\/AggregateRoot.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model\\Base; interface AggregateRoot { public static function reconstituteFromHistory(DomainEvent ...$domainEvents): self; public static function reconstituteFromStateArray(array $state): self; \/** * @return DomainEvent[] *\/ public function popRecordedEvents(): array; public function apply(DomainEvent $event): void; } and the corresponding port implementation:&lt;?php declare(strict_types=1); namespace MyService\\System\\Flavour; use EventEngine\\Runtime\\Oop\\Port; use MyService\\Domain\\Api\\Aggregate; use MyService\\Domain\\Model\\Base\\AggregateRoot; use MyService\\Domain\\Model\\Building; final class EventSourcedAggregatePort implements Port { \/* ... *\/ \/** * @param string $aggregateType * @param iterable $events history * @return mixed Aggregate instance *\/ public function reconstituteAggregateFromStateArray(string $aggregateType, array $state, int $version) { $arClass = $this-&gt;getAggregateClassOfType($aggregateType); \/\/ Note: $version is ignored, our aggregate implementation \/\/ relies on the version managed by Event Engine internally \/** @var AggregateRoot $arClass *\/ return $arClass::reconstituteFromStateArray($state); } private function getAggregateClassOfType(string $aggregateType): string { switch ($aggregateType) { case Aggregate::BUILDING: return Building::class; default: throw new \\RuntimeException(\"Unknown aggregate type $aggregateType\"); } } } Obviously, this won't work. We did not touch Building yet. Let's do that next."},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIV.html#2-12-7","title":"Merge Functions And State","content":"Our Building aggregate consists of a set of pure functions grouped in a class and immutable data types. Turning it into an event sourced object is less work than you might expect:src\/Domain\/Model\/Building.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model; use MyService\\Domain\\Model\\Base\\AggregateRoot; use MyService\\Domain\\Model\\Base\\EventSourced; use MyService\\Domain\\Model\\Building\\Command\\AddBuilding; use MyService\\Domain\\Model\\Building\\Command\\CheckInUser; use MyService\\Domain\\Model\\Building\\Command\\CheckOutUser; use MyService\\Domain\\Model\\Building\\Event\\BuildingAdded; use MyService\\Domain\\Model\\Building\\Event\\DoubleCheckInDetected; use MyService\\Domain\\Model\\Building\\Event\\DoubleCheckOutDetected; use MyService\\Domain\\Model\\Building\\Event\\UserCheckedIn; use MyService\\Domain\\Model\\Building\\Event\\UserCheckedOut; final class Building implements AggregateRoot { use EventSourced; \/** * @var Building\\State *\/ private $state; public static function reconstituteFromStateArray(array $state): AggregateRoot { $self = new self(); $self-&gt;state = Building\\State::fromArray($state); return $self; } public static function add(AddBuilding $addBuilding): AggregateRoot { $self = new self(); $self-&gt;recordThat(BuildingAdded::fromArray($addBuilding-&gt;toArray())); return $self; } public function whenBuildingAdded(BuildingAdded $buildingAdded): void { $this-&gt;state = Building\\State::fromArray($buildingAdded-&gt;toArray()); } public function checkInUser(CheckInUser $checkInUser): void { if($this-&gt;state-&gt;isUserCheckedIn($checkInUser-&gt;name())) { $this-&gt;recordThat(DoubleCheckInDetected::fromArray($checkInUser-&gt;toArray())); return; } $this-&gt;recordThat(UserCheckedIn::fromArray($checkInUser-&gt;toArray())); } private function whenUserCheckedIn(UserCheckedIn $userCheckedIn): void { $this-&gt;state = $this-&gt;state-&gt;withCheckedInUser($userCheckedIn-&gt;name()); } private function whenDoubleCheckInDetected(DoubleCheckInDetected $event): void { \/\/No state change required } public function checkOutUser(CheckOutUser $checkOutUser): void { if(!$this-&gt;state-&gt;isUserCheckedIn($checkOutUser-&gt;name())) { $this-&gt;recordThat(DoubleCheckOutDetected::fromArray($checkOutUser-&gt;toArray())); return; } $this-&gt;recordThat(UserCheckedOut::fromArray($checkOutUser-&gt;toArray())); } private function whenUserCheckedOut(UserCheckedOut $userCheckedOut): void { $this-&gt;state = $this-&gt;state-&gt;withCheckedOutUser($userCheckedOut-&gt;name()); } private function whenDoubleCheckOutDetected(DoubleCheckOutDetected $event): void { \/\/No state change required } } Here are the refactoring steps: All events need to implement MyService\\Domain\\Model\\Base\\DomainEvent Building implements AggregateRoot Building uses EventSourced Building stores Building\\State internally in a state property Building::add() creates an instance of itself and records BuildingAdded instead of yielding it Building::reconstituteFromStateArray sets up internal state using Building\\State::fromArray() All other command handling functions: Remove static, they become instance methods Change return type to void Building\\State is no longer an argument, but accessed internally Domain events get recorded All apply\/when functions Remove static and make them private, they become internal methods Change return type to void Building\\State is no longer an argument, but accessed internally "},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIV.html#2-12-8","title":"Aggregate Factory","content":"Building::add() is the aggregate factory for Building. The Oop\\Port can simply call it.src\/System\/Flavour\/EventSourcedAggregatePort.php&lt;?php declare(strict_types=1); namespace MyService\\System\\Flavour; use MyService\\Domain\\Model\\Base\\AggregateRoot; use EventEngine\\Runtime\\Oop\\Port; final class EventSourcedAggregatePort implements Port { \/** * @param string $aggregateType * @param callable $aggregateFactory * @param $customCommand * @param array $contextServices * @return mixed Created aggregate *\/ public function callAggregateFactory(string $aggregateType, callable $aggregateFactory, $customCommand, ...$contextServices) { return $aggregateFactory($customCommand, ...$contextServices); } \/* ... *\/ } The callable $aggregateFactory passed to the port, is still the one we've defined in the Event Engine Description:src\/Domain\/Api\/Aggregate.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use MyService\\Domain\\Model\\Building; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; class Aggregate implements EventEngineDescription { const BUILDING = 'Building'; \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;process(Command::ADD_BUILDING) -&gt;withNew(self::BUILDING) -&gt;identifiedBy(Payload::BUILDING_ID) -&gt;handle([Building::class, 'add']) \/\/&lt;-- Aggregate Factory -&gt;recordThat(Event::BUILDING_ADDED) -&gt;apply([Building::class, 'whenBuildingAdded']); \/* ... *\/ } } $contextServices is not an argument of Building::add() but PHP does not care. We can use that to our advantage. The port does not need to know if an aggregate factory or command handling function is interested in a context or requires dependencies. It just passes it always to the function. If $contextServices is empty and the function doesn't care, everything is fine."},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIV.html#2-12-9","title":"Command Handling","content":"Oop\\Port::callAggregateWithCommand() is next on the list. Let's see ...\/** * @param mixed $aggregate * @param mixed $customCommand * @param array $contextServices *\/ public function callAggregateWithCommand($aggregate, $customCommand, ...$contextServices): void { \/\/ TODO: Implement callAggregateWithCommand() method. } We get the $aggregate instance, a $customCommand and optionally a list of $contextServices. We could use a switch (command) -&gt; call $aggregate-&gt;method approach, but we are lazy. We don't want to touch the port each time we add a new command to the system. Conventions work great to get around the issue.An aggregate root should have a method named like the command, whereby command name is derived from its class name without namespace. The first letter of the name is lowercase.Looking at Building methods, it's exactly what we already have in place ;) We just need to implement the convention in the port.src\/Infrastructure\/Flavour\/EventSourcedAggregatePort.php&lt;?php declare(strict_types=1); namespace MyService\\System\\Flavour; use MyService\\Domain\\Model\\Base\\AggregateRoot; use EventEngine\\Runtime\\Oop\\Port; final class EventSourcedAggregatePort implements Port { \/* ... *\/ \/** * @param mixed $aggregate * @param mixed $customCommand * @param array $contextServices *\/ public function callAggregateWithCommand($aggregate, $customCommand, ...$contextServices): void { $commandNameParts = \\explode('\\\\', \\get_class($customCommand)); $handlingMethod = \\lcfirst(\\array_pop($commandNameParts)); $aggregate-&gt;{$handlingMethod}($customCommand, ...$contextServices); } \/* ... *\/ } Low hanging fruits, right? But the Event Engine Aggregate Description is broken! Handle and apply functions are no longer callable (except aggregate factory), because they are instance methods now. To get around the issue, we can replace the definition with a FlavourHint.src\/Domain\/Api\/Aggregate.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Api; use EventEngine\\Runtime\\Oop\\FlavourHint; use MyService\\Domain\\Model\\Building; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use MyService\\Domain\\Resolver\\BuildingResolver; class Aggregate implements EventEngineDescription { const BUILDING = 'Building'; \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;process(Command::ADD_BUILDING) -&gt;withNew(self::BUILDING) -&gt;identifiedBy(Payload::BUILDING_ID) -&gt;handle([Building::class, 'add']) -&gt;recordThat(Event::BUILDING_ADDED) -&gt;apply([FlavourHint::class, 'useAggregate']) -&gt;storeStateIn(BuildingResolver::COLLECTION); $eventEngine-&gt;process(Command::CHECK_IN_USER) -&gt;withExisting(self::BUILDING) -&gt;handle([FlavourHint::class, 'useAggregate']) -&gt;recordThat(Event::USER_CHECKED_IN) -&gt;apply([FlavourHint::class, 'useAggregate']) -&gt;orRecordThat(Event::DOUBLE_CHECK_IN_DETECTED) -&gt;apply([FlavourHint::class, 'useAggregate']); $eventEngine-&gt;process(Command::CHECK_OUT_USER) -&gt;withExisting(self::BUILDING) -&gt;handle([FlavourHint::class, 'useAggregate']) -&gt;recordThat(Event::USER_CHECKED_OUT) -&gt;apply([FlavourHint::class, 'useAggregate']) -&gt;orRecordThat(Event::DOUBLE_CHECK_OUT_DETECTED) -&gt;apply([FlavourHint::class, 'useAggregate']); } } That's a bit of a drawback of the OopFlavour. It relies less on Event Engine, but Event Engine still wants to make sure that you don't forget to handle a command or apply an event (handle and apply definition is mandatory). With the FlavourHint we basically tell Event Engine: \"Don't worry, we know what we're doing!\". It's a small extra step, but trust me, it still saves you time. Forgetting to add a route for a message to some config or have a typo somewhere is one of the most silly bugs that can cost you hours for nothing!"},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIV.html#2-12-10","title":"Aggregate State","content":"One method left in the port: serializeAggregate(). A simple toArray() on the aggregate is sufficient. We add it to the AggregateRoot interface to enforce its implementation.src\/Model\/Base\/AggregateRoot.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model\\Base; interface AggregateRoot { \/** * @return DomainEvent[] *\/ public function popRecordedEvents(): array; public function apply(DomainEvent $event): void; public function toArray(): array; } Building can call the toArray method of Building\\State ...src\/Domain\/Model\/Building.php&lt;?php declare(strict_types=1); namespace MyService\\Domain\\Model; use MyService\\Domain\\Model\\Base\\AggregateRoot; use MyService\\Domain\\Model\\Base\\EventSourced; use MyService\\Domain\\Model\\Building\\Command\\AddBuilding; use MyService\\Domain\\Model\\Building\\Command\\CheckInUser; use MyService\\Domain\\Model\\Building\\Command\\CheckOutUser; use MyService\\Domain\\Model\\Building\\Event\\BuildingAdded; use MyService\\Domain\\Model\\Building\\Event\\DoubleCheckInDetected; use MyService\\Domain\\Model\\Building\\Event\\DoubleCheckOutDetected; use MyService\\Domain\\Model\\Building\\Event\\UserCheckedIn; use MyService\\Domain\\Model\\Building\\Event\\UserCheckedOut; final class Building implements AggregateRoot { use EventSourced; \/** * @var Building\\State *\/ private $state; \/* ... *\/ public function toArray(): array { return $this-&gt;state-&gt;toArray(); } } ... and the Oop\\Port does the same:src\/System\/Flavour\/EventSourcedAggregatePort.php&lt;?php declare(strict_types=1); namespace MyService\\System\\Flavour; use MyService\\Domain\\Model\\Base\\AggregateRoot; use EventEngine\\Runtime\\Oop\\Port; final class EventSourcedAggregatePort implements Port { \/* ... *\/ \/** * @param mixed $aggregate * @return array *\/ public function serializeAggregate($aggregate): array { if(!$aggregate instanceof AggregateRoot) { throw new \\RuntimeException( sprintf(\"Cannot serialize aggregate. Given aggregate is not an instance of %s. Got %s\", AggregateRoot::class, (is_object($aggregate)? get_class($aggregate) : gettype($aggregate)) ) ); } return $aggregate-&gt;toArray(); } \/* ... *\/ } Of course, you can use a totally different serialization strategy. Organising aggregate state in a single immutable state object is also only a suggestion. Do whatever you like. It's your choice!"},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIV.html#2-12-11","title":"Activate OopFlavour","content":"As a last step (before looking at the tests \u00f0\u009f\u0099\u0088) we should activate the OopFlavour in src\/System\/SystemServices.php:src\/Service\/ServiceFactory.php&lt;?php declare(strict_types=1); namespace MyService\\System; use EventEngine\\Data\\ImmutableRecordDataConverter; use EventEngine\\Logger\\LogEngine; use EventEngine\\Logger\\SimpleMessageEngine; use EventEngine\\Messaging\\MessageBag; use EventEngine\\Prooph\\V7\\EventStore\\GenericProophEvent; use EventEngine\\Runtime\\Flavour; use EventEngine\\Runtime\\FunctionalFlavour; use EventEngine\\Runtime\\OopFlavour; use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use MyService\\Domain\\Api\\Event; use MyService\\System\\Api\\EventEngineConfig; use MyService\\System\\Api\\SystemQuery; use MyService\\System\\Api\\SystemType; use MyService\\System\\Flavour\\EventSourcedAggregatePort; use MyService\\System\\Flavour\\MyServiceMessagePort; use Prooph\\Common\\Messaging\\NoOpMessageConverter; use Prooph\\ServiceBus\\Message\\HumusAmqp\\AmqpMessageProducer; use Psr\\Log\\LoggerInterface; trait SystemServices { \/* ... *\/ \/\/Flavour public function flavour(): Flavour { return $this-&gt;makeSingleton(Flavour::class, function () { return new OopFlavour( new EventSourcedAggregatePort(), new FunctionalFlavour(new MyServiceMessagePort(), new ImmutableRecordDataConverter()) ); }); } \/* ... *\/ } As stated at the beginning, the OopFlavour uses the FunctionalFlavour mainly to make use of custom message handling."},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIV.html#2-12-12","title":"Fixing tests","content":"At least the BuildingTest should fail after latest changes. Let's see if we need to work some extra hours or can go out for a beer with a friend:docker-compose run php php vendor\/bin\/phpunit As expected, BuildingTest is broken, but should be easy to fix:&lt;?php declare(strict_types=1); namespace MyServiceTest\\Domain\\Model; use MyService\\Domain\\Api\\Command; use MyService\\Domain\\Api\\Event; use MyService\\Domain\\Api\\Payload; use MyServiceTest\\UnitTestCase; use Ramsey\\Uuid\\Uuid; use MyService\\Domain\\Model\\Building; final class BuildingTest extends UnitTestCase { private $buildingId; private $buildingName; private $username; protected function setUp(): void { $this-&gt;buildingId = Uuid::uuid4()-&gt;toString(); $this-&gt;buildingName = 'Acme Headquarters'; $this-&gt;username = 'John'; parent::setUp(); } \/** * @test *\/ public function it_checks_in_a_user() { \/\/Prepare expected aggregate state $state = Building\\State::fromArray([ Building\\State::BUILDING_ID =&gt; $this-&gt;buildingId, Building\\State::NAME =&gt; $this-&gt;buildingName ]); \/** @var Building $building *\/ $building = Building::reconstituteFromStateArray($state-&gt;toArray()); \/\/Use test helper UnitTestCase::makeCommand() to construct command $command = Building\\Command\\CheckInUser::fromArray([ Building\\State::BUILDING_ID =&gt; $this-&gt;buildingId, Building\\State::NAME =&gt; $this-&gt;username, ]); $building-&gt;checkInUser($command); $events = $building-&gt;popRecordedEvents(); \/\/Another test helper to assert that list of recorded events contains given event $this-&gt;assertRecordedEvent(Event::USER_CHECKED_IN, [ Payload::BUILDING_ID =&gt; $this-&gt;buildingId, Payload::NAME =&gt; $this-&gt;username ], $events); } } We can use methods from AggregateRoot to set up our Building with state, invoke the command handling method and use popRecordedEvents() to access newly recorded events. That's it!"},{"id":"https:\/\/event-engine.github.io\/tutorial\/bonusIV.html#2-12-13","title":"Wrap Up","content":"At this point the tutorial ends. Thank you for taking the tour through the world of CQRS and Event Sourcing with Event Engine. We started our tour with a rapid development approach. Event Engine really shines here. The skeleton application is preconfigured including some best practices like splitting Event Engine Descriptions by functionality. We learned how to react on domain events and how to project them into a read model, that we can access using queries and resolvers. All that with a minimum of boilerplate. Finally, Event Engine Flavours gave us a way to write more explicit code and harden the domain model. Every team can find its own style by mixing Flavours, conventions and serialization techniques.What's next?You can start to work on your own project. Event Engine docs cover advanced topics and a lot more details, but get some practice first and revisit them every now and then."},{"id":"https:\/\/event-engine.github.io\/api\/set_up\/installation.html#3-1-1","title":"Installation","content":"Event Engine is not a full stack framework. Instead you integrate it in any PHP framework that supports PHP Standards Recommendations."},{"id":"https:\/\/event-engine.github.io\/api\/set_up\/installation.html#3-1-1-1","title":"Skeleton","content":"The easiest way to get started is by using the skeleton. It ships with a preconfigured Event Engine, a recommended project structure, ready-to-use docker containers and Zend Strategility to handle HTTP requests.Again: The skeleton is not the only way to set up Event Engine. You can tweak set up as needed and integrate Event Engine with Symfony, Laravel or any other framework or middleware dispatcher."},{"id":"https:\/\/event-engine.github.io\/api\/set_up\/installation.html#3-1-1-2","title":"Required Infrastructure","content":"Event Engine is based on PHP 7.2 or higher. Package dependencies are installed using composer."},{"id":"https:\/\/event-engine.github.io\/api\/set_up\/installation.html#3-1-1-2-1","title":"Database","content":"By default Event Engine uses prooph\/event-store to store events recorded by the write model and a DocumentStore (see \"Document Store\" chapter) to store the read model.The skeleton uses prooph's Postgres event store and a Postgres Document Store implementation. This allows Event Engine to work with a single database, but that's not a requirement. You can mix and match. Event Engine defines a lean event store interface, that can be found in the event-engine\/php-event-store package. Projections don't have a hard dependency on the document store, either. A document store is only required when using the MultiModelStore feature or the default aggregate projection. Other than that, you can use whatever you want to persist the read model."},{"id":"https:\/\/event-engine.github.io\/api\/set_up\/installation.html#3-1-1-2-1-1","title":"Creating The Event Stream","content":"By default all events are stored in a single stream and prooph\/event-store has to be set up with the SingleStreamStrategy! The reason for this is that projections rely on a guaranteed order of events. A single stream is the only way to fulfill this requirement.When using a relational database as an event store a single table is also very efficient. A longer discussion about the topic can be found in the prooph\/pdo-event-store repo.An easy way to create the needed stream is to use the event store API directly.&lt;?php declare(strict_types=1); namespace EventEngine; use ArrayIterator; use Prooph\\EventStore\\EventStore; use Prooph\\EventStore\\Stream; use Prooph\\EventStore\\StreamName; chdir(dirname(__DIR__)); require_once 'vendor\/autoload.php'; $container = require 'config\/container.php'; \/** @var EventStore $eventStore *\/ $eventStore = $container-&gt;get(EventStore::class); $eventStore-&gt;create(new Stream(new StreamName('event_stream'), new ArrayIterator())); echo \"done.\\n\"; Such a script is used in the skeleton. As you can see we request the event store from a container that we get from a config file. The skeleton uses Zend Strategility and this is a common approach in Strategility (and Zend Expressive) based applications.If you want to use another framework, adopt the script accordingly. The only thing that really matters is that you get a configured prooph\/event-store from the PSR-11 container used by Event Engine."},{"id":"https:\/\/event-engine.github.io\/api\/set_up\/installation.html#3-1-1-2-1-2","title":"Read Model Storage","content":"Projection storage is set up on the fly. You don't need to prepare it upfront, but you can if you prefer to work with a database migration tool. It is up to you. Learn more about read model storage set up in the projections chapter.The Multi-Model-Store requires existing read model collections. Please find a detailed explanation in the tutorial."},{"id":"https:\/\/event-engine.github.io\/api\/set_up\/installation.html#3-1-1-3","title":"Descriptions","content":"Event Engine is bootstrapped in three phases. Descriptions are loaded first, followed by a $eventEngine-&gt;initialize(\/* dependencies *\/) call. Finally, $eventEngine-&gt;bootstrap($env, $debugMode) prepares the system so that it can handle incoming messages.Bootstrapping is split because description and initialization phase can be skipped in production. Read more about this in Production Optimization.A \"zero configuration\" approach is used. While you have to configure integrated packages like prooph\/event-store, Event Engine itself does not require centralized configuration. Instead it loads so called Event Engine Descriptions:&lt;?php declare(strict_types=1); namespace Prooph\\EventEngine; interface EventEngineDescription { public static function describe(EventEngine $eventEngine): void; } Any class implementing the interface can be loaded by Event Engine. The task of a Description is to tell Event Engine how the application is structured. This is done in a programmatic way using Event Engine's registration API which we will cover in the next chapter. Here is a simple example of a Description that registers a command in Event Engine.&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventEngine\\EventEngine; use Prooph\\EventEngine\\EventEngineDescription; class Command implements EventEngineDescription { const COMMAND_CONTEXT = 'MyContext.'; const REGISTER_USER = self::COMMAND_CONTEXT . 'RegisterUser'; \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;registerCommand( self::REGISTER_USER, \/\/&lt;-- Name of the command defined as constant above JsonSchema::object([ Payload::USER_ID =&gt; Schema::userId(), Payload::USERNAME =&gt; Schema::username(), Payload::EMAIL =&gt; Schema::email(), ]) ); } } Now we only need to tell Event Engine that it should load the Description:declare(strict_types=1); require_once 'vendor\/autoload.php'; $eventEngine = new EventEngine( new OpisJsonSchema() \/* Or another Schema implementation *\/ ); $eventEngine-&gt;load(App\\Api\\Command::class); Event Engine only requires a EventEngine\\Schema\\Schema implementation in the constructor. All other dependencies are passed during initialize phase (see next section)."},{"id":"https:\/\/event-engine.github.io\/api\/set_up\/installation.html#3-1-1-4","title":"Initialize","content":"Event Engine needs to aggregate information from all Descriptions. This is done in the Initialize phase. The phase also requires mandatory and optional dependencies used by Event Engine. Details are listed on the Dependencies page."},{"id":"https:\/\/event-engine.github.io\/api\/set_up\/installation.html#3-1-1-5","title":"Bootstrap","content":"Last, but not least $eventEngine-&gt;bootstrap($environment, $debugMode) starts the engine and we're ready to take off. Event Engine supports 3 different environments: dev, prod and test. The environment is mainly used to set up third-party components like a logger.Same is true for the debug mode. It can be used to enable verbose logging or displaying of exceptions even if Event Engine runs in prod environment. You have to take care of this when setting up services. Event Engine just provides the information:Environment: $eventEngine-&gt;env(); \/\/ prod | dev | test Debug Mode: $eventEngine-&gt;debugMode(); \/\/ bool "},{"id":"https:\/\/event-engine.github.io\/api\/set_up\/di.html#3-1-2","title":"Dependencies","content":"When initializing Event Engine - EventEngine::initialize() or EventEngine::fromCachedConfig() - you have to pass a couple of mandatory and optional dependencies. This page serves as an overview and provides links to the docs of each dependency."},{"id":"https:\/\/event-engine.github.io\/api\/set_up\/di.html#3-1-2-1","title":"Schema","content":"Mandatory DependencyAn EventEngine\\Schema\\Schema is either required in the Event Engine constructor or as the first argument of EventEngine::fromCachedConfig(). The latter method is used when initializing Event Engine from a cached config. Production Optimization contains further information.@TODO Link to schema docsevent-engine\/php-json-schema (@TODO add link) provides a JSON Schema implementation of EventEngine\\Schema\\Schema.A Schema implementation is the only dependency required in the constructor. Event Engine needs it to validate message schema defined in the description phase. All other dependencies are first required when initializing Event Engine. EventEngine::fromCachedConfig() skips description phase and initialize phase, therefor it requires all dependencies along with the cached config."},{"id":"https:\/\/event-engine.github.io\/api\/set_up\/di.html#3-1-2-2","title":"Flavour","content":"Mandatory DependencyA Flavour is the gateway between Event Engine and your code. Three different Flavours are available and you can implement your own EventEngine\\Runtime\\Flavour if needed. Learn more about Flavours (@TODO add link)."},{"id":"https:\/\/event-engine.github.io\/api\/set_up\/di.html#3-1-2-3","title":"Event Store","content":"Mandatory DependencyEvent Engine inspects the event store dependency. If you provide a plain EventEngine\\EventStore\\EventStore, the MultiModeStore mode gets disabled. If you pass a EventEngine\\Persistence\\MultiModelStore instead, Event Engine makes use of it automatically.You can pass a MultiModelStore as EventStore because the MultiModelStore is a composition of the event store and document store. Event Store details (@TODO add link) Multi Model Store details (@TODO add link) "},{"id":"https:\/\/event-engine.github.io\/api\/set_up\/di.html#3-1-2-4","title":"LogEngine","content":"Mandatory DependencyTo be able to provide rich logging capabilities, Event Engine requires a EventEngine\\Logger\\LogEngine. The LogEngine is responsible for translating high level logging information into the format required by the low level logger. A PSR-3 compatible low level logger is included in the logging package (@TODO add link)."},{"id":"https:\/\/event-engine.github.io\/api\/set_up\/di.html#3-1-2-5","title":"PSR-11 Container","content":"Mandatory DependencyWhenever a component in the stack requires further dependencies you can configure a service id in the appropriate Description and Event Engine will use that service id to pull the component from the PSR-11 container when needed. Typical components that have dependencies are: Resolvers, ContextProviders and Projectors.A specific container implementation is not required! Anyway, Event Engine wants to keep things simple and straightforward. Therefor, it provides a lightweight container implementation called Discolight. Make sure to try it out. Maybe it's an eye opener ;)."},{"id":"https:\/\/event-engine.github.io\/api\/set_up\/di.html#3-1-2-6","title":"Document Store","content":"Optional DependencyThe EventEngine\\DocumentStore\\DocumentStore is only required if you a) do not use a MultiModelStore and b) use the built-in aggregate projector instead.Learn more about the Document Store and the Aggregate Projector."},{"id":"https:\/\/event-engine.github.io\/api\/set_up\/di.html#3-1-2-7","title":"Event Queue","content":"Optional DependencyNewly recorded events are dispatched automatically by Event Engine within the same PHP process. If you wish to publish them on a message queue instead, provide an implementation of EventEngine\\Messaging\\MessageProducer and Event Engine will forward all recorded events to it.Details about event publishing can be found here (@TODO add link)."},{"id":"https:\/\/event-engine.github.io\/api\/set_up\/production_optimization.html#3-1-3","title":"Production Optimization","content":"Event Engine boots in three phases: description phase, initializing phase, bootstrapping phase.Learn more about the three phases.To speed up the process you can skip the first two phases in production. This page explains how it works."},{"id":"https:\/\/event-engine.github.io\/api\/set_up\/production_optimization.html#3-1-3-1","title":"Warm Cache","content":"The best approach is to warm up the Event Engine cache during deployment. Luckily, Event Engine is already prepared for that scenario. A simple PHP script is sufficient:Example script is taken from a production system#!\/usr\/bin\/env php &lt;?php declare(strict_types=1); chdir(dirname(__DIR__)); require 'vendor\/autoload.php'; \/** @var \\Interop\\Container\\ContainerInterface $container *\/ $container = require 'config\/container.php'; $config = $container-&gt;get('config'); if($config['cache_enabled'] &amp;&amp; $config['cached_config_file']) { \/\/ Thanks to the three phases, we can easily set up Event Engine \/\/ Without the need to pass all dependencies \/\/ This is useful, because we don't want to establish a database connection \/\/ during deployment ... $eventEngine = new \\EventEngine\\EventEngine( $container-&gt;get(\\EventEngine\\Schema\\Schema::class) ); \/\/ ... but only want to load EE Descriptions ... foreach ($config['descriptions'] as $description) { $eventEngine-&gt;load($description); } \/\/ ... and cache the result file_put_contents( $config['cached_config_file'], \"&lt;?php\\nreturn \" . var_export($eventEngine-&gt;compileCacheableConfig(), true) . ';' ); echo sprintf('Event Engine config file \"%s\" saved.', $config['cached_config_file']) . PHP_EOL; } Call the script while preparing the deployment (f.e. when building the production docker image) and include the generated cache file in the build.You can then check for the existence of a cache file when setting up Event Engine.Example factory is again taken from a production system.&lt;?php declare(strict_types=1); namespace Acme\\Infrastructure\\EventEngine; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use EventEngine\\Logger\\LogEngine; use EventEngine\\Messaging\\MessageProducer; use EventEngine\\Persistence\\MultiModelStore; use EventEngine\\Runtime\\Flavour; use EventEngine\\Schema\\Schema; use Interop\\Config\\ConfigurationTrait; use Interop\\Config\\ProvidesDefaultOptions; use Interop\\Config\\RequiresConfig; use Psr\\Container\\ContainerInterface; final class EventEngineFactory { public function __invoke(ContainerInterface $container) : EventEngine { $config = $container-&gt;get('config'); $schema = $container-&gt;get(Schema::class); $flavour = $container-&gt;get(Flavour::class); $multiModelStore = $container-&gt;get(MultiModelStore::class); $logger = $container-&gt;get(LogEngine::class); $messageProducer = null; if ($container-&gt;has(MessageProducer::class)) { $messageProducer = $container-&gt;get(MessageProducer::class); } if($config['cache_enabled'] &amp;&amp; $config['cached_config_file'] &amp;&amp; file_exists($config['cached_config_file'])) { $cachedConfig = require $config['cached_config_file']; $eventEngine = EventEngine::fromCachedConfig( $cachedConfig, $schema, $flavour, $multiModelStore, $logger, $container, null, $messageProducer ); } else { $eventEngine = $this-&gt;createEventEngine($schema, $config['descriptions']); $eventEngine-&gt;initialize($flavour, $multiModelStore, $logger, $container, null, $messageProducer); \/\/ If cache file is missing for whatever reason, recreate it if($config['cache_enabled'] &amp;&amp; $config['cached_config_file']) { file_put_contents( $config['cached_config_file'], \"&lt;?php\\nreturn \" . var_export($eventEngine-&gt;compileCacheableConfig(), true) . ';' ); } } $debug = $container-&gt;get('config')['debug'] ?? false; $eventEngine-&gt;bootstrap($debug ? EventEngine::ENV_DEV : EventEngine::ENV_PROD, $debug); return $eventEngine; } \/** * Returns a minimal event engine instance to generate cache file * * @param Schema $schema * @param string[] $descriptions FQCN[] of EventEngineDescription implementations * @return EventEngine *\/ private function createEventEngine(Schema $schema, array $descriptions): EventEngine { $eventEngine = new EventEngine($schema); foreach ($descriptions as $description) { $eventEngine-&gt;load($description); } \/\/ We use async projections $eventEngine-&gt;disableAutoProjecting(); return $eventEngine; } } "},{"id":"https:\/\/event-engine.github.io\/api\/descriptions.html#3-2","title":"Descriptions","content":"In the previous chapter \"Set Up\" we already learned that Event Engine loads EventEngineDescriptions and passes itself as the only argument to a static describe method.&lt;?php declare(strict_types=1); namespace Prooph\\EventEngine; interface EventEngineDescription { public static function describe(EventEngine $eventEngine): void; } Descriptions need to be loaded before EventEngine::initialize() is called.In the skeleton descriptions are listed in src\/Domain\/DomainServices.php and this list is read by the event engine factory method in src\/ServiceFactory:public function eventEngine($notInitialized = false): EventEngine { if($notInitialized) { $eventEngine = new EventEngine(new OpisJsonSchema()); foreach ($this-&gt;eventEngineDescriptions() as $description) { $eventEngine-&gt;load($description); } return $eventEngine; } $this-&gt;assertContainerIsset(); return $this-&gt;makeSingleton(EventEngine::class, function () { $eventEngine = new EventEngine(new OpisJsonSchema()); foreach ($this-&gt;eventEngineDescriptions() as $description) { $eventEngine-&gt;load($description); } $eventEngine-&gt;initialize( $this-&gt;flavour(), $this-&gt;multiModelStore(), $this-&gt;logEngine(), $this-&gt;container ); return $eventEngine; }); } Organising Descriptions: If you followed the tutorial, you already know that you can avoid code duplication and typing errors with a few simple tricks. Clever combinations of class and constant names can provide readable code without much effort. The skeleton ships with default Event Engine Descriptions to support you with that idea. You can find them in src\/Domain\/Api"},{"id":"https:\/\/event-engine.github.io\/api\/descriptions.html#3-2-1","title":"Registration API","content":"Event Engine provides various registration methods. Those methods can only be called during description phase.See Set Up chapter for details about bootstrap phases.Here is an overview of available methods:&lt;?php declare(strict_types=1); namespace Prooph\\EventEngine; \/\/... final class EventEngine implements MessageDispatcher, AggregateStateStore { \/\/... \/** * Add a command message to the system along with its payload schema *\/ public function registerCommand(string $commandName, PayloadSchema $schema): self { \/\/... } \/** * Add an event message to the system along with its payload schema *\/ public function registerEvent(string $eventName, PayloadSchema $schema): self { \/\/... } \/** * Add a query message to the system along with its payload schema (optional for queries) *\/ public function registerQuery(string $queryName, PayloadSchema $payloadSchema = null): QueryDescription { \/\/... } \/** * Add a data type to the system along with its schema *\/ public function registerResponseType(string $nameOrImmutableRecordClass, ResponseTypeSchema $schema = null): void { \/\/... } \/** * Alias for registerResponseType() *\/ public function registerType(string $nameOrImmutableRecordClass, ResponseTypeSchema $schema = null): void { \/\/... } \/** * Add an input data type to the system along with its schema * * If the schema implemenation distinguishes between input and data types (f.e. a GraphQL implementation) * you can use registerReponseType() and registerInputType() explicitly *\/ public function registerInputType(string $nameOrImmutableRecordClass, InputTypeSchema $schema = null): void { \/\/... } \/** * Service id or instance of a CommandPreProcessor invoked before command is dispatched * * You can register many preprocessors per command. Think of it like a middleware pipeline. * * @param string $commandName * @param string | CommandPreProcessor $preProcessor *\/ public function preProcess(string $commandName, $preProcessor): self { \/\/... } \/** * Service id or callable command controller invoked for command instead of an aggregate * * You can use controllers for non-aggregate business logic, migrations and more * A command can either be handled by an aggregate or a controller. * Event Engine takes care of this. * * @param string $commandName * @param string|callable $controller * @return EventEngine *\/ public function passToController(string $commandName, $controller): self { \/\/... } \/** * Describe handling of a command using returned CommandProcessorDescription *\/ public function process(string $commandName): CommandProcessorDescription { \/\/... } \/** * Service id or callable event listener invoked after event is written to event stream * * @param string $eventName * @param string | callable $listener *\/ public function on(string $eventName, $listener): self { \/\/... } \/** * Describe a projection by using returned ProjectionDescription *\/ public function watch(Stream $stream): ProjectionDescription { \/\/... } \/\/... } "},{"id":"https:\/\/event-engine.github.io\/api\/descriptions.html#3-2-2","title":"Message Payload Schema","content":"Messages are like HTTP requests, but they are protocol agnostic. For HTTP requests\/responses PHP-FIG has defined a standard known as PSR-7. Event Engine messages on the other hand are similar to prooph\/common messages.Like HTTP requests messages should be validated before doing anything with them. It can become a time consuming task to write validation logic for each message by hand. Hence, Event Engine has a built-in way to validate messages using a Schema (@TODO add link).The package event-engine\/php-json-schema provides a Json Schema Draft 6 compatible implementation.You can use JsonSchema wrapper objects. Those objects are easy to use and drastically improve readability of the code.Here is a command registration example:$eventEngine-&gt;registerCommand( self::REGISTER_USER, JsonSchema::object([ Payload::USER_ID =&gt; Schema::userId(), Payload::USERNAME =&gt; Schema::username(), Payload::EMAIL =&gt; Schema::email(), ]) ); This code speaks for itself, doesn't it? Once you're used to it you can add new messages to the system in less than 30 seconds. The chapter about Json Schema (@TODO add link) covers all the details. Make sure to check it out.A nice side effect of this approach is out-of-the-box Swagger UI support. Learn more about it in the Swagger UI (@TODO add link) chapter."},{"id":"https:\/\/event-engine.github.io\/api\/descriptions.html#3-2-3","title":"Command Registration","content":"Event Engine needs to know which commands can be processed by the system. Therefor, you have to register them before defining processing logic.Software developed with Event Engine follows a Command-Query-Responsibility-Segregation (short CQRS) approach. Commands are used to trigger state changes without returning modified state and queries are used to request current state without modifying it.You're ask to tell Event Engine a few details about available commands. Each command should have a unique name and a payload schema. It is recommended to add a context as prefix in front of each command name. Let's take an example from the tutorial but add a context to the command name:&lt;?php declare(strict_types=1); namespace App\\Api; use Prooph\\EventEngine\\EventEngine; use Prooph\\EventEngine\\EventEngineDescription; use Prooph\\EventEngine\\JsonSchema\\JsonSchema; class Command implements EventEngineDescription { const CMD_CXT = 'BuildingMgmt.'; const ADD_BUILDING = self::CMD_CXT.'AddBuilding'; \/** * @param EventEngine $eventEngine *\/ public static function describe(EventEngine $eventEngine): void { $eventEngine-&gt;registerCommand( Command::ADD_BUILDING, JsonSchema::object( [ 'buildingId' =&gt; JsonSchema::uuid(), 'name' =&gt; JsonSchema::string()-&gt;withMinLength(2) ] ) ); } } Event Engine makes no assumptions about the format of the name. A common approach is to use a dot notation to separate context from message name e.g. BuildingMgmt.AddBuilding. Using dot notation has the advantage that message broker like RabbitMQ can use it for routing."},{"id":"https:\/\/event-engine.github.io\/api\/descriptions.html#3-2-4","title":"Command Processing","content":"Once Event Engine knows about a command you can register processing logic for it. Commands are processed by aggregate functions. Think of an aggregate as a process with multiple steps. Each step is triggered by a command and there is only one active step for a specific process aka. aggregate at the same time.In Event Engine aggregate functions are stateless. You can use plain PHP functions or classes with static public methods.Before we dive deeper into aggregate functions, let's have a look at how commands are processed. The following gif shows a CommandProcessingDescription.A fluent interface mixed with clever class and constant naming + modern IDE support (PHPStorm in this case) can assist you while putting together the pieces. You need to remember less which frees your mind to reason more about the logic you're developing. This results in a higher quality business logic, written in a shorter time. Try it yourself. It's actually a lot of fun to work with Event Engine.Keep an eye on the array callable syntax: [ShoppingCart::class, 'addItem']. PHPStorm provides code completion for it and respects it while renaming methods and classes. That's an awesome feature and makes the syntax save to use.Event Engine Descriptions keep glue code outside of the core business logic. This reduces \"noise\" in the core and creates a central overview for navigation through the code.Let's go through the CommandProcessingDescription step by step."},{"id":"https:\/\/event-engine.github.io\/api\/descriptions.html#3-2-4-1","title":"process()","content":"The process(string $commandName) method takes a command name as input and starts a CommandProcessingDescription for that command.If the command is not registered or a second processing description exists for it, Event Engine raises an exception. There can always only be one handler for a command be it an aggregate or a controller. You can only attach multiple command preprocessors to the same command.$eventEngine-&gt;process(Command::START_SHOPPING_SESSION) "},{"id":"https:\/\/event-engine.github.io\/api\/descriptions.html#3-2-4-2","title":"withNew()","content":"Event Engine Descriptions are really meant to be descriptive. This way you can internalize the required steps to build a CQRS \/ ES system. The descriptions also serve as documentation. A developer new to the system just needs to read them to get an idea of the structure and business logic.That said, description methods are named to form a sentence. If a command should create a new aggregate use withNew(string $aggregateType) after process() and pass the aggregate type as an argument:$eventEngine-&gt;process(Command::START_SHOPPING_SESSION) -&gt;withNew(Aggregate::SHOPPING_CART) "},{"id":"https:\/\/event-engine.github.io\/api\/descriptions.html#3-2-4-3","title":"identifiedBy()","content":"If a new aggregate should be created, you have to tell Event Engine which command property contains the aggregate identifier. This is done with identifiedBy(string $identifierPropName):$eventEngine-&gt;process(Command::START_SHOPPING_SESSION) -&gt;withNew(Aggregate::SHOPPING_CART) -&gt;identifiedBy(Payload::SHOPPING_CART_ID) You can omit identifiedBy() in further CommandProcessingDescriptions addressing the same aggregate type as long as all commands and events always contain the same aggregate identifier property. If this is not the case, you can also add identifiedBy() after withExisting() to define an alternative property name for the specific command and related events.If you omit identifiedBy() at all, Event Engine uses the default property name id and throws an exception if the command does not contain it."},{"id":"https:\/\/event-engine.github.io\/api\/descriptions.html#3-2-4-4","title":"withExisting()","content":"Like the name suggests, withExisting(string $aggregateType) should be used if a command addresses an existing aggregate. Event Engine will use the aggregate type and the identifier property from the command to look up the aggregate and bring it into current state ready to handle the command.Loading aggregates is managed by Event Engine internally. No command handlers or repositories required.$eventEngine-&gt;process(Command::ADD_ITEM) -&gt;withExisting(Aggregate::SHOPPING_CART) "},{"id":"https:\/\/event-engine.github.io\/api\/descriptions.html#3-2-4-5","title":"provideContext()","content":"provideContext(string $providerServiceId) allows you to attach a context provider to the command. It should be a service id. Event Engine pulls the context provider from the PSR-11 container.$eventEngine-&gt;process(Command::ADD_ITEM) -&gt;withExisting(Aggregate::SHOPPING_CART) -&gt;provideContext(AddItemContextProvider::class) Aggregate functions should not have any side effects. This is explained in the Functional Core chapter. But to make decisions like: \"Should a command be handled or not and in what way?\" - an aggregate sometimes requires information not included in its own state. This information needs to be loaded either from an external system or a database. To keep aggregates focused on the business logic, external information should be loaded beforehand. A context provider takes care of loading information. It can manage communication, deal with errors and caching. Once loaded, the information is handed over as context to the aggregate function.While Event Engine makes no assumptions about the context format, it is highly recommended to only use immutable objects as contexts. In rare cases it might be required to pass a data resolver down to the aggregate, f.e. if the aggregate needs to decide if external data is really needed and fetching it beforehand is too costly. You can use a context object to pass dependencies into aggregate functions. But use it with care!"},{"id":"https:\/\/event-engine.github.io\/api\/descriptions.html#3-2-4-6","title":"handle()","content":"handle(callable $aggregateFunc) takes a callable as input. This is usually the aggregate function responsible for handling the command.$eventEngine-&gt;process(Command::ADD_ITEM) -&gt;withExisting(Aggregate::SHOPPING_CART) -&gt;provideContext(AddItemContextProvider::class) -&gt;handle([ShoppingCart::class, 'addItem']) The recommended approach is to group aggregate functions in classes using static class methods. This way, you can use PHP's array callable syntax like shown in the example. Thanks to the syntax, Event Engine can cache the Description. If you pass a Closure to handle(), caching won't work, because closures can't be exported. Event Engine takes care of that limitation and throws an exception if needed.If you use the OopFlavour please refer to the OopFlavour tutorial part. It explains how to describe command processing when aggregate functions are not stateless."},{"id":"https:\/\/event-engine.github.io\/api\/descriptions.html#3-2-4-7","title":"recordThat() &amp; apply()","content":"Tell Event Engine what possible events are yielded for a command using recordThat(string $eventName) or one of the aliases andRecordThat(string $eventName) or orRecordThat(string $eventName). Every recordThat() call should be followed by an apply(callable $eventApplyFunc) call, which takes a callable aggregate apply function for the event as argument.$eventEngine-&gt;process(Command::ADD_ITEM) -&gt;withExisting(Aggregate::SHOPPING_CART) -&gt;provideContext(AddItemContextProvider::class) -&gt;handle([ShoppingCart::class, 'addItem']) -&gt;recordThat(Event::ITEM_ADDED) -&gt;apply([ShoppingCart::class, 'whenItemAdded']) -&gt;andRecordThat(Event::FREE_SHIPPING_ENABLED) -&gt;apply([ShoppingCart::class, 'whenFreeShippingEnabled']); The aggregate handle function doesn't need to yield all specified events each time and the recordThat aliases are only defined for better readability. The important thing is, that Event Engine knows all events and their corresponding apply functions."},{"id":"https:\/\/event-engine.github.io\/api\/descriptions.html#3-2-4-8","title":"storeStateIn()","content":"storeStateIn(string $collection) tells Event Engine to store the aggregate state in the specified document store collection. This description only takes effect when using a Multi-Model-Store (@TODO add link). It can only be used when describing command processing for a NEW aggregate:$eventEngine-&gt;process(Command::START_SHOPPING_SESSION) -&gt;withNew(Aggregate::SHOPPING_CART) -&gt;identifiedBy(Payload::SHOPPING_CART_ID) -&gt;storeStateIn('shopping_carts') \/\/ ... If you don't specify a collection, Event Engine defaults to:$aggregateCollection = AggregateProjector::aggregateCollectionName( '0.1.0', \/\/ &lt;- Default projection version Aggregate::SHOPPING_CART \/\/ &lt;- Aggregate type of command processing description ); echo $aggregateCollection; \/\/ em_ds_shopping_cart_0_1_0 Make sure to create the collection upfront! It is NOT created automatically by Event Engine. The tutorial provides some guidance."},{"id":"https:\/\/event-engine.github.io\/api\/descriptions.html#3-2-4-9","title":"storeEventsIn()","content":"By default, Event Engine writes all events into its WriteModelStream. If you wish to write events for a certain aggregate type into a separate stream, you can use storeEventsIn(string $streamName). Like storeStateIn(), you can define an alternative stream only when describing command processing for a new aggregate.$eventEngine-&gt;process(Command::START_SHOPPING_SESSION) -&gt;withNew(Aggregate::SHOPPING_CART) -&gt;identifiedBy(Payload::SHOPPING_CART_ID) -&gt;storeStateIn('shopping_carts') -&gt;storeEventsIn('shopping_cart_history') \/\/ ... You need to take care of creating alternative event streams. The skeleton includes an example script. Just change the stream name."},{"id":"https:\/\/event-engine.github.io\/api\/descriptions.html#3-2-5","title":"passToController()","content":"If you don't want to handle a command with an aggregate, you can pass it to a command controller (@TODO add link) instead:$eventEngine-&gt;passToController(MyCommandController::class); The controller instance is pulled from the PSR-11 container using the service id handed over to passToController().A command can either be handled by a controller or an aggregate, but not both. A command always has one handler only."},{"id":"https:\/\/event-engine.github.io\/api\/descriptions.html#3-2-6","title":"Event Registration","content":"Event registration works similar to command registration described above. Before you can reference events in command processing descriptions they need to be known by Event Engine. This mechanism protects you from silly mistakes like misspelling an event name or forgetting to define a schema for it.$eventEngine-&gt;registerEvent( self::USER_REGISTERED, JsonSchema::object([ Payload::USER_ID =&gt; Schema::userId(), Payload::USERNAME =&gt; Schema::username(), Payload::EMAIL =&gt; Schema::email(), ]) ); "},{"id":"https:\/\/event-engine.github.io\/api\/descriptions.html#3-2-7","title":"Attach Process Manager","content":"One of the strengths of Event Sourcing is the ability to automate processes using an Event-Driven approach. This means, that follow up actions can be triggered when certain events occur. Those automatic triggers are called process managers. Here is an example how you attach a process manager to an event:$eventEngine-&gt;on(Event::USER_REGISTERED, SendWelcomeEmail::class); If a process manager has dependencies, pass a service id to $eventEngine-&gt;on() so that it is pulled from the PSR-11 container. A stateless process manager that listens on an event to dispatch a new command, can be provided as a callable. It's recommended to use the array callable syntax like discussed for aggregate functions.Let's look at an example:Whenever an order was placed the system should generate an invoice.final class GenerateInvoiceTrigger { public static function onOrderPlaced(Message $orderPlaced): array { return [ Command::GENERATE_INVOICE, [ Payload::ORDER_ID =&gt; $orderPlaced-&gt;get(Payload::ORDER_ID) ] ]; } } A process manager can return a command using the \"short message syntax\" of Event Engine. The command is automatically dispatched by Event Engine. The only thing we need to do is to attach the process manager function to the correct event:$eventEngine-&gt;on(Event::ORDER_PLACED, [GenerateInvoiceTrigger::class, 'onOrderPlaced']); @TODO Describe query, type and projection registration"},{"id":"https:\/\/event-engine.github.io\/api\/functional_core.html#3-3","title":"Functional Core","content":" Event Sourced Aggregates are Domain-Driven Aggregates, representing a unit of consistency. They protect invariants. This basically means that an aggregate makes sure that it can transition to a new state. Different business rules can permit or prevent state transitions, and the aggregate has to enforce these business rules. Source: http:\/\/docs.getprooph.org\/tutorial\/event_sourcing_basics.html#1-3-3"},{"id":"https:\/\/event-engine.github.io\/api\/functional_core.html#3-3-1","title":"Functions vs. Objects","content":"Event Engine supports three programming styles out-of-the-box: OopFlavour, PrototypingFlavour and FunctionalFlavour.On this page we focus on the Prototyping and Functional Flavour. Both follow the same idea of a functional core. Event Sourcing is heavily based on functional patterns: immutable events, append-only streams, left fold of past events to calculate current state, ...The difference between Prototyping and Functional is that the PrototypingFlavour uses generic Event Engine messages while the FunctionalFlavour is 100% decoupled from Event Engine. Code examples shown here are based on the PrototypingFlavour. If you're curious how you can switch to another Flavour, then check out the Event Engine tutorial. It covers all three Flavours in detail.Event Engine grows with your application from prototype to MVP up to a rock solid production system. And it is able to reduce boilerplate code to a bare minimum. You have to follow some rules, though:"},{"id":"https:\/\/event-engine.github.io\/api\/functional_core.html#3-3-2","title":"1. Pure Functions","content":"Given the same input a pure function will always produce the same result.Here is the simplest form of a pure aggregate function in Event Engine:"},{"id":"https:\/\/event-engine.github.io\/api\/functional_core.html#3-3-2-1","title":"prooph\/micro style","content":"\/\/some_business_process.php declare(strict_types=1); Namespace Acme\\Model\\SomeBusinessProcess; use EventEngine\\Messaging\\Message; use Acme\\Api\\Event; const startProcess = '\\Acme\\SomeBusinessProcess\\startProcess'; function startProcess(Message $startProcess): \\Generator { yield [Event::SOME_PROCESS_STARTED, $startProcess-&gt;payload()]; } \/\/More functions .... "},{"id":"https:\/\/event-engine.github.io\/api\/functional_core.html#3-3-2-2","title":"Static method style","content":"\/\/SomeBusinessProcess.php declare(strict_types=1); Namespace Acme\\Model; use EventEngine\\Messaging\\Message; use Acme\\Api\\Event; final class SomeBusinessProcess { public static function startProcess(Message $startProcess): \\Generator { yield [Event::SOME_PROCESS_STARTED, $startProcess-&gt;payload()]; } \/\/more methods .... } As you can see both approaches are very similar. The prooph\/micro style looks more functional and underlines the intention of the code whereby the static method approach plays nice together with a modern IDE and PHP's autoloading. We'll stick to the static method approach in the examples because this is the recommended style when working with Event Engine. But prooph\/micro style can be used, too!Back to the pure nature of both approaches. No matter how often you call the function as long as the input message does not change, the yielded event won't change, too.This property makes testing the function a breeze. You don't need mocks. You don't need heavy fixture setup. Just create the appropriate message, call the function and test against an expected event."},{"id":"https:\/\/event-engine.github.io\/api\/functional_core.html#3-3-3","title":"2. Stateless Functions","content":"No object, no internal state and therefor a much simpler business logic implementation, which is easy to test, refactor and maintain!But even if we use functions, we have to be careful to not fall into the trap of modifying state:Evil Global VariableOne way to break the rule with a function is by modifying global state.\/\/SomeBusinessProcess.php declare(strict_types=1); Namespace Acme\\Model; use EventEngine\\Messaging\\Message; use Acme\\Api\\Event; $evilState = new EvilState(); final class SomeBusinessProcess { public static function startProcess(Message $startProcess): \\Generator { global $evilState; $evilState-&gt;burnStatelessApproach(); yield [Event::SOME_PROCESS_STARTED, $startProcess-&gt;payload()]; } \/\/more methods .... } Never ever do this! Don't even think about it!Evil Static PropertyAnother way to break our stateless function:\/\/SomeBusinessProcess.php declare(strict_types=1); Namespace Acme\\Model; use EventEngine\\Messaging\\Message; use Acme\\Api\\Event; final class SomeBusinessProcess { private static $evilState; public static function startProcess(Message $startProcess): \\Generator { self::$evilState = new EvilState(); yield [Event::SOME_PROCESS_STARTED, $startProcess-&gt;payload()]; } public static function continueProcess(Message $continue): \\Generator { yield [Event::SOME_PROCESS_CONTINUED, self::$evilState-&gt;toArray()]; } \/\/more methods .... } Evil Static Local VariableThat's also a very bad idea:\/\/SomeBusinessProcess.php declare(strict_types=1); Namespace Acme\\Model; use EventEngine\\Messaging\\Message; use Acme\\Api\\Event; final class SomeBusinessProcess { public static function startProcess(Message $startProcess): \\Generator { yield [Event::SOME_PROCESS_STARTED, $startProcess-&gt;payload()]; } public static function continueProcess(Message $continue): \\Generator { static $evilCounter; if($evilCounter === null) { $evilCounter = 0; } yield [Event::SOME_PROCESS_CONTINUED, ['counter' =&gt; ++$evilCounter]]; } \/\/more methods .... } Evil Mutable State Passed As ArgumentMutable state passed as an argument is probably the easiest way to break the stateless rule. Let's look at an evil example first and then we'll see how we can do better.\/\/SomeBusinessProcess.php declare(strict_types=1); Namespace Acme\\Model; use EventEngine\\Messaging\\Message; use Acme\\Api\\Event; final class SomeBusinessProcess { public static function startProcess(Message $startProcess): \\Generator { yield [Event::SOME_PROCESS_STARTED, $startProcess-&gt;payload()]; } public static function continueProcess(EvilMutableState $evilState, Message $continue): \\Generator { $evilState-&gt;burnStatelessApproach(); yield [Event::SOME_PROCESS_CONTINUED, ['state' =&gt; $evilState-&gt;toArray()]]; } \/\/more methods .... } Let's fight the evil!\/\/SomeBusinessProcess.php declare(strict_types=1); Namespace Acme\\Model; use EventEngine\\Messaging\\Message; use Acme\\Api\\Event; use Acme\\Api\\Payload; final class SomeBusinessProcess { public static function startProcess(Message $startProcess): \\Generator { yield [Event::SOME_PROCESS_STARTED, $startProcess-&gt;payload()]; } public static function whenProcessStarted(Message $processStarted): ImmutableState { return new ImmutableState(); } public static function continueProcess(ImmutableState $state, Message $continue): \\Generator { if($state-&gt;wantsToBurnStatelessApproach()) { yield [Event::STATE_MUTATION_BLOCKED, [Payload::ALTERNATIVE =&gt; $continue-&gt;get(Payload::ALTERNATIVE)]]; } } public static function whenStateMutationBlocked(ImmutableState $currentState, Message $stateMutationBlocked): ImmutableState { return $currentState-&gt;withAlternativeMutation($stateMutationBlocked-&gt;get(Payload::ALTERNATIVE)); } } Ok, we see two new functions here. Both start with when followed by an event name.Note: The naming is only a recommendation.Those when functions do not take commands as input and do not yield events, but instead take yielded events as input and return (note the difference to yield) ImmutableState. The second when function even takes ImmutableState as an argument and returns it.To be able to understand the alternative to mutable state we have to jump into the method withAlternativeMutation:declare(strict_types=1); Namespace Acme\\Model; final class ImmutableState { private $alternative; public function alternative(): ?string { return $this-&gt;alternative; } public function withAlternativeMutation(string $alternative): self { $copy = clone $this; $copy-&gt;alternative = $alternative; return $copy; } } This is how state of an immutable object is changed. Instead of modifying internal state directly, the value object copies itself and modifies the copy instead.It works because visibility of properties and methods is defined on class level and not on instance level.Let's look at the effect with a unit test:declare(strict_types=1); Namespace AcmeTest\\Model; use Acme\\Api\\Event; use Acme\\Api\\Payload; use Acme\\Model\\SomeBusinessProcess; use Acme\\Model\\ImmutableState; use AcmeTest\\BaseTestCase; \/\/&lt;-- extends PHPUnit\\Framework\\TestCase + provides message factory use EventEngine\\Messaging\\Message; final class SomeBusinessProcessTest extends BaseTestCase { \/** * @test *\/ public function it_does_not_change_input_state() { $inputState = new ImmutableState(); $this-&gt;assertNull($inputState-&gt;alternative()); $event = $this-&gt;messageFactory()-&gt;createMessageFromArray( Event::STATE_MUTATION_BLOCKED, [ 'payload' =&gt; [ 'alternative' =&gt; 'modify and return copy' ] ] ); $outputState = SomeBusinessProcess::whenStateMutationBlocked( $inputState, $event ); $this-&gt;assertNull($inputState-&gt;alternative()); $this-&gt;assertSame( 'modify and return copy', $outputState-&gt;alternative() ); } } Working with immutable state avoids a whole bunch of silly and hidden errors. Function calls are predictable. You can harden the system With simple tests, pave the way for refactorings and keep velocity high. Event Engine also has an easy job. It does not need to care about state changes, because they are fully managed in userland code. This means, that you have full control. No object mapping layer required, no dirty state and no unit of work.The Immutable State chapter provides a lot of tips and tricks to rapidly create and work with immutable value objects."},{"id":"https:\/\/event-engine.github.io\/api\/functional_core.html#3-3-4","title":"3. Side-Effect Free Functions","content":"Modifying global state is one kind of side-effect, I\/O is another. I\/O is the short term for Input\/Output and includes things like reading from or writing to a database, accessing the filesystem or calling a remote service. It describes any operation that might fail due to unavailability of the target system. If a function (or method) performs a database query but the database is down, the function will behave different than in normal cases. Hence, the result of the function call is not predictable.Side-Effects make testing harder. Performing I\/O usually requires mocking and you have to test against more scenarios. That's a bad situation specifically for business logic tests. When testing business logic you should focus on its behaviour and only on that! Mixing I\/O into the game makes it difficult.If we must not query a database or call a remote service in aggregate functions, where do we do it then? Well, outside of the functional core. The following diagram illustrates that idea.The diagram shows three layers. The outermost layer is where I\/O happens. Event Engine acts as a middleware between I\/O layer and the functional core."},{"id":"https:\/\/event-engine.github.io\/api\/functional_core.html#3-3-5","title":"Read I\/O","content":"We can tell Event Engine to invoke a ContextProvider before invoking an aggregate function. That's the preferred way to perform read I\/O to query data needed by the aggregate.&lt;?php declare(strict_types=1); namespace EventEngine\\Aggregate; use EventEngine\\Messaging\\Message; interface ContextProvider { \/** * @param Message $command * @return mixed The context passed as last argument to aggregate functions *\/ public function provide(Message $command); } Let's say we have a shopping cart aggregate that processes AddItem commands. The command payload only contains the itemId but we also need the price of the item to enable free shipping if a certain order sum is reached.Context Provider: uses a price finder to get item price from a database and sets up a free shipping policy with 40,- \u00e2\u0082\u00ac (4000 Cent) as minimum order sum.&lt;?php declare(strict_types=1); namespace ProophExample\\ContextProvider; use EventEngine\\Aggregate\\ContextProvider; use EventEngine\\Messaging\\Message; use ProophExample\\ContextProvider\\Api\\Payload; use ProophExample\\ContextProvider\\Policy\\FreeShipping; use ProophExample\\ContextProvider\\ShoppingCart\\AddItemContext; final class AddItemContextProvider implements ContextProvider { \/** * @var PriceFinder *\/ private $priceFinder; \/** * @param Message $command * @return mixed The context passed as last argument to aggregate functions *\/ public function provide(Message $command) { $itemId = ItemId::fromString($command-&gt;get(Payload::ITEM_ID)); $itemPrice = $this-&gt;priceFinder-&gt;findItemPrice($itemId); $item = Item::withIdAndPrice($itemId, $itemPrice); $freeShipping = FreeShipping::fromInt(4000); return AddItemContext::fromRecordData(['item' =&gt; $item, 'freeShipping' =&gt; $freeShipping]); } } Command Processing Description: AddItemContextProvider service id (FQCN) is passed to provideContext.&lt;?php declare(strict_types=1); namespace ProophExample\\ContextProvider\\Api; use EventEngine\\EventEngine; use EventEngine\\EventEngineDescription; use ProophExample\\ContextProvider\\AddItemContextProvider; use ProophExample\\ContextProvider\\ShoppingCart; final class Aggregate implements EventEngineDescription { const SHOPPING_CART = 'ShoppingCart'; public static function describe(EventEngine $eventEngine): void { \/\/... $eventEngine-&gt;process(Command::ADD_ITEM) -&gt;withExisting(self::SHOPPING_CART) -&gt;provideContext(AddItemContextProvider::class) -&gt;handle([ShoppingCart::class, 'addItem']) -&gt;recordThat(Event::ITEM_ADDED) -&gt;apply([ShoppingCart::class, 'whenItemAdded']) -&gt;andRecordThat(Event::FREE_SHIPPING_ENABLED) -&gt;apply([ShoppingCart::class, 'whenFreeShippingEnabled']); } } Shopping Cart Aggregate: receives AddItemContext as third argument in the addItem function&lt;?php declare(strict_types=1); namespace ProophExample\\ContextProvider; use EventEngine\\Messaging\\Message; use ProophExample\\ContextProvider\\Api\\Event; use ProophExample\\ContextProvider\\Api\\Payload; use ProophExample\\ContextProvider\\ShoppingCart\\AddItemContext; use ProophExample\\ContextProvider\\ShoppingCart\\State; final class ShoppingCart { \/\/... public static function addItem(State $cart, Message $addItem, AddItemContext $context): \\Generator { yield [Event::ITEM_ADDED, [ Payload::SHOPPING_CART_ID =&gt; $addItem-&gt;get(Payload::SHOPPING_CART_ID), Payload::ITEM =&gt; $context-&gt;item()-&gt;toArray(), ]]; if(!$cart-&gt;freeShipping()) { \/\/Temporarily add item. We can safely do this, because $cart is immutable $cart = $cart-&gt;withAddedItem($context-&gt;item()); if($context-&gt;freeShipping()-&gt;isFree($cart-&gt;orderSum())) { yield [Event::FREE_SHIPPING_ENABLED, [ Payload::SHOPPING_CART_ID =&gt; $addItem-&gt;get(Payload::SHOPPING_CART_ID), ]]; } } } public static function whenItemAdded(State $cart, Message $itemAdded): State { return $cart-&gt;withAddedItem(Item::fromArray($itemAdded-&gt;get(Payload::ITEM))); } public static function whenFreeShippingEnabled(State $cart, Message $freeShippingEnabled): State { return $cart-&gt;withFreeShippingEnabled(); } } "},{"id":"https:\/\/event-engine.github.io\/api\/functional_core.html#3-3-6","title":"Write I\/O","content":"Event Engine appends all yielded events to the write model event stream. You don't need to care about that. Read model updates are performed by projections (@TODO add link) or the Multi-Model-Store (@TODO add link) and all other Write I\/O should happen in event listeners (@TODO add link).Aggregate functions should NEVER perform any write operation directly but only yield events to trigger Write I\/O in the outermost layer."},{"id":"https:\/\/event-engine.github.io\/api\/functional_core.html#3-3-7","title":"Aggregate Lifecycle","content":"If an aggregate is composed of pure functions and those functions work with immutable state only, does the aggregate have a lifecycle?Yes! An aggregate has a lifecycle. It is just not implemented as an object that changes internal state over time. But an aggregate is still a domain concept - a business process. Each aggregate has a unique id and yielded events should contain that id (otherwise Event Engine throws an exception) so that the events can be added to the event stream of the aggregate. An event stream can be seen as a timeline. It tracks all important facts about the aggregate.But how can Event Engine always pass the current state of an aggregate to the next function?It seems like aggregate state is magically passed to aggregate functions. But the mechanism used by Event Engine is relatively simple. It is best explained with our shopping cart example again.$eventEngine-&gt;process(Command::START_SHOPPING_SESSION) -&gt;withNew(self::SHOPPING_CART) -&gt;identifiedBy(Payload::SHOPPING_CART_ID) Event Engine gets two important information here. The first one is that the lifecycle of our ShoppingCart aggregate begins with a StartShoppingSession command. And the second is that a ShoppingCart is identified by its ShoppingCartId. All commands addressing the shopping cart should contain the ShoppingCartId and all events yielded by the aggregate should contain the same id.$eventEngine-&gt;process(Command::START_SHOPPING_SESSION) -&gt;withNew(self::SHOPPING_CART) -&gt;identifiedBy(Payload::SHOPPING_CART_ID) -&gt;handle([ShoppingCart::class, 'startShoppingSession']) Given the information above, Event Engine knows that the aggregate function ShoppingCart::startShoppingSession() only takes a StartShoppingSession command as argument.Aggregate state doesn't exist at this time because it's the first command.&lt;?php \/\/... final class ShoppingCart { public static function startShoppingSession(Message $startShoppingSession): \\Generator { yield [Event::SHOPPING_SESSION_STARTED, [ Payload::SHOPPING_CART_ID =&gt; $startShoppingSession-&gt;get(Payload::SHOPPING_CART_ID), ]]; } \/\/... } Event Engine will append the yielded ShoppingSessionStarted event to its write model event stream. This event will mark the beginning of a new shopping cart lifecycle.Every yielded event should have a corresponding apply function. Event Engine takes care of that rule. It's the last part of every CommandProcessingDescription.$eventEngine-&gt;process(Command::START_SHOPPING_SESSION) -&gt;withNew(self::SHOPPING_CART) -&gt;identifiedBy(Payload::SHOPPING_CART_ID) -&gt;handle([ShoppingCart::class, 'startShoppingSession']) -&gt;recordThat(Event::SHOPPING_SESSION_STARTED) -&gt;apply([ShoppingCart::class, 'whenShoppingSessionStarted']); A recordThat call should always be followed by an apply call. Obvousely, it's a mapping so that Event Engine knows which apply function to use. And because the entire description is bound to the command being processed, Event Engine knows again that ShoppingCart::whenShoppingSessionStarted is the first apply function and therefor does not take aggregate state as an argument. But the apply function should return the first immutable state derived from the first event.&lt;?php \/\/... final class ShoppingCart { \/\/... public static function whenShoppingSessionStarted(Message $shoppingSessionStarted): State { return State::newSession(ShoppingCartId::fromString( $shoppingSessionStarted-&gt;get(Payload::SHOPPING_CART_ID) )); } } All subsequent aggregate functions (command handling and event applying functions) receive the current aggregate state as the first argument.The following diagram illustrates how Event Engine calculates current state with the help of the apply functions."},{"id":"https:\/\/event-engine.github.io\/api\/functional_core.html#3-3-8","title":"RecordThat","content":"The CommandProcessingDescription defines two aliases for recordThat: andRecordThat and orRecordThat. You can use them when an aggregate function yields multiple events (andRecordThat) or different events depending on conditions (orRecordThat).Event Engine doesn't really care about which variant you use, but if an aggregate function yields an unknown event (no recordThat-&gt;apply pair defined) Event Engine will throw an exception.$eventEngine-&gt;process(Command::ADD_ITEM) -&gt;withExisting(self::SHOPPING_CART) -&gt;provideContext(AddItemContextProvider::class) -&gt;handle([ShoppingCart::class, 'addItem']) -&gt;recordThat(Event::ITEM_ADDED) -&gt;apply([ShoppingCart::class, 'whenItemAdded']) -&gt;andRecordThat(Event::FREE_SHIPPING_ENABLED) -&gt;apply([ShoppingCart::class, 'whenFreeShippingEnabled']); It's not required that all events are yielded each time. The important thing is that Event Engine knows about them all.In some situations an aggregate function does not want to yield any new event. In such a case you can yield null and return from the function.&lt;?php \/\/... final class ShoppingCart { \/\/... public static function removeItem(State $cart, Message $removeItem): \\Generator { $item = Item::fromArray($removeItem-&gt;get(Payload::ITEM)); if(!$cart-&gt;hasItem($item)) { yield null; return; } yield [Event::ITEM_REMOVED, $removeItem-&gt;payload()]; } } Wrap UP: Aggregates in Event Engine are composed of pure functions and immutable state (when using Prototyping or Functional Flavour). Command Processing Descriptions tell Event Engine how the pieces fit together. This reduces boilerplate code and we can focus on the domain and avoid silly bugs that interrupt our model exploration."},{"id":"https:\/\/event-engine.github.io\/api\/immutable_state.html#3-4","title":"Immutable State","content":"Using immutable objects whenever possible results in robust implementations. Function calls and state changes become predictable. Using value objects instead of raw data structures like arrays or plain strings adds type safety, acts as documentation and makes code much more readable. All very important properties for long-lived applications that are constantly reshaped.The EventEngine\\Data package provides useful helpers to speed up development of immutable objects. In fact, when using the Prototyping or Functional Flavour all application state should be immutable.For the OOP Flavour the only exception are Aggregate Roots. But even then it's recommended to use a single internal state property within the AR that references immutable state and is the only mutable part of the object."},{"id":"https:\/\/event-engine.github.io\/api\/immutable_state.html#3-4-1","title":"PHPStorm Templates","content":"Writing immutable value objects in PHP is painful because you need a lot of boilerplate code and always have the risk to introduce bugs due to typos.Libraries like FPP aim to simplify the task of writing immutable objects and combine them to complex structures.FPP works quite well and you can use it together with Event Engine.However, if you don't want to learn another meta language but still want to avoid writing all the boilerplate that comes along with immutable objects, EventEngine\\Data combined with PHPStorm Live Templates might be for you.Keep in mind that both FPP and EventEngine\\Data are only suggestions. You don't have to use them. It's also fine if you prefer working with a serializer library.The EventEngine\\Data package contains a set of live templates specifically designed to work together with the EventEngine\\Data\\ImmutableRecord.You can import the templates by following official PHPStorm instructions. Please find the settings.zip here."},{"id":"https:\/\/event-engine.github.io\/api\/immutable_state.html#3-4-2","title":"Scalar Value Objects","content":"Each scalar PHP type (string, int, float, bool) has a corresponding template that you can access by typing vo_&lt;scalar type&gt; in a PHP file. Create an empty value object class. Invoke the template in the class body. Define the name of the inner property. See examples: vo_string vo_int vo_float vo_bool  "},{"id":"https:\/\/event-engine.github.io\/api\/immutable_state.html#3-4-3-1","title":"vo_uuid","content":"A UUID value object template is included, too. It works with the well known ramsey\/uuid library. Along with the vo_uuid template you also get a use_uuid template. Use them in combination like shown in the example:"},{"id":"https:\/\/event-engine.github.io\/api\/immutable_state.html#3-4-3-2","title":"vo_datetime","content":"The vo_datetime is another specialized scalar value object template. It uses PHP's built-in \\DateTimeImmutable, ensures UTC is used as well as a standard format for from\/to string conversion.The FORMAT constant can be used to change the format. By default it is 'Y-m-d\\TH:i:s.u, which is the same format as of the Message::createdAt property."},{"id":"https:\/\/event-engine.github.io\/api\/immutable_state.html#3-4-4","title":"List \/ Collection","content":"If you need a list or collection with all items being of the same type you can use the vo_collection template. It generates quite a lot of code so that you can work with the list out-of-box. Feel free to add more methods, either to the template or after code generation if it is specific to the concrete class.The template needs two information: The item class. The item class should at least have a public static from&lt;RawType&gt;($rawType) method, a public to&lt;RawType&gt;() method and a public equals(ItemClass $other): bool method. Of course all immutable objects generated with our VO templates can be used as item class. The raw type of the items, one of: string, int, float, bool, array If you use the push() and pop() methods, keep in mind that the list is immutable. That said, only the returned list contains the change (item appended, last item removed). This also means, that you have to use last() before pop() to get the last item of the list."},{"id":"https:\/\/event-engine.github.io\/api\/immutable_state.html#3-4-5","title":"Complex Types","content":"Immutable objects can have arbitrary complexity. So far we only learned about single value objects and lists. What's missing is the ability to combine them to complex objects\/types. A simple PHPStorm Live Template is not suitable for the job. Hence, EventEngine\\Data provides the interface ImmutableRecord and the trait ImmutableRecordLogic to help you out.When you use PHPStorm and import the settings.zip linked above, you have a new file template ImmutableRecord that you can choose when adding a new class to the project. The template for getter methods is also aligned. ImmutableRecord requires getter methods that exactly match with the properties they provide read access to. Hence, the get prefix is removed in the file template. The example shows both in action.These are the steps required to get a working ImmutableRecord: Create a class that implements ImmutableRecord and uses the ImmutableRecordLogic trait (either use the file template or create the class by hand). Add properties and their types. You can use the live template record_field, which also adds a constant for each property to avoid typos. Generate getter methods for the properties with appropriate return types. The getter methods should be named like the properties. ImmutableRecordLogic relies on the return types of getter methods to know which property type class should be used when creating a record instance from raw data."},{"id":"https:\/\/event-engine.github.io\/api\/immutable_state.html#3-4-5-1","title":"fromArray vs. fromRecordData","content":"By default ImmutableRecordLogic provides two ways to instantiate an object: fromArray(): create the record from an array containing raw data, especially useful when mapping user input or database results. fromRecordData(): create the record from value objects. &lt;?php declare(strict_types=1); namespace ProophExample; use ProophExample\\ValueObject\\GivenName; use ProophExample\\ValueObject\\Person; use ProophExample\\ValueObject\\UserId; use Ramsey\\Uuid\\Uuid; $john = Person::fromArray([ Person::USER_ID =&gt; Uuid::uuid4()-&gt;toString(), Person::NAME =&gt; 'John', Person::AGE =&gt; 42 ]); $jane = Person::fromRecordData([ Person::USER_ID =&gt; UserId::generate(), Person::NAME =&gt; GivenName::fromString('Jane') ]); It is recommended to add named constructors to a record class using the Ubiquitous Language of the domain. Those methods can use fromRecordData() internally.For example we could add a register() method to our Person class. The UserId is generated internally and Age is nullable and is not required by default.&lt;?php declare(strict_types=1); namespace ProophExample\\ValueObject; use EventEngine\\Data\\ImmutableRecord; use EventEngine\\Data\\ImmutableRecordLogic; final class Person implements ImmutableRecord { use ImmutableRecordLogic; public const USER_ID = 'userId'; public const NAME = 'name'; public const AGE = 'age'; \/** * @var Age|null *\/ private $age; \/** * @var GivenName *\/ private $name; \/** * @var UserId *\/ private $userId; public static function register(GivenName $givenName): self { return self::fromRecordData([ self::USER_ID =&gt; UserId::generate(), self::NAME =&gt; $givenName ]); } \/* ... getter methods *\/ } "},{"id":"https:\/\/event-engine.github.io\/api\/immutable_state.html#3-4-5-2","title":"Nullable Properties","content":"ImmutableRecordLogic validates the given data. If a property (or to be more precise the return type of the corresponding getter method) is not marked as nullable, then it throws an exception. Property data validation is delegated to the property type classes. You don't have to replicate it."},{"id":"https:\/\/event-engine.github.io\/api\/immutable_state.html#3-4-5-3","title":"Array Properties","content":"It's recommended to use the vo_collection live template (see above) to generate lists\/collections as immutable types. Such a type class can then be used for a record property. However, in some cases you might want to use a plain php array instead of an extra class to keep a list of items in a record property. In that case you have to add a private static arrayPropItemTypeMap(): array method, that returns a mapping of property name to type class. PHP does not provide a way to specify array item types in return types (yet). Hence, ImmutableRecordLogic needs a hint.Let's look at an example. We a add a friends property to our Person record, define array as property\/return type and provide a mapping that friends are also of type Person."},{"id":"https:\/\/event-engine.github.io\/api\/immutable_state.html#3-4-5-4","title":"Initialize Properties","content":"If we replace the plain array type of the previous example with the FriendsList generated earlier, our Person class would look like this:&lt;?php declare(strict_types=1); namespace ProophExample\\ValueObject; use EventEngine\\Data\\ImmutableRecord; use EventEngine\\Data\\ImmutableRecordLogic; final class Person implements ImmutableRecord { use ImmutableRecordLogic; public const USER_ID = 'userId'; public const NAME = 'name'; public const AGE = 'age'; public const FRIENDS = 'friends'; \/** * @var FriendsList *\/ private $friends; \/** * @var Age|null *\/ private $age; \/** * @var GivenName *\/ private $name; \/** * @var UserId *\/ private $userId; public static function register(GivenName $givenName): self { return self::fromRecordData([ self::USER_ID =&gt; UserId::generate(), self::NAME =&gt; $givenName ]); } \/** * @return FriendsList *\/ public function friends(): FriendsList { return $this-&gt;friends; } \/* ... other getter methods *\/ } Again: no extra mapping required! Try to favor collection classes over plain arrays!When a new person registers for our service their friends list would be empty. Hence, we don't want to require that property in the register() named constructor. On the other hand we also don't want to make the friendsList property nullable. Iterating over an empty list results in no iteration at all. No need to check against null first. To solve the conflict we can override the empty init() method of ImmutableRecordLogic. The method is called after all properties have been set, but before the null check is performed (which would result in an exception for the current Person::register() implementation).&lt;?php declare(strict_types=1); namespace ProophExample\\ValueObject; use EventEngine\\Data\\ImmutableRecord; use EventEngine\\Data\\ImmutableRecordLogic; final class Person implements ImmutableRecord { use ImmutableRecordLogic; public const USER_ID = 'userId'; public const NAME = 'name'; public const AGE = 'age'; public const FRIENDS = 'friends'; \/** * @var FriendsList *\/ private $friends; \/** * @var Age|null *\/ private $age; \/** * @var GivenName *\/ private $name; \/** * @var UserId *\/ private $userId; public static function register(GivenName $givenName): self { return self::fromRecordData([ self::USER_ID =&gt; UserId::generate(), self::NAME =&gt; $givenName ]); } private function init(): void { if(null === $this-&gt;friends) { $this-&gt;friends = FriendsList::emptyList(); } } \/* ... getter methods *\/ } Never override __construct() of ImmutableRecodLogic! Always use the init() hook for setting default values."},{"id":"https:\/\/event-engine.github.io\/api\/document_store\/set_up.html#3-5-1","title":"Document Store","content":"Work in Progress"},{"id":"https:\/\/event-engine.github.io\/api\/projections\/set_up.html#3-6-1","title":"Custom Projections","content":"Work in Progress"},{"id":"https:\/\/event-engine.github.io\/api\/discolight.html#3-7","title":"Discolight","content":"Event Engine was initially designed as a workshop framework, which is still noticeable in its design. Discolight is one of the nice concepts carried over from workshops into production grade code.Credits: Discolight is inspired by bitExpert\/disco but removes the need for annotations.Discolight is a very small package. It emphasis \"Hand-written service containers\" similar to what Matthias Noback suggests in this blog post."},{"id":"https:\/\/event-engine.github.io\/api\/discolight.html#3-7-1","title":"Installation","content":"composer require event-engine\/discolight "},{"id":"https:\/\/event-engine.github.io\/api\/discolight.html#3-7-2","title":"Service Factory","content":"If you walked your way through the tutorial, you already know about Discolight. The skeleton app comes preconfigured with it.You're asked to provide a ServiceFactory, that contains a public factory method for each dependency. Such a class is included in the skeleton.Note: The skeleton organizes factory methods in module specific traits (src\/Domain\/DomainServices.php, src\/Persistence\/PersistenceServices.php, ...) to keep dependencies manageable. But that's only a suggestion. Each service trait becomes part of the main service factory at runtime. You could also put all methods in one class or organize the traits differently."},{"id":"https:\/\/event-engine.github.io\/api\/discolight.html#3-7-3","title":"Service Ids","content":"The service factory does not need to implement a specific interface. Instead, Discolight scans it and treats all public methods of the class as service factory methods. The return type of a factory method becomes the service id.Let's look at the method which provides the service EventEngine\\Persistence\\MultiModelStore:public function multiModelStore(): MultiModelStore { return $this-&gt;makeSingleton(MultiModelStore::class, function () { return new ComposedMultiModelStore( $this-&gt;transactionalConnection(), $this-&gt;eventEngineEventStore(), $this-&gt;documentStore() ); }); } A lot of stuff going on here, so we'll look at it step by step.public function multiModelStore(): MultiModelStore It's a public method of the ServiceFactory, therefor EventEngine\\Persistence\\MultiModelStore becomes the service id. This means that you can do the following to get the multi model store from Discolight:$store = $discolight-&gt;get(MultiModelStore::class); "},{"id":"https:\/\/event-engine.github.io\/api\/discolight.html#3-7-4","title":"Singleton Service","content":"In most cases we want to get the same instance of a service from the container no matter how often we request it. This is called a Singleton. Discolight is dead simple. It does not know anything about singletons. Instead we use a pattern called memoization to cache the instance of a service in memory and return it from cache on subsequent calls.The ServiceFactory is userland implementation. No interface implementation required. To add memoization to your service factory use the provided trait EventEngine\\Discolight\\ServiceRegistry like it is done in the skeleton service factory.final class ServiceFactory { use ServiceRegistry; \/* use service traits ... *\/ Now you can store service instances in memory:public function multiModelStore(): MultiModelStore { return $this-&gt;makeSingleton(MultiModelStore::class, function () { \/\/... }); } You might recognize that we use MultiModelStore::class again as service id for the registry. The second argument of makeSingleton is a closure which acts as a factory function for the service. When MultiModelStore::class is not in the cache, the factory function is called otherwise the service is returned from the registry."},{"id":"https:\/\/event-engine.github.io\/api\/discolight.html#3-7-5","title":"Injecting Dependencies","content":"Often one service depends on other services. The multi model store requires a TransactionalConnection an EventStore and a DocumentStore and because all services are provided by the same ServiceFactory we can simply get those services by calling the appropriate methods.By default a closure is bound to its parent scope (the service factory instance in this case). Hence, insight the closure we have access to all methods of the service factory no matter if they are declared public, protected or private.public function multiModelStore(): MultiModelStore { return $this-&gt;makeSingleton(MultiModelStore::class, function () { return new ComposedMultiModelStore( $this-&gt;transactionalConnection(), $this-&gt;eventEngineEventStore(), $this-&gt;documentStore() ); }); } The multi model store interface is service id and return type at the same time. Therefor, PHP's type system ensures at runtime that a valid store is returned. Internally, we built a ComposedMultiModelStore. If we want to switch the store we can return another implementation."},{"id":"https:\/\/event-engine.github.io\/api\/discolight.html#3-7-6","title":"Configuration","content":"Another thing that is out of scope for Discolight is application configuration. Remember: providing a working ServiceFactory is your task. When services need configuration then pass it to the ServiceFactory. The skeleton uses environmental variables mapped to config params in config\/autoload\/global.php.The configuration array is then passed to the ServiceFactory in the constructor and wrapped with an ArrayReader:final class ServiceFactory { use ServiceRegistry; \/\/... public function __construct(array $appConfig) { $this-&gt;config = new ArrayReader($appConfig); } This way we have access to the configuration when building our services. We can see this in action in the factory method of the \\PDO connection:public function pdoConnection(): \\PDO { return $this-&gt;makeSingleton(\\PDO::class, function () { $this-&gt;assertMandatoryConfigExists('pdo.dsn'); $this-&gt;assertMandatoryConfigExists('pdo.user'); $this-&gt;assertMandatoryConfigExists('pdo.pwd'); return new \\PDO( $this-&gt;config()-&gt;stringValue('pdo.dsn'), $this-&gt;config()-&gt;stringValue('pdo.user'), $this-&gt;config()-&gt;stringValue('pdo.pwd') ); }); } $this-&gt;assertMandatoryConfigExists(\/*...*\/) is a helper function of the ServiceFactory marked as private. It is ignored by Discolight but we can use it within factory methods.private function assertMandatoryConfigExists(string $path): void { if(null === $this-&gt;config-&gt;mixedValue($path)) { throw new \\RuntimeException(\"Missing application config for $path\"); } } "},{"id":"https:\/\/event-engine.github.io\/api\/discolight.html#3-7-7","title":"Service Alias","content":"In some cases using a full qualified class name (FQCN) of an interface or class as service id is not suitable. In such a case you can configure an alias like shown in the example:$serviceFactory = new \\MyService\\ServiceFactory($config); $container = new \\EventEngine\\Discolight\\Discolight( $serviceFactory, [PostgresEventStore::class =&gt; 'prooph.event_store'] ); You pass a map of service id =&gt; alias name as second argument to Discolight."},{"id":"https:\/\/event-engine.github.io\/api\/discolight.html#3-7-8","title":"Production Optimization","content":"Discolight uses \\Reflection to scan the ServiceFactory class and find out about public factory methods and their return types. It's a myth that reflection is slow. However, rescanning the ServiceFactory on every request in a production environment just does not make sense. Code does not change, so doing it once and remember the result is the better option. $serviceMapCache = null; if(getenv('APP_ENV') === 'prod' &amp;&amp; file_exists('data\/ee.cache.php')) { \/\/Read cache from file $serviceMapCache = require 'data\/ee.cache.php'; } $serviceFactory = new \\MyService\\ServiceFactory($config); $discolight = new \\EventEngine\\Discolight\\Discolight( $serviceFactory, [PostgresEventStore::class =&gt; 'prooph.event_store'], $serviceMapCache \/\/ &lt;-- Pass cache as third argument. If it's NULL a rescan is triggered ); if(!$serviceMapCache &amp;&amp; getenv('APP_ENV') === 'prod') { \/\/ ServiceFactoryMap is an array \/\/ var_export turns that array in a string parsable by PHP \/\/ The cache file itself is a PHP script that returns the array file_put_contents( 'data\/ee.cache.php', \"&lt;?php\\nreturn \" . var_export($discolight-&gt;getServiceFactoryMap(), true) . ';' ); } "},{"id":"https:\/\/event-engine.github.io\/news\/2019-04-05.html#4-1","title":"Event Engine Tutorial Available","content":"Written by Alexander Miertsch (@codeliner) - CEO prooph software GmbH - prooph core team - 2019-04-05Three weeks ago we've released the first dev version of Event Engine, which supersedes Event Machine. Now we reached another important milestone towards a stable release. Make sure to check out the brand new Event Engine tutorial: https:\/\/event-engine.github.io\/tutorial\/ along with a new skeleton application."},{"id":"https:\/\/event-engine.github.io\/news\/2019-04-05.html#4-1-1","title":"Repo Split","content":"A prerequisite for the new skeleton was the repo split announced in the release notes of v0.1. All packages are listed on GitHub and Packagist."},{"id":"https:\/\/event-engine.github.io\/news\/2019-04-05.html#4-1-2","title":"Rewritten Tutorial","content":"The Event Engine tutorial is a rewrite of the previous Event Machine tutorial. The story is the same but it differs in many details like a changed skeleton structure and the usage of the new MultiModelStore feature, which replaces aggregate projections in the default skeleton set up. That said, even if you did the Event Machine tutorial before and think you know the basics, I highly recommend to do the new Event Engine tutorial again to quickly learn more about new features and structural changes."},{"id":"https:\/\/event-engine.github.io\/news\/2019-04-05.html#4-1-3","title":"API Docs","content":"At the time of writing, many API docs are still outdated. You'll find a warning at the top of each page that still needs to be migrated."},{"id":"https:\/\/event-engine.github.io\/news\/2019-04-05.html#4-1-4","title":"Immutable Objects","content":"We've added new documentation about how to quickly generate immutable objects using PHPStorm templates and the event-engine\/php-data package. Learn more"},{"id":"https:\/\/event-engine.github.io\/news\/2019-04-05.html#4-1-5","title":"Keep Up-To-Date","content":"Follow us on twitter and watch changes\/releases on the event-engine repos"}]